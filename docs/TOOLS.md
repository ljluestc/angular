# Developer Tools for AngularHere you will find a collection of tools and tips for keeping your applicationperform well and contain fewer bugs.## Angular debug tools in the dev consoleAngular provides a set of debug tools that are accessible from any browser'sdeveloper console. In Chrome the dev console can be accessed by pressingCtrl + Shift + j.### Enabling debug toolsBy default the debug tools are disabled. You can enable debug tools as follows:```typescriptimport {ApplicationRef} from '@angular/core';import {platformBrowserDynamic} from '@angular/platform-browser-dynamic';import {enableDebugTools} from '@angular/platform-browser';platformBrowserDynamic().bootstrapModule(AppModule)  .then(moduleRef => {    const applicationRef = moduleRef.injector.get(ApplicationRef);    const appComponent = applicationRef.components[0];    enableDebugTools(appComponent);  })```### Using debug toolsIn the browser open the developer console (Ctrl + Shift + j in Chrome). Thetop level object is called `ng` and contains more specific tools inside it.Example:```javascriptng.profiler.timeChangeDetection();```## Performance### Change detection profilerIf your application is janky (it misses frames) or is slow according to othermetrics, it is important to find the root cause of the issue. Change detectionis a phase in Angular's lifecycle that detects changes in values that arebound to UI, and if it finds a change it performs the corresponding UI update.However, sometimes it is hard to tell if the slowness is due to the act ofcomputing the changes being slow, or due to the act of applying those changesto the UI. For your application to be performant it is important that theprocess of computing changes is very fast. For best results it should be under3 milliseconds in order to leave room for the application logic, the UI updatesand browser's rendering pipeline to fit within the 16 millisecond frame(assuming the 60 FPS target frame rate).Change detection profiler repeatedly performs change detection without invokingany user actions, such as clicking buttons or entering text in input fields. Itthen computes the average amount of time it took to perform a single cycle ofchange detection in milliseconds and prints it to the console. This numberdepends on the current state of the UI. You will likely see different numbersas you go from one screen in your application to another.#### Running the profilerEnable debug tools (see above), then in the dev console enter the following:```javascriptng.profiler.timeChangeDetection();```The results will be printed to the console.#### Recording CPU profilePass `{record: true}` an argument:```javascriptng.profiler.timeChangeDetection({record: true});```Then open the "Profiles" tab. You will see the recorded profile titled"Change Detection". In Chrome, if you record the profile repeatedly, all theprofiles will be nested under "Change Detection".#### Interpreting the numbersIn a properly-designed application repeated attempts to detect changes withoutany user actions should result in no changes to be applied on the UI. It isalso desirable to have the cost of a user action be proportional to the amountof UI changes required. For example, popping up a menu with 5 items should bevastly faster than rendering a table of 500 rows and 10 columns. Therefore,change detection with no UI updates should be as fast as possible. Ideally thenumber printed by the profiler should be well below the length of a singleanimation frame (16ms). A good rule of thumb is to keep it under 3ms.#### Investigating slow change detectionSo you found a screen in your application on which the profiler reports a veryhigh number (i.e. >3ms). This is where a recorded CPU profile can help. Enablerecording while profiling:```javascriptng.profiler.timeChangeDetection({record: true});```Then look for hot spots using[Chrome CPU profiler](https://developer.chrome.com/devtools/docs/cpu-profiling).#### Reducing change detection costThere are many reasons for slow change detection. To gain intuition aboutpossible causes it would help to understand how change detection works. Such adiscussion is outside the scope of this document (TODO link to docs), but hereare some key concepts in brief.By default Angular uses "dirty checking" mechanism for finding model changes.This mechanism involves evaluating every bound expression that's active on theUI. These usually include text interpolation via `{{expression}}` and propertybindings via `[prop]="expression"`. If any of the evaluated expressions arecostly to compute they could contribute to slow change detection. A good way tospeed things up is to use plain class fields in your expressions and avoid anykinds of computation. Example:```typescript@Component({  template: '<button [enabled]="isEnabled">{{title}}</button>'})class FancyButton {  // GOOD: no computation, just return the value  isEnabled: boolean;  // BAD: computes the final value upon request  _title: String;  get title(): String { return this._title.trim().toUpperCase(); }}```Most cases like these could be solved by precomputing the value and storing thefinal value in a field.Angular also supports a second type of change detection - the "push" model. Inthis model Angular does not poll your component for changes. Instead, thecomponent "tells" Angular when it changes and only then does Angular performthe update. This model is suitable in situations when your data model usesobservable or immutable objects (also a discussion for another time).