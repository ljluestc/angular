## API Report File for "@angular/core"> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).```tsimport { Observable } from 'rxjs';import { Subject } from 'rxjs';import { Subscription } from 'rxjs';// @publicexport interface AbstractType<T> extends Function {// (undocumented)prototype: T;}// @publicexport interface AfterContentChecked {ngAfterContentChecked(): void;}// @publicexport interface AfterContentInit {ngAfterContentInit(): void;}// @publicexport function afterNextRender(callback: VoidFunction, options?: AfterRenderOptions): AfterRenderRef;// @publicexport function afterRender(callback: VoidFunction, options?: AfterRenderOptions): AfterRenderRef;// @publicexport interface AfterRenderOptions {injector?: Injector;}// @publicexport interface AfterRenderRef {destroy(): void;}// @publicexport interface AfterViewChecked {ngAfterViewChecked(): void;}// @publicexport interface AfterViewInit {ngAfterViewInit(): void;}// @publicexport const ANIMATION_MODULE_TYPE: InjectionToken<"NoopAnimations" | "BrowserAnimations">;// @publicexport const APP_BOOTSTRAP_LISTENER: InjectionToken<readonly ((compRef: ComponentRef<any>) => void)[]>;// @publicexport const APP_ID: InjectionToken<string>;// @publicexport const APP_INITIALIZER: InjectionToken<readonly (() => Observable<unknown> | Promise<unknown> | void)[]>;// @publicexport interface ApplicationConfig {providers: Array<Provider | EnvironmentProviders>;}// @publicexport class ApplicationInitStatus {constructor();// (undocumented)readonly done = false;// (undocumented)readonly donePromise: Promise<any>;// (undocumented)static ɵfac: i0.ɵɵFactoryDeclaration<ApplicationInitStatus, never>;// (undocumented)static ɵprov: i0.ɵɵInjectableDeclaration<ApplicationInitStatus>;}// @publicexport class ApplicationModule {constructor(appRef: ApplicationRef);// (undocumented)static ɵfac: i0.ɵɵFactoryDeclaration<ApplicationModule, never>;// (undocumented)static ɵinj: i0.ɵɵInjectorDeclaration<ApplicationModule>;// (undocumented)static ɵmod: i0.ɵɵNgModuleDeclaration<ApplicationModule, never, never, never>;}// @publicexport class ApplicationRef {attachView(viewRef: ViewRef): void;bootstrap<C>(component: Type<C>, rootSelectorOrNode?: string | any): ComponentRef<C>;// @deprecatedbootstrap<C>(componentFactory: ComponentFactory<C>, rootSelectorOrNode?: string | any): ComponentRef<C>;readonly components: ComponentRef<any>[];readonly componentTypes: Type<any>[];destroy(): void;get destroyed(): boolean;detachView(viewRef: ViewRef): void;get injector(): EnvironmentInjector;readonly isStable: Observable<boolean>;onDestroy(callback: () => void): VoidFunction;tick(): void;get viewCount(): number;// (undocumented)static ɵfac: i0.ɵɵFactoryDeclaration<ApplicationRef, never>;// (undocumented)static ɵprov: i0.ɵɵInjectableDeclaration<ApplicationRef>;}// @public (undocumented)export function asNativeElements(debugEls: DebugElement[]): any;// @publicexport function assertInInjectionContext(debugFn: Function): void;// @publicexport function assertPlatform(requiredToken: any): PlatformRef;// @publicexport interface Attribute {attributeName: string;}// @publicexport const Attribute: AttributeDecorator;// @publicexport interface AttributeDecorator {(name: string): any;// (undocumented)new (name: string): Attribute;}// @publicexport function booleanAttribute(value: unknown): boolean;// @publicexport interface BootstrapOptions {ngZone?: NgZone | 'zone.js' | 'noop';ngZoneEventCoalescing?: boolean;ngZoneRunCoalescing?: boolean;}// @publicexport enum ChangeDetectionStrategy {Default = 1,OnPush = 0}// @publicexport abstract class ChangeDetectorRef {abstract checkNoChanges(): void;abstract detach(): void;abstract detectChanges(): void;abstract markForCheck(): void;abstract reattach(): void;}// @publicexport interface ClassProvider extends ClassSansProvider {multi?: boolean;provide: any;}// @publicexport interface ClassSansProvider {useClass: Type<any>;}// @public @deprecatedexport class Compiler {clearCache(): void;clearCacheFor(type: Type<any>): void;compileModuleAndAllComponentsAsync<T>(moduleType: Type<T>): Promise<ModuleWithComponentFactories<T>>;compileModuleAndAllComponentsSync<T>(moduleType: Type<T>): ModuleWithComponentFactories<T>;compileModuleAsync<T>(moduleType: Type<T>): Promise<NgModuleFactory<T>>;compileModuleSync<T>(moduleType: Type<T>): NgModuleFactory<T>;getModuleId(moduleType: Type<any>): string | undefined;// (undocumented)static ɵfac: i0.ɵɵFactoryDeclaration<Compiler, never>;// (undocumented)static ɵprov: i0.ɵɵInjectableDeclaration<Compiler>;}// @publicexport const COMPILER_OPTIONS: InjectionToken<CompilerOptions[]>;// @public @deprecatedexport abstract class CompilerFactory {// (undocumented)abstract createCompiler(options?: CompilerOptions[]): Compiler;}// @publicexport type CompilerOptions = {useJit?: boolean;defaultEncapsulation?: ViewEncapsulation;providers?: StaticProvider[];missingTranslation?: MissingTranslationStrategy;preserveWhitespaces?: boolean;};// @publicexport interface Component extends Directive {animations?: any[];changeDetection?: ChangeDetectionStrategy;encapsulation?: ViewEncapsulation;imports?: (Type<any> | ReadonlyArray<any>)[];interpolation?: [string, string];// @deprecatedmoduleId?: string;preserveWhitespaces?: boolean;schemas?: SchemaMetadata[];standalone?: boolean;styles?: string | string[];styleUrl?: string;styleUrls?: string[];template?: string;templateUrl?: string;viewProviders?: Provider[];}// @publicexport const Component: ComponentDecorator;// @publicexport interface ComponentDecorator {(obj: Component): TypeDecorator;new (obj: Component): Component;}// @public @deprecatedexport abstract class ComponentFactory<C> {abstract get componentType(): Type<any>;abstract create(injector: Injector, projectableNodes?: any[][], rootSelectorOrNode?: string | any, environmentInjector?: EnvironmentInjector | NgModuleRef<any>): ComponentRef<C>;abstract get inputs(): { propName: string; templateName: string; transform?: (value: any) => any;}[];abstract get ngContentSelectors(): string[];abstract get outputs(): { propName: string; templateName: string;}[];abstract get selector(): string;}// @public @deprecatedexport abstract class ComponentFactoryResolver {// (undocumented)static NULL: ComponentFactoryResolver;abstract resolveComponentFactory<T>(component: Type<T>): ComponentFactory<T>;}// @publicexport interface ComponentMirror<C> {get inputs(): ReadonlyArray<{ readonly propName: string; readonly templateName: string; readonly transform?: (value: any) => any;}>;get isStandalone(): boolean;get ngContentSelectors(): ReadonlyArray<string>;get outputs(): ReadonlyArray<{ readonly propName: string; readonly templateName: string;}>;get selector(): string;get type(): Type<C>;}// @publicexport abstract class ComponentRef<C> {abstract get changeDetectorRef(): ChangeDetectorRef;abstract get componentType(): Type<any>;abstract destroy(): void;abstract get hostView(): ViewRef;abstract get injector(): Injector;abstract get instance(): C;abstract get location(): ElementRef;abstract onDestroy(callback: Function): void;abstract setInput(name: string, value: unknown): void;}// @publicexport function computed<T>(computation: () => T, options?: CreateComputedOptions<T>): Signal<T>;// @publicexport interface ConstructorProvider extends ConstructorSansProvider {multi?: boolean;provide: Type<any>;}// @publicexport interface ConstructorSansProvider {deps?: any[];}// @publicexport type ContentChild = Query;// @publicexport const ContentChild: ContentChildDecorator;// @publicexport interface ContentChildDecorator {(selector: ProviderToken<unknown> | Function | string, opts?: { descendants?: boolean; read?: any; static?: boolean;}): any;// (undocumented)new (selector: ProviderToken<unknown> | Function | string, opts?: { descendants?: boolean; read?: any; static?: boolean;}): ContentChild;}// @publicexport type ContentChildren = Query;// @publicexport const ContentChildren: ContentChildrenDecorator;// @publicexport interface ContentChildrenDecorator {(selector: ProviderToken<unknown> | Function | string, opts?: { descendants?: boolean; emitDistinctChangesOnly?: boolean; read?: any;}): any;// (undocumented)new (selector: ProviderToken<unknown> | Function | string, opts?: { descendants?: boolean; emitDistinctChangesOnly?: boolean; read?: any;}): Query;}// @publicexport function createComponent<C>(component: Type<C>, options: {environmentInjector: EnvironmentInjector;hostElement?: Element;elementInjector?: Injector;projectableNodes?: Node[][];}): ComponentRef<C>;// @publicexport interface CreateComputedOptions<T> {equal?: ValueEqualityFn<T>;}// @publicexport interface CreateEffectOptions {allowSignalWrites?: boolean;injector?: Injector;manualCleanup?: boolean;}// @publicexport function createEnvironmentInjector(providers: Array<Provider | EnvironmentProviders>, parent: EnvironmentInjector, debugName?: string | null): EnvironmentInjector;// @publicexport function createNgModule<T>(ngModule: Type<T>, parentInjector?: Injector): NgModuleRef<T>;// @public @deprecatedexport const createNgModuleRef: typeof createNgModule;// @publicexport function createPlatform(injector: Injector): PlatformRef;// @publicexport function createPlatformFactory(parentPlatformFactory: ((extraProviders?: StaticProvider[]) => PlatformRef) | null, name: string, providers?: StaticProvider[]): (extraProviders?: StaticProvider[]) => PlatformRef;// @publicexport interface CreateSignalOptions<T> {equal?: ValueEqualityFn<T>;}// @publicexport const CSP_NONCE: InjectionToken<string | null>;// @publicexport const CUSTOM_ELEMENTS_SCHEMA: SchemaMetadata;// @public (undocumented)export class DebugElement extends DebugNode {constructor(nativeNode: Element);get attributes(): { [key: string]: string | null;};get childNodes(): DebugNode[];get children(): DebugElement[];get classes(): { [key: string]: boolean;};get name(): string;get nativeElement(): any;get properties(): { [key: string]: any;};// (undocumented)query(predicate: Predicate<DebugElement>): DebugElement;// (undocumented)queryAll(predicate: Predicate<DebugElement>): DebugElement[];// (undocumented)queryAllNodes(predicate: Predicate<DebugNode>): DebugNode[];get styles(): { [key: string]: string | null;};triggerEventHandler(eventName: string, eventObj?: any): void;}// @public (undocumented)export class DebugEventListener {constructor(name: string, callback: Function);// (undocumented)callback: Function;// (undocumented)name: string;}// @public (undocumented)export class DebugNode {constructor(nativeNode: Node);get componentInstance(): any;get context(): any;get injector(): Injector;get listeners(): DebugEventListener[];readonly nativeNode: any;get parent(): DebugElement | null;get providerTokens(): any[];get references(): { [key: string]: any;};}// @publicexport const DEFAULT_CURRENCY_CODE: InjectionToken<string>;// @public @deprecated (undocumented)export class DefaultIterableDiffer<V> implements IterableDiffer<V>, IterableChanges<V> {constructor(trackByFn?: TrackByFunction<V>);// (undocumented)check(collection: NgIterable<V>): boolean;// (undocumented)readonly collection: V[] | Iterable<V> | null;// (undocumented)diff(collection: NgIterable<V> | null | undefined): DefaultIterableDiffer<V> | null;// (undocumented)forEachAddedItem(fn: (record: IterableChangeRecord_<V>) => void): void;// (undocumented)forEachIdentityChange(fn: (record: IterableChangeRecord_<V>) => void): void;// (undocumented)forEachItem(fn: (record: IterableChangeRecord_<V>) => void): void;// (undocumented)forEachMovedItem(fn: (record: IterableChangeRecord_<V>) => void): void;// (undocumented)forEachOperation(fn: (item: IterableChangeRecord<V>, previousIndex: number | null, currentIndex: number | null) => void): void;// (undocumented)forEachPreviousItem(fn: (record: IterableChangeRecord_<V>) => void): void;// (undocumented)forEachRemovedItem(fn: (record: IterableChangeRecord_<V>) => void): void;// (undocumented)get isDirty(): boolean;// (undocumented)readonly length: number;// (undocumented)onDestroy(): void;}// @public @deprecated (undocumented)export const defineInjectable: typeof ɵɵdefineInjectable;// @publicexport function destroyPlatform(): void;// @publicexport abstract class DestroyRef {abstract onDestroy(callback: () => void): () => void;}// @publicexport interface Directive {exportAs?: string;host?: { [key: string]: string;};hostDirectives?: (Type<unknown> | { directive: Type<unknown>; inputs?: string[]; outputs?: string[];})[];inputs?: ({ name: string; alias?: string; required?: boolean; transform?: (value: any) => any;} | string)[];jit?: true;outputs?: string[];providers?: Provider[];queries?: { [key: string]: any;};selector?: string;standalone?: boolean;}// @publicexport const Directive: DirectiveDecorator;// @publicexport interface DirectiveDecorator {(obj?: Directive): TypeDecorator;new (obj?: Directive): Directive;}// @publicexport interface DoBootstrap {// (undocumented)ngDoBootstrap(appRef: ApplicationRef): void;}// @publicexport interface DoCheck {ngDoCheck(): void;}// @publicexport function effect(effectFn: (onCleanup: EffectCleanupRegisterFn) => void, options?: CreateEffectOptions): EffectRef;// @publicexport type EffectCleanupFn = () => void;// @publicexport interface EffectRef {destroy(): void;}// @publicexport class ElementRef<T = any> {constructor(nativeElement: T);nativeElement: T;}// @publicexport abstract class EmbeddedViewRef<C> extends ViewRef {abstract context: C;abstract get rootNodes(): any[];}// @publicexport function enableProdMode(): void;// @publicexport const ENVIRONMENT_INITIALIZER: InjectionToken<readonly (() => void)[]>;// @publicexport abstract class EnvironmentInjector implements Injector {// (undocumented)abstract destroy(): void;abstract get<T>(token: ProviderToken<T>, notFoundValue: undefined, options: InjectOptions & { optional?: false;}): T;abstract get<T>(token: ProviderToken<T>, notFoundValue: null | undefined, options: InjectOptions): T | null;abstract get<T>(token: ProviderToken<T>, notFoundValue?: T, options?: InjectOptions): T;// @deprecatedabstract get<T>(token: ProviderToken<T>, notFoundValue?: T, flags?: InjectFlags): T;// @deprecated (undocumented)abstract get(token: any, notFoundValue?: any): any;// @deprecatedabstract runInContext<ReturnT>(fn: () => ReturnT): ReturnT;}// @publicexport type EnvironmentProviders = {ɵbrand: 'EnvironmentProviders';};// @publicexport class ErrorHandler {// (undocumented)handleError(error: any): void;}// @publicexport interface EventEmitter<T> extends Subject<T> {new (isAsync?: boolean): EventEmitter<T>;emit(value?: T): void;subscribe(next?: (value: T) => void, error?: (error: any) => void, complete?: () => void): Subscription;subscribe(observerOrNext?: any, error?: any, complete?: any): Subscription;}// @public (undocumented)export const EventEmitter: {new (isAsync?: boolean): EventEmitter<any>;new <T>(isAsync?: boolean): EventEmitter<T>;readonly prototype: EventEmitter<any>;};// @publicexport interface ExistingProvider extends ExistingSansProvider {multi?: boolean;provide: any;}// @publicexport interface ExistingSansProvider {useExisting: any;}// @publicexport interface FactoryProvider extends FactorySansProvider {multi?: boolean;provide: any;}// @publicexport interface FactorySansProvider {deps?: any[];useFactory: Function;}// @publicexport function forwardRef(forwardRefFn: ForwardRefFn): Type<any>;// @publicexport interface ForwardRefFn {// (undocumented)(): any;}// @public (undocumented)export function getDebugNode(nativeNode: any): DebugNode | null;// @public @deprecatedexport function getModuleFactory(id: string): NgModuleFactory<any>;// @publicexport function getNgModuleById<T>(id: string): Type<T>;// @publicexport function getPlatform(): PlatformRef | null;// @publicexport interface GetTestability {// (undocumented)addToWindow(registry: TestabilityRegistry): void;// (undocumented)findTestabilityInTree(registry: TestabilityRegistry, elem: any, findInAncestors: boolean): Testability | null;}// @publicexport interface Host {}// @publicexport const Host: HostDecorator;// @publicexport interface HostBinding {hostPropertyName?: string;}// @public (undocumented)export const HostBinding: HostBindingDecorator;// @publicexport interface HostBindingDecorator {(hostPropertyName?: string): any;// (undocumented)new (hostPropertyName?: string): any;}// @publicexport interface HostDecorator {(): any;// (undocumented)new (): Host;}// @publicexport interface HostListener {args?: string[];eventName?: string;}// @publicexport const HostListener: HostListenerDecorator;// @publicexport interface HostListenerDecorator {(eventName: string, args?: string[]): any;// (undocumented)new (eventName: string, args?: string[]): any;}// @public @deprecatedexport type ImportedNgModuleProviders = EnvironmentProviders;// @publicexport function importProvidersFrom(...sources: ImportProvidersSource[]): EnvironmentProviders;// @publicexport type ImportProvidersSource = Type<unknown> | ModuleWithProviders<unknown> | Array<ImportProvidersSource>;// @publicexport interface Inject {token: any;}// @publicexport const Inject: InjectDecorator;// @public (undocumented)export function inject<T>(token: ProviderToken<T>): T;// @public @deprecated (undocumented)export function inject<T>(token: ProviderToken<T>, flags?: InjectFlags): T | null;// @public (undocumented)export function inject<T>(token: ProviderToken<T>, options: InjectOptions & {optional?: false;}): T;// @public (undocumented)export function inject<T>(token: ProviderToken<T>, options: InjectOptions): T | null;// @publicexport interface Injectable {providedIn?: Type<any> | 'root' | 'platform' | 'any' | null;}// @publicexport const Injectable: InjectableDecorator;// @publicexport interface InjectableDecorator {(): TypeDecorator;// (undocumented)(options?: { providedIn: Type<any> | 'root' | 'platform' | 'any' | null;} & InjectableProvider): TypeDecorator;// (undocumented)new (): Injectable;// (undocumented)new (options?: { providedIn: Type<any> | 'root' | 'platform' | 'any' | null;} & InjectableProvider): Injectable;}// @publicexport type InjectableProvider = ValueSansProvider | ExistingSansProvider | StaticClassSansProvider | ConstructorSansProvider | FactorySansProvider | ClassSansProvider;// @publicexport interface InjectableType<T> extends Type<T> {ɵprov: unknown;}// @publicexport interface InjectDecorator {(token: any): any;// (undocumented)new (token: any): Inject;}// @public @deprecatedexport enum InjectFlags {Default = 0,Host = 1,Optional = 8,Self = 2,SkipSelf = 4}// @publicexport class InjectionToken<T> {constructor(_desc: string, options?: { providedIn?: Type<any> | 'root' | 'platform' | 'any' | null; factory: () => T;});// (undocumented)protected _desc: string;// (undocumented)toString(): string;// (undocumented)readonly ɵprov: unknown;}// @publicexport interface InjectOptions {host?: boolean;optional?: boolean;self?: boolean;skipSelf?: boolean;}// @publicexport const INJECTOR: InjectionToken<Injector>;// @publicexport abstract class Injector {// @deprecated (undocumented)static create(providers: StaticProvider[], parent?: Injector): Injector;static create(options: { providers: Array<Provider | StaticProvider>; parent?: Injector; name?: string;}): Injector;abstract get<T>(token: ProviderToken<T>, notFoundValue: undefined, options: InjectOptions & { optional?: false;}): T;abstract get<T>(token: ProviderToken<T>, notFoundValue: null | undefined, options: InjectOptions): T | null;abstract get<T>(token: ProviderToken<T>, notFoundValue?: T, options?: InjectOptions | InjectFlags): T;// @deprecatedabstract get<T>(token: ProviderToken<T>, notFoundValue?: T, flags?: InjectFlags): T;// @deprecated (undocumented)abstract get(token: any, notFoundValue?: any): any;// (undocumented)static NULL: Injector;// (undocumented)static THROW_IF_NOT_FOUND: {};// (undocumented)static ɵprov: unknown;}// @publicexport interface InjectorType<T> extends Type<T> {// (undocumented)ɵfac?: unknown;// (undocumented)ɵinj: unknown;}// @publicexport interface Input {alias?: string;required?: boolean;transform?: (value: any) => any;}// @public (undocumented)export const Input: InputDecorator;// @public (undocumented)export interface InputDecorator {(arg?: string | Input): any;// (undocumented)new (arg?: string | Input): any;}// @publicexport function isDevMode(): boolean;// @publicexport function isSignal(value: unknown): value is Signal<unknown>;// @publicexport function isStandalone(type: Type<unknown>): boolean;// @publicexport interface IterableChangeRecord<V> {readonly currentIndex: number | null;readonly item: V;readonly previousIndex: number | null;readonly trackById: any;}// @publicexport interface IterableChanges<V> {forEachAddedItem(fn: (record: IterableChangeRecord<V>) => void): void;forEachIdentityChange(fn: (record: IterableChangeRecord<V>) => void): void;forEachItem(fn: (record: IterableChangeRecord<V>) => void): void;forEachMovedItem(fn: (record: IterableChangeRecord<V>) => void): void;forEachOperation(fn: (record: IterableChangeRecord<V>, previousIndex: number | null, currentIndex: number | null) => void): void;forEachPreviousItem(fn: (record: IterableChangeRecord<V>) => void): void;forEachRemovedItem(fn: (record: IterableChangeRecord<V>) => void): void;}// @publicexport interface IterableDiffer<V> {diff(object: NgIterable<V> | undefined | null): IterableChanges<V> | null;}// @publicexport interface IterableDifferFactory {// (undocumented)create<V>(trackByFn?: TrackByFunction<V>): IterableDiffer<V>;// (undocumented)supports(objects: any): boolean;}// @publicexport class IterableDiffers {constructor(factories: IterableDifferFactory[]);// (undocumented)static create(factories: IterableDifferFactory[], parent?: IterableDiffers): IterableDiffers;static extend(factories: IterableDifferFactory[]): StaticProvider;// (undocumented)find(iterable: any): IterableDifferFactory;// (undocumented)static ɵprov: unknown;}// @publicexport interface KeyValueChangeRecord<K, V> {readonly currentValue: V | null;readonly key: K;readonly previousValue: V | null;}// @publicexport interface KeyValueChanges<K, V> {forEachAddedItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;forEachChangedItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;forEachItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;forEachPreviousItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;forEachRemovedItem(fn: (r: KeyValueChangeRecord<K, V>) => void): void;}// @publicexport interface KeyValueDiffer<K, V> {diff(object: Map<K, V>): KeyValueChanges<K, V> | null;diff(object: { [key: string]: V;}): KeyValueChanges<string, V> | null;}// @publicexport interface KeyValueDifferFactory {create<K, V>(): KeyValueDiffer<K, V>;supports(objects: any): boolean;}// @publicexport class KeyValueDiffers {constructor(factories: KeyValueDifferFactory[]);// (undocumented)static create<S>(factories: KeyValueDifferFactory[], parent?: KeyValueDiffers): KeyValueDiffers;static extend<S>(factories: KeyValueDifferFactory[]): StaticProvider;// @deprecated (undocumented)factories: KeyValueDifferFactory[];// (undocumented)find(kv: any): KeyValueDifferFactory;// (undocumented)static ɵprov: unknown;}// @publicexport const LOCALE_ID: InjectionToken<string>;// @publicexport function makeEnvironmentProviders(providers: (Provider | EnvironmentProviders)[]): EnvironmentProviders;// @publicexport function makeStateKey<T = void>(key: string): StateKey<T>;// @publicexport function mergeApplicationConfig(...configs: ApplicationConfig[]): ApplicationConfig;// @publicexport enum MissingTranslationStrategy {// (undocumented)Error = 0,// (undocumented)Ignore = 2,// (undocumented)Warning = 1}// @public @deprecatedexport class ModuleWithComponentFactories<T> {constructor(ngModuleFactory: NgModuleFactory<T>, componentFactories: ComponentFactory<any>[]);// (undocumented)componentFactories: ComponentFactory<any>[];// (undocumented)ngModuleFactory: NgModuleFactory<T>;}// @publicexport interface ModuleWithProviders<T> {// (undocumented)ngModule: Type<T>;// (undocumented)providers?: Array<Provider | EnvironmentProviders>;}// @publicexport type NgIterable<T> = Array<T> | Iterable<T>;// @publicexport interface NgModule {bootstrap?: Array<Type<any> | any[]>;declarations?: Array<Type<any> | any[]>;exports?: Array<Type<any> | any[]>;id?: string;imports?: Array<Type<any> | ModuleWithProviders<{}> | any[]>;jit?: true;providers?: Array<Provider | EnvironmentProviders>;schemas?: Array<SchemaMetadata | any[]>;}// @public (undocumented)export const NgModule: NgModuleDecorator;// @publicexport interface NgModuleDecorator {(obj?: NgModule): TypeDecorator;// (undocumented)new (obj?: NgModule): NgModule;}// @public @deprecated (undocumented)export abstract class NgModuleFactory<T> {// (undocumented)abstract create(parentInjector: Injector | null): NgModuleRef<T>;// (undocumented)abstract get moduleType(): Type<T>;}// @publicexport abstract class NgModuleRef<T> {// @deprecatedabstract get componentFactoryResolver(): ComponentFactoryResolver;abstract destroy(): void;abstract get injector(): EnvironmentInjector;abstract get instance(): T;abstract onDestroy(callback: () => void): void;}// @publicexport class NgProbeToken {constructor(name: string, token: any);// (undocumented)name: string;// (undocumented)token: any;}// @publicexport class NgZone {constructor({ enableLongStackTrace, shouldCoalesceEventChangeDetection, shouldCoalesceRunChangeDetection }: { enableLongStackTrace?: boolean | undefined; shouldCoalesceEventChangeDetection?: boolean | undefined; shouldCoalesceRunChangeDetection?: boolean | undefined;});static assertInAngularZone(): void;static assertNotInAngularZone(): void;// (undocumented)readonly hasPendingMacrotasks: boolean;// (undocumented)readonly hasPendingMicrotasks: boolean;static isInAngularZone(): boolean;readonly isStable: boolean;readonly onError: EventEmitter<any>;readonly onMicrotaskEmpty: EventEmitter<any>;readonly onStable: EventEmitter<any>;readonly onUnstable: EventEmitter<any>;run<T>(fn: (...args: any[]) => T, applyThis?: any, applyArgs?: any[]): T;runGuarded<T>(fn: (...args: any[]) => T, applyThis?: any, applyArgs?: any[]): T;runOutsideAngular<T>(fn: (...args: any[]) => T): T;runTask<T>(fn: (...args: any[]) => T, applyThis?: any, applyArgs?: any[], name?: string): T;}// @publicexport interface NgZoneOptions {eventCoalescing?: boolean;runCoalescing?: boolean;}// @publicexport const NO_ERRORS_SCHEMA: SchemaMetadata;// @publicexport function numberAttribute(value: unknown, fallbackValue?: number): number;// @publicexport interface OnChanges {ngOnChanges(changes: SimpleChanges): void;}// @publicexport interface OnDestroy {ngOnDestroy(): void;}// @publicexport interface OnInit {ngOnInit(): void;}// @publicexport interface Optional {}// @publicexport const Optional: OptionalDecorator;// @publicexport interface OptionalDecorator {(): any;// (undocumented)new (): Optional;}// @publicexport interface Output {alias?: string;}// @public (undocumented)export const Output: OutputDecorator;// @publicexport interface OutputDecorator {(alias?: string): any;// (undocumented)new (alias?: string): any;}// @public @deprecatedexport const PACKAGE_ROOT_URL: InjectionToken<string>;// @publicexport interface Pipe {name: string;pure?: boolean;standalone?: boolean;}// @public (undocumented)export const Pipe: PipeDecorator;// @publicexport interface PipeDecorator {(obj: Pipe): TypeDecorator;new (obj: Pipe): Pipe;}// @publicexport interface PipeTransform {// (undocumented)transform(value: any, ...args: any[]): any;}// @publicexport const PLATFORM_ID: InjectionToken<Object>;// @publicexport const PLATFORM_INITIALIZER: InjectionToken<readonly (() => void)[]>;// @publicexport const platformCore: (extraProviders?: StaticProvider[] | undefined) => PlatformRef;// @publicexport class PlatformRef {bootstrapModule<M>(moduleType: Type<M>, compilerOptions?: (CompilerOptions & BootstrapOptions) | Array<CompilerOptions & BootstrapOptions>): Promise<NgModuleRef<M>>;// @deprecatedbootstrapModuleFactory<M>(moduleFactory: NgModuleFactory<M>, options?: BootstrapOptions): Promise<NgModuleRef<M>>;destroy(): void;get destroyed(): boolean;get injector(): Injector;onDestroy(callback: () => void): void;// (undocumented)static ɵfac: i0.ɵɵFactoryDeclaration<PlatformRef, never>;// (undocumented)static ɵprov: i0.ɵɵInjectableDeclaration<PlatformRef>;}// @publicexport interface Predicate<T> {// (undocumented)(value: T): boolean;}// @publicexport type Provider = TypeProvider | ValueProvider | ClassProvider | ConstructorProvider | ExistingProvider | FactoryProvider | any[];// @publicexport type ProviderToken<T> = Type<T> | AbstractType<T> | InjectionToken<T>;// @publicexport function provideZoneChangeDetection(options?: NgZoneOptions): EnvironmentProviders;// @publicexport interface Query {// (undocumented)descendants: boolean;// (undocumented)emitDistinctChangesOnly: boolean;// (undocumented)first: boolean;// (undocumented)isViewQuery: boolean;// (undocumented)read: any;// (undocumented)selector: any;// (undocumented)static?: boolean;}// @publicexport abstract class Query {}// @publicexport class QueryList<T> implements Iterable<T> {// (undocumented)[Symbol.iterator]: () => Iterator<T>;constructor(_emitDistinctChangesOnly?: boolean);get changes(): Observable<any>;destroy(): void;// (undocumented)readonly dirty = true;filter<S extends T>(predicate: (value: T, index: number, array: readonly T[]) => value is S): S[];// (undocumented)filter(predicate: (value: T, index: number, array: readonly T[]) => unknown): T[];find(fn: (item: T, index: number, array: T[]) => boolean): T | undefined;// (undocumented)readonly first: T;forEach(fn: (item: T, index: number, array: T[]) => void): void;get(index: number): T | undefined;// (undocumented)readonly last: T;// (undocumented)readonly length: number;map<U>(fn: (item: T, index: number, array: T[]) => U): U[];notifyOnChanges(): void;reduce<U>(fn: (prevValue: U, curValue: T, curIndex: number, array: T[]) => U, init: U): U;reset(resultsTree: Array<T | any[]>, identityAccessor?: (value: T) => unknown): void;setDirty(): void;some(fn: (value: T, index: number, array: T[]) => boolean): boolean;toArray(): T[];// (undocumented)toString(): string;}// @publicexport function reflectComponentType<C>(component: Type<C>): ComponentMirror<C> | null;// @publicexport abstract class Renderer2 {abstract addClass(el: any, name: string): void;abstract appendChild(parent: any, newChild: any): void;abstract createComment(value: string): any;abstract createElement(name: string, namespace?: string | null): any;abstract createText(value: string): any;abstract get data(): { [key: string]: any;};abstract destroy(): void;destroyNode: ((node: any) => void) | null;abstract insertBefore(parent: any, newChild: any, refChild: any, isMove?: boolean): void;abstract listen(target: 'window' | 'document' | 'body' | any, eventName: string, callback: (event: any) => boolean | void): () => void;abstract nextSibling(node: any): any;abstract parentNode(node: any): any;abstract removeAttribute(el: any, name: string, namespace?: string | null): void;abstract removeChild(parent: any, oldChild: any, isHostElement?: boolean): void;abstract removeClass(el: any, name: string): void;abstract removeStyle(el: any, style: string, flags?: RendererStyleFlags2): void;abstract selectRootElement(selectorOrNode: string | any, preserveContent?: boolean): any;abstract setAttribute(el: any, name: string, value: string, namespace?: string | null): void;abstract setProperty(el: any, name: string, value: any): void;abstract setStyle(el: any, style: string, value: any, flags?: RendererStyleFlags2): void;abstract setValue(node: any, value: string): void;}// @publicexport abstract class RendererFactory2 {abstract begin?(): void;abstract createRenderer(hostElement: any, type: RendererType2 | null): Renderer2;abstract end?(): void;abstract whenRenderingDone?(): Promise<any>;}// @publicexport enum RendererStyleFlags2 {DashCase = 2,Important = 1}// @publicexport interface RendererType2 {data: { [kind: string]: any;};encapsulation: ViewEncapsulation;id: string;styles: string[];}// @publicexport function resolveForwardRef<T>(type: T): T;// @publicexport function runInInjectionContext<ReturnT>(injector: Injector, fn: () => ReturnT): ReturnT;// @publicexport abstract class Sanitizer {// (undocumented)abstract sanitize(context: SecurityContext, value: {} | string | null): string | null;// (undocumented)static ɵprov: unknown;}// @publicexport interface SchemaMetadata {// (undocumented)name: string;}// @publicexport enum SecurityContext {// (undocumented)HTML = 1,// (undocumented)NONE = 0,// (undocumented)RESOURCE_URL = 5,// (undocumented)SCRIPT = 3,// (undocumented)STYLE = 2,// (undocumented)URL = 4}// @publicexport interface Self {}// @publicexport const Self: SelfDecorator;// @publicexport interface SelfDecorator {(): any;// (undocumented)new (): Self;}// @publicexport function setTestabilityGetter(getter: GetTestability): void;// @publicexport type Signal<T> = (() => T) & {[SIGNAL]: unknown;};// @publicexport function signal<T>(initialValue: T, options?: CreateSignalOptions<T>): WritableSignal<T>;// @publicexport class SimpleChange {constructor(previousValue: any, currentValue: any, firstChange: boolean);// (undocumented)currentValue: any;// (undocumented)firstChange: boolean;isFirstChange(): boolean;// (undocumented)previousValue: any;}// @publicexport interface SimpleChanges {// (undocumented)[propName: string]: SimpleChange;}// @publicexport interface SkipSelf {}// @publicexport const SkipSelf: SkipSelfDecorator;// @publicexport interface SkipSelfDecorator {(): any;// (undocumented)new (): SkipSelf;}// @publicexport type StateKey<T> = string & {__not_a_string: never;__value_type?: T;};// @publicexport interface StaticClassProvider extends StaticClassSansProvider {multi?: boolean;provide: any;}// @publicexport interface StaticClassSansProvider {deps: any[];useClass: Type<any>;}// @publicexport type StaticProvider = ValueProvider | ExistingProvider | StaticClassProvider | ConstructorProvider | FactoryProvider | any[];// @publicexport abstract class TemplateRef<C> {abstract createEmbeddedView(context: C, injector?: Injector): EmbeddedViewRef<C>;abstract readonly elementRef: ElementRef;}// @publicexport class Testability implements PublicTestability {constructor(_ngZone: NgZone, registry: TestabilityRegistry, testabilityGetter: GetTestability);// @deprecateddecreasePendingRequestCount(): number;findProviders(using: any, provider: string, exactMatch: boolean): any[];// @deprecatedgetPendingRequestCount(): number;// @deprecatedincreasePendingRequestCount(): number;isStable(): boolean;whenStable(doneCb: Function, timeout?: number, updateCb?: Function): void;// (undocumented)static ɵfac: i0.ɵɵFactoryDeclaration<Testability, never>;// (undocumented)static ɵprov: i0.ɵɵInjectableDeclaration<Testability>;}// @publicexport class TestabilityRegistry {findTestabilityInTree(elem: Node, findInAncestors?: boolean): Testability | null;getAllRootElements(): any[];getAllTestabilities(): Testability[];getTestability(elem: any): Testability | null;registerApplication(token: any, testability: Testability): void;unregisterAllApplications(): void;unregisterApplication(token: any): void;// (undocumented)static ɵfac: i0.ɵɵFactoryDeclaration<TestabilityRegistry, never>;// (undocumented)static ɵprov: i0.ɵɵInjectableDeclaration<TestabilityRegistry>;}// @publicexport interface TrackByFunction<T> {// (undocumented)<U extends T>(index: number, item: T & U): any;}// @publicexport class TransferState {get<T>(key: StateKey<T>, defaultValue: T): T;hasKey<T>(key: StateKey<T>): boolean;get isEmpty(): boolean;onSerialize<T>(key: StateKey<T>, callback: () => T): void;remove<T>(key: StateKey<T>): void;set<T>(key: StateKey<T>, value: T): void;toJson(): string;// (undocumented)static ɵprov: unknown;}// @publicexport const TRANSLATIONS: InjectionToken<string>;// @publicexport const TRANSLATIONS_FORMAT: InjectionToken<string>;// @publicexport const Type: FunctionConstructor;// @public (undocumented)export interface Type<T> extends Function {// (undocumented)new (...args: any[]): T;}// @publicexport interface TypeDecorator {<T extends Type<any>>(type: T): T;// (undocumented)(target: Object, propertyKey?: string | symbol, parameterIndex?: number): void;// (undocumented)(target: unknown, context: unknown): void;}// @publicexport interface TypeProvider extends Type<any> {}// @publicexport function untracked<T>(nonReactiveReadsFn: () => T): T;// @publicexport type ValueEqualityFn<T> = (a: T, b: T) => boolean;// @publicexport interface ValueProvider extends ValueSansProvider {multi?: boolean;provide: any;}// @publicexport interface ValueSansProvider {useValue: any;}// @public (undocumented)export const VERSION: Version;// @publicexport class Version {constructor(full: string);// (undocumented)full: string;// (undocumented)readonly major: string;// (undocumented)readonly minor: string;// (undocumented)readonly patch: string;}// @publicexport type ViewChild = Query;// @publicexport const ViewChild: ViewChildDecorator;// @publicexport interface ViewChildDecorator {(selector: ProviderToken<unknown> | Function | string, opts?: { read?: any; static?: boolean;}): any;// (undocumented)new (selector: ProviderToken<unknown> | Function | string, opts?: { read?: any; static?: boolean;}): ViewChild;}// @publicexport type ViewChildren = Query;// @publicexport const ViewChildren: ViewChildrenDecorator;// @publicexport interface ViewChildrenDecorator {(selector: ProviderToken<unknown> | Function | string, opts?: { read?: any; emitDistinctChangesOnly?: boolean;}): any;// (undocumented)new (selector: ProviderToken<unknown> | Function | string, opts?: { read?: any; emitDistinctChangesOnly?: boolean;}): ViewChildren;}// @publicexport abstract class ViewContainerRef {abstract clear(): void;abstract createComponent<C>(componentType: Type<C>, options?: { index?: number; injector?: Injector; ngModuleRef?: NgModuleRef<unknown>; environmentInjector?: EnvironmentInjector | NgModuleRef<unknown>; projectableNodes?: Node[][];}): ComponentRef<C>;// @deprecatedabstract createComponent<C>(componentFactory: ComponentFactory<C>, index?: number, injector?: Injector, projectableNodes?: any[][], environmentInjector?: EnvironmentInjector | NgModuleRef<any>): ComponentRef<C>;abstract createEmbeddedView<C>(templateRef: TemplateRef<C>, context?: C, options?: { index?: number; injector?: Injector;}): EmbeddedViewRef<C>;abstract createEmbeddedView<C>(templateRef: TemplateRef<C>, context?: C, index?: number): EmbeddedViewRef<C>;abstract detach(index?: number): ViewRef | null;abstract get element(): ElementRef;abstract get(index: number): ViewRef | null;abstract indexOf(viewRef: ViewRef): number;abstract get injector(): Injector;abstract insert(viewRef: ViewRef, index?: number): ViewRef;abstract get length(): number;abstract move(viewRef: ViewRef, currentIndex: number): ViewRef;// @deprecated (undocumented)abstract get parentInjector(): Injector;abstract remove(index?: number): void;}// @publicexport enum ViewEncapsulation {Emulated = 0,None = 2,ShadowDom = 3}// @publicexport abstract class ViewRef extends ChangeDetectorRef {abstract destroy(): void;abstract get destroyed(): boolean;abstract onDestroy(callback: Function): void;}// @publicexport interface WritableSignal<T> extends Signal<T> {asReadonly(): Signal<T>;mutate(mutatorFn: (value: T) => void): void;set(value: T): void;update(updateFn: (value: T) => T): void;}// @publicexport function ɵɵdefineInjectable<T>(opts: {token: unknown;providedIn?: Type<any> | 'root' | 'platform' | 'any' | 'environment' | null;factory: () => T;}): unknown;// @publicexport function ɵɵinject<T>(token: ProviderToken<T>): T;// @public (undocumented)export function ɵɵinject<T>(token: ProviderToken<T>, flags?: InjectFlags): T | null;// @publicexport function ɵɵinjectAttribute(attrNameToInject: string): string | null;// (No @packageDocumentation comment for this package)```