## API Report File for "@angular/localize_tools"> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).```tsimport { AbsoluteFsPath } from '@angular/compiler-cli/private/localize';import { Element as Element_2 } from '@angular/compiler';import { Logger } from '@angular/compiler-cli/private/localize';import { MessageId } from '@angular/localize';import { NodePath } from '@babel/traverse';import { ParseError } from '@angular/compiler';import { PathManipulation } from '@angular/compiler-cli/private/localize';import { PluginObj } from '@babel/core';import { ReadonlyFileSystem } from '@angular/compiler-cli/private/localize';import { types } from '@babel/core';import { ɵParsedMessage } from '@angular/localize';import { ɵParsedTranslation } from '@angular/localize';import { ɵSourceLocation } from '@angular/localize';import { ɵSourceMessage } from '@angular/localize';// @publicexport class ArbTranslationParser implements TranslationParser<ArbJsonObject> {// (undocumented)analyze(_filePath: string, contents: string): ParseAnalysis<ArbJsonObject>;// (undocumented)parse(_filePath: string, contents: string, arb?: ArbJsonObject): ParsedTranslationBundle;}// @publicexport class ArbTranslationSerializer implements TranslationSerializer {constructor(sourceLocale: string, basePath: AbsoluteFsPath, fs: PathManipulation);// (undocumented)serialize(messages: ɵParsedMessage[]): string;}// @publicexport function buildLocalizeReplacement(messageParts: TemplateStringsArray, substitutions: readonly types.Expression[]): types.Expression;// @publicexport function checkDuplicateMessages(fs: PathManipulation, messages: ɵParsedMessage[], duplicateMessageHandling: DiagnosticHandlingStrategy, basePath: AbsoluteFsPath): Diagnostics;// @publicexport type DiagnosticHandlingStrategy = 'error' | 'warning' | 'ignore';// @publicexport class Diagnostics {// (undocumented)add(type: DiagnosticHandlingStrategy, message: string): void;// (undocumented)error(message: string): void;// (undocumented)formatDiagnostics(message: string): string;// (undocumented)get hasErrors(): boolean;// (undocumented)merge(other: Diagnostics): void;// (undocumented)readonly messages: { type: 'warning' | 'error'; message: string;}[];// (undocumented)warn(message: string): void;}// @publicexport function isGlobalIdentifier(identifier: NodePath<types.Identifier>): boolean;// @publicexport class LegacyMessageIdMigrationSerializer implements TranslationSerializer {constructor(_diagnostics: Diagnostics);// (undocumented)serialize(messages: ɵParsedMessage[]): string;}// @publicexport function makeEs2015TranslatePlugin(diagnostics: Diagnostics, translations: Record<string, ɵParsedTranslation>, { missingTranslation, localizeName }?: TranslatePluginOptions, fs?: PathManipulation): PluginObj;// @publicexport function makeEs5TranslatePlugin(diagnostics: Diagnostics, translations: Record<string, ɵParsedTranslation>, { missingTranslation, localizeName }?: TranslatePluginOptions, fs?: PathManipulation): PluginObj;// @publicexport function makeLocalePlugin(locale: string, { localizeName }?: TranslatePluginOptions): PluginObj;// @publicexport class MessageExtractor {constructor(fs: ReadonlyFileSystem, logger: Logger, { basePath, useSourceMaps, localizeName }: ExtractionOptions);// (undocumented)extractMessages(filename: string): ɵParsedMessage[];}// @publicexport class SimpleJsonTranslationParser implements TranslationParser<SimpleJsonFile> {// (undocumented)analyze(filePath: string, contents: string): ParseAnalysis<SimpleJsonFile>;// (undocumented)parse(_filePath: string, contents: string, json?: SimpleJsonFile): ParsedTranslationBundle;}// @publicexport class SimpleJsonTranslationSerializer implements TranslationSerializer {constructor(sourceLocale: string);// (undocumented)serialize(messages: ɵParsedMessage[]): string;}// @publicexport function translate(diagnostics: Diagnostics, translations: Record<string, ɵParsedTranslation>, messageParts: TemplateStringsArray, substitutions: readonly any[], missingTranslation: DiagnosticHandlingStrategy): [TemplateStringsArray, readonly any[]];// @publicexport function unwrapExpressionsFromTemplateLiteral(quasi: NodePath<types.TemplateLiteral>, fs?: PathManipulation): [types.Expression[], (ɵSourceLocation | undefined)[]];// @publicexport function unwrapMessagePartsFromLocalizeCall(call: NodePath<types.CallExpression>, fs?: PathManipulation): [TemplateStringsArray, (ɵSourceLocation | undefined)[]];// @publicexport function unwrapMessagePartsFromTemplateLiteral(elements: NodePath<types.TemplateElement>[], fs?: PathManipulation): [TemplateStringsArray,(ɵSourceLocation | undefined)[]];// @publicexport function unwrapSubstitutionsFromLocalizeCall(call: NodePath<types.CallExpression>, fs?: PathManipulation): [types.Expression[], (ɵSourceLocation | undefined)[]];// @publicexport class Xliff1TranslationParser implements TranslationParser<XmlTranslationParserHint> {// (undocumented)analyze(filePath: string, contents: string): ParseAnalysis<XmlTranslationParserHint>;// (undocumented)parse(filePath: string, contents: string, hint: XmlTranslationParserHint): ParsedTranslationBundle;}// @publicexport class Xliff1TranslationSerializer implements TranslationSerializer {constructor(sourceLocale: string, basePath: AbsoluteFsPath, useLegacyIds: boolean, formatOptions?: FormatOptions, fs?: PathManipulation);// (undocumented)serialize(messages: ɵParsedMessage[]): string;}// @publicexport class Xliff2TranslationParser implements TranslationParser<XmlTranslationParserHint> {// (undocumented)analyze(filePath: string, contents: string): ParseAnalysis<XmlTranslationParserHint>;// (undocumented)parse(filePath: string, contents: string, hint: XmlTranslationParserHint): ParsedTranslationBundle;}// @publicexport class Xliff2TranslationSerializer implements TranslationSerializer {constructor(sourceLocale: string, basePath: AbsoluteFsPath, useLegacyIds: boolean, formatOptions?: FormatOptions, fs?: PathManipulation);// (undocumented)serialize(messages: ɵParsedMessage[]): string;}// @publicexport class XmbTranslationSerializer implements TranslationSerializer {constructor(basePath: AbsoluteFsPath, useLegacyIds: boolean, fs?: PathManipulation);// (undocumented)serialize(messages: ɵParsedMessage[]): string;}// @publicexport class XtbTranslationParser implements TranslationParser<XmlTranslationParserHint> {// (undocumented)analyze(filePath: string, contents: string): ParseAnalysis<XmlTranslationParserHint>;// (undocumented)parse(filePath: string, contents: string, hint: XmlTranslationParserHint): ParsedTranslationBundle;}// (No @packageDocumentation comment for this package)```