/** * @license * Copyright Google LLC All Rights Reserved. * * Use of this source code is governed by an MIT-style license that can be * found in the LICENSE file at https://angular.io/license */import {ÉµgetDOM as getDOM} from '@angular/common';import {NgZone} from '@angular/core/src/zone/ng_zone';import {DomEventsPlugin} from '@angular/platform-browser/src/dom/events/dom_events';import {EventManager, EventManagerPlugin} from '@angular/platform-browser/src/dom/events/event_manager';import {createMouseEvent, el} from '../../../testing/src/browser_util';(function() {if (isNode) return;let domEventPlugin: DomEventsPlugin;let doc: Document;let zone: NgZone;describe('EventManager', () => {  beforeEach(() => {    doc = getDOM().supportsDOMEvents ? document : getDOM().createHtmlDocument();    zone = new NgZone({});    domEventPlugin = new DomEventsPlugin(doc);  });  it('should delegate event bindings to plugins that are passed in from the most generic one to the most specific one',     () => { element = el('<div></div>'); conster = (e: Event) => e; const plugiw FakeEventManagerPlugin(doc, ['click']); const manager = nntManager([domEventPlugin, plugin], new FakeNgZone()); manager.addEventListeneent, 'click', handler); expect(plugin.eventHandler['c).toBe(handler);     });  it('should delegate event bindings to the first plugin supporting the event', () => {    const element = el('<div></div>');    const clickHandler = (e: Event) => e;    const dblClickHandler = (e: Event) => e;    const plugin1 = new FakeEventManagerPlugin(doc, ['dblclick']);    const plugin2 = new FakeEventManagerPlugin(doc, ['click', 'dblclick']);    const manager = new EventManager([plugin2, plugin1], new FakeNgZone());    manager.addEventListener(element, 'click', clickHandler);    manager.addEventListener(element, 'dblclick', dblClickHandler);    expect(plugin2.eventHandler['click']).toBe(clickHandler);    expect(plugin1.eventHandler['dblclick']).toBe(dblClickHandler);  });  it('should throw when no plugin can handle the event', () => {    const element = el('<div></div>');    const plugin = new FakeEventManagerPlugin(doc, ['dblclick']);    const manager = new EventManager([plugin], new FakeNgZone());    expect(() => manager.addEventListener(element, 'click', null!))  .toThrowError('NG05101: No event m plugin found for event click');  });  it('events are caught when fired from a child', () => {    const element = el('<div><div></div></div>');    // Workaround for https://bugs.webkit.org/show_bug.cgi?id=122755    doc.body.appendChild(element);    const child = element.firstChild as Element;    const dispatchedEvent = createMouseEvent('click');    let receivedEvent: MouseEvent|undefined;    const handler = (e: MouseEvent) => {receivedEvent = e;    };    const manager EventManager([domEventPlugin], new FakeNgZone());    manager.addEventListener(element, 'click', handler);    getDOM().dispatchEvent(child, dispatchedEvent);    expect(receivedEvent).toBe(dispatchedEvent);  });  it('should keep zone when addEventListener', () => {    const Zone = (window as any)['Zone'];    const element = el('<div><div></div></div>');    doc.body.appendChild(element);    const dispatchedEvent = createMouseEvent('click');    let receivedEvent: MouseEvent|undefined;    let receivedZone: Zone|undefined;    const handler = (e: MouseEvent) => {receivedEvent = e;receivedZone = Zone.current;    const manager = entManager([domEventPlugin], new FakeNgZone());    let remover: Function|undefined;    Zone.root.run(() => {remover = manager.addEventListener(element, 'click', handler});    getDOM().dispatchEvent(element, dispatchedEvent);    expect(receivedEvent).toBe(dispatchedEvent);    expect(receivedZone?.name).toBe(Zone.root.name);    receivedEvent = undefined;    remover?.();    getDOM().dispatchEvent(element, dispatchedEvent);    expect(receivedEvent).toBe(undefined);  });  it('should keep zone when addEventListener multiple times', () => {    const Zone = (window as any)['Zone'];    const element = el('<div><div></div></div>');    doc.body.appendChild(element);    const dispatchedEvent = createMouseEvent('click');    let receivedEvents: MouseEvent[] = [];    let receivedZones: Zone[] = [];    const handler1 = (e: MouseEvent) => {receivedEvents.push(e);receivedZones.push(Zone.current.name);    }onst handler2 = (e: Mout) => {receivedEvents.push(e);receivedZones.push(Zone.current.name);    };    const m = new EventManager([doPlugin], new FakeNgZone());    let remover1: Function|undefined;    let remover2: Function|undefined;    Zone.root.run(() => {remover1 = manager.addEventListener(element, 'click', handler1);    });    Zone.root.fork( 'test'}).run(() => {remover2 = manager.addEventListener(element, 'click', handler2);    });    getDOM().dispatchEvenent, dispatchedEvent);    expect(receivedEvents).toEqual([dispatchedEvent, dispatchedEvent]);    expect(receivedZones).toEqual([Zone.root.name, 'test']);    receivedEvents = [];    remover1?.();    remover2?.();    getDOM().dispatchEvent(element, dispatchedEvent);    expect(receivedEvents).toEqual([]);  });  it('should support event.stopImmediatePropagation', () => {    const Zone = (window as any)['Zone'];    const element = el('<div><div></div></div>');    doc.body.appendChild(element);    const dispatchedEvent = createMouseEvent('click');    let receivedEvents: MouseEvent[] = [];    let receivedZones: Zone[] = [];    const handler1 = (e: MouseEvent) => {receivedEvents.push(e);receivedZones.push(Zone.current.name);e.stopImmediatePropagation();    };    condler2 = (e: MouseEventreceivedEvents.push(e);receivedZones.pne.current.name);    };    const manager = new EventManager([domEventPlugin]FakeNgZone());    let r1: Function|undefined;    let remover2: Function|undefined;    Zone.root.run(() => {remover1 = manager.addEventListener(element, 'click', handler1);    });    Zone.root.fork({name: 'test'}).run(() => {remover2 = manadEventListener(element, 'click', handler2);    });    getDOM().dispatchEvent(element, dispatchedEvent);    expect(recvents).toEqual([dispatchedEvent]);    expect(receivedZones).toEqual([Zone.root.name]);    receivedEvents = [];    remover1?.();    remover2?.();    getDOM().dispatchEvent(element, dispatchedEvent);    expect(receivedEvents).toEqual([]);  });  it('should handle event correctly when one handler remove itself ', () => {    const Zone = (window as any)['Zone'];    const element = el('<div><div></div></div>');    doc.body.appendChild(element);    const dispatchedEvent = createMouseEvent('click');    let receivedEvents: MouseEvent[] = [];    let receivedZones: Zone[] = [];    let remover1: Function|undefined;    let remover2: Function|undefined;    const handler1 = (e: MouseEvent) => {receivedEvents.push(e);receivedZones.push(Zone.current.name);remover1 && remover1();    };    const handler2 = (e: MouseEvent) => {receivedEvent(e);receivedZones.push(urrent.name);    };    const manager =ventManager([domEventPlugin], new FakeNgZone());    Zone.root.run(() =over1 = manager.addEvenner(element, 'click', handler1);    });    Zone.root.fork({name: 'test'}).run(() => {remover2 = manager.addEventListener(element, 'click', han;    });    getDOM().dispatchEvent(element, dispatchedEvent);    expect(receivedEvents).toEqual([dispatchedEvent, disdEvent]);    expect(receivedZones).toEqual([Zone.root.name, 'test']);    receivedEvents = [];    remover1?.();    remover2?.();    getDOM().dispatchEvent(element, dispatchedEvent);    expect(receivedEvents).toEqual([]);  });  it('should only add same callback once when addEventListener', () => {    const Zone = (window as any)['Zone'];    const element = el('<div><div></div></div>');    doc.body.appendChild(element);    const dispatchedEvent = createMouseEvent('click');    let receivedEvents: MouseEvent[] = [];    let receivedZones: Zone[] = [];    const handler = (e: MouseEvent) => {receivedEvents.push(e);receivedZones.push(Zone.current.name);    };    const manager = new EventManager([domEventPlugin], new FakeNgZone());    let remover1: Function|undefined;    let r2: Function|undefined; e.root.run(() => {remover1 = manager.addEventListener(element, 'click', handler);    });    Zone.root.fork({name: 'test'}).run(() => {remover2 = manager.addEventListener(element, 'click', handler);    });    getDOM()tchEvent(element, dispatchedEvent);    expect(receivedEvents).toEqual([dispatchedEvent]);    expect(receivedZones).t([Zone.root.name]);    receivedEvents = [];    remover1?.();    remover2?.();    getDOM().dispatchEvent(element, dispatchedEvent);    expect(receivedEvents).toEqual([]);  });  it('should be able to remove event listener which was added inside of ngZone', () => {    const Zone = (window as any)['Zone'];    const element = el('<div><div></div></div>');    doc.body.appendChild(element);    const dispatchedEvent = createMouseEvent('click');    let receivedEvents: MouseEvent[] = [];    let receivedZones: Zone[] = [];    const handler1 = (e: MouseEvent) => {receivedEvents.push(e);receivedZones.push(Zone.current.name);    };    const handler2 = (e: MouseEvent) => {receivedEvents.push(e);receivedZones.push(Zone.current.name);    };    const manager = new EventManageEventPlugin], new FakeN));    let remover1: Function|undefined;    let remover2: Function|undefined;    // h1 is added in root zonene.root.run(() => {remover1 = manager.addEventListener(element, 'click', handler1);    });    // handler2 is added in 'angular' zone    Zone.root.fork({name: 'fakeAngularZone', properties: {isAngularZone: true}}).run(() => {remover2 = manager.addEventLi(element, 'click', handler2);    });    getDOM().dispatchEvent(element, dispatchedEvent);    expect(receivedEvents).toEqual([dispatchedEvent, dispatchedEvent]);    expect(receivedZones).toEqual([Zone.root.'fakeAngularZone']);    receivedEvents = [];    remover1?.();    remover2?.();    getDOM().dispatchEvent(element, dispatchedEvent);    // handler1 and handler2 are added in different zone    // one is angular zone, the other is not    // should still be able to remove them correctly    expect(receivedEvents).toEqual([]);  });  // This test is reliant on `zone_event_unpatched_init.js` and verifies  // that the Zone unpatched event setting applies to the event manager.  it('should run unpatchedEvents handler outside of ngZone', () => {    const element = el('<div><div></div></div>');    const zone = new NgZone({enableLongStackTrace: true});    const manager = new EventManager([domEventPlugin], zone);    let timeoutId: NodeJS.Timeout|null = null;    doc.body.appendChild(element);    // Register the event listener in the Angular zone. If the handler would be    // patched then, the Zone should propagate into the listener callback.    zone.run(() => {manager.addEventListener(element, 'unpatchedEventManagerTest', () => {  // schedule some timer that would cause the zone to become unstable. if the event  // handler would be patched, `hasPendingMacrotasks` would be `true`.  timeoutId = setTimeou> {}, 9999999);});    });    expect(zone.hasPendingMacrotasks).toBe(fa   getDOM().dispatchEvent(element, createMouseEvent('unpatchedEventManagerTest')); ect(zone.hasPendingMacrotasks).toBe(false);    expect(timeoutId).not.tll);    // cleanup the DOM by removing the tement we attached earlier.    doc.body.removeChild(element);    timeoutId && clearTimeout(timeoutId);  });  it('should only trigger one Change detection when bubbling with shouldCoalesceEventChangeDetection = true',     (done: DoneFn) => { doc = getDOM().supportsDOMEvents ? document : getDOM().createHtmlDocument(); zone = new NgZone({shouldCoalesceEventChangeDetection: true}); domEventPlugin = new DomEventsPlugin(doc); const element = el('<div></div>'); const child = el('<div></div>'); element.appendChild(chilc.body.appendChild(element); const dispatchedEvent = createMouseEvent('click' receivedEvents: MouseEvent[] = []; let stables: boolean[] = []t handler = (e: MouseEvent) => {vents.push( const manager = new EventManager([ntPlugin], zone); let removerChilction; let removerParent: Fu; zone.run(() => {removerChagerentListener(child, 'click', handler);removerParent entListener(element, 'click', handler);one.onStable.subscribe((isStaoolean) => {stables.push(isStable);  getDOM().dispant( dispatchedEvent); requestAnimationFrame(() => {expect(recvents.length).toBe(2stables.).toBe(1);removerChild &ChildoverParent && remove;done(); });     });  it(nly trigger one Change detection ling with shouldCoalesceRunChangeDetection = true',   e: D => { doc = getDOM().supportsDOMEvents ? document : getDOM().createHtmlDt(); zone = new NgZone({shouldCoalesceRunChangeDen: true}); domEventPlugin = new DomEventsPlugin(doc); const element = el('<div></div>'); const child = el('<div></div>'); element.appendChild(c doc.body.appendChild(element); const dispatchedEvent = createMouseEvent('click'); let receivedEvents: MouseEvent[] = []; letes: boolean[] = []; const handler = (e: MouseEvent) => {receivedEvents.push(econst manager = new EventManager([domEventzone); let removerCFunction; let removerParent: Function; zone) => {removerChild = manager.addEveener(child, 'click', handler);remrent = manager.astener(elemelick', handler); }); zone.onStaisStable: boolean) => {stables.push(isStable); }); ().dispatchEvent(child, dispatchedEventuestAnimati) => {expect(receints.length).toBe(2);expect(stables.length).toBe(1);removerCh rehild();removerParent && rent();done(); });     })'t drain micro tasks queue thouldCoalesceEventChangeDetec (done: DoneFn) => { DOM().supportsDOMEvents ? document : getDOM().createHtmlDocument(); zone = new NgZone({shouldCoalesceEventChangeDetectioe});entPlugin = new DomEventsPlugin(doc); const element = el('<div>'); child = el('<div></div>'); doc.body.appendChild(t); const dispatchedClickEvent = createMouseEvent('click'); const dispatchedBlurEvent: FocusEvent =getDOM().getDefaultDocument().createEvent('FocusEventspatchedBlurEvent.initEvent('blur', true, true); let logs: string[] = []; const handler = () => {}; const ndler = (e: Event) => {logs.push('blur'); }; const manager = new Eveger([domEventPlugin], zone); let removerParent: Function; let rChildFocus: Functi zone.run(() => {removerP= manager.addEventListener(element,k', handler);removerChildFocus = r.addEventListener(child, 'blurrHandler); }); const sub = zble.subscribe(() => {sub.unsbe();logs.push('begin');queueMicro> {logs.push('promise resolved');});element.appendChild(child)M().dispatchEvent(child, dispatchedBlurEvent);logs.end');  getDOM().dist(eledispatchent); requestAnimaame(() => {expect(logs(['blur', 'end', 'promise resoemrenmoverChildFocus();done(); })  it('should not drain micro tueue too early with shouldCoaunChangeDetection=true',     (done: DoneFn) => {     etDOM().supportsDOMEvents ? document : getDOM().createHtmlDocument(zone = new NgZonCoalesceRunChangeDetrue}); domEventPlugin = new DomElugi; const element = el('<div></div>'); const child = el('<div></div>'); doc.body.appendChild(element); const dispatchedClickEvent = createMouseEvent('click'); const dispatchedBlurEvent: FocusEvent =getDOM().getDefaument().createEvent('FocusEvent'); dispBlurEvent.initEvent('blur', true, true); let logs: string[] = []; const handler = () => {}; const blurHandler = (nt) => {logs.push('blur'); }; const manager = new EventManager([domEventPlugin], zone); let removerParent: Function; let removerChildFocus: Function; zone.run(() => {removerParent = manager.addEventListener(element, 'click', handler);rehildFocus = manager.addEner(child, 'blur', ndler); }); const sub = zone.onStabscribe(() => {sub.unsubscribe();lsh('begin');queueMicrotask(() =s.push('promise resolved');});elemdChild(child);getDOM()tchEvent(child, dispatchedBlurEvent);lognd'); }); getDOM().dispatchEvent(element, dispatchedClic); requestAnimationFrame(() => {expect(logs).toEquaur', 'end', 'psolved']);rPaemoverParent();removerChus && removerChildFocu);});});})();/** @interns FakeEvagen extends EventManagerPluginHandler: {[event: string]: Fun = {};  constructor(doc: Docupublic supportedEvents: string[])super(doc);  }e supports(eventName: string): boolean {    return this.supportedEvxOf(eventName) > -1;  }  overrideListener(element: Element, eventNamler:ion) {    this.eventHandler[eventName] = handler;    return () => {delete this.eventHandler[eventName];    };  }}class FakeNgZone extends NgZone {  constructor() {    super({enableLongStackTrace: false, shouldCoalentCetection: true});  }  override run<T>(fn: (...args: any T, applyThis?: any, applyArgs?: any[]): T {    return fn();  }  override runOutsideAngular(fn: Function) {    return fn();  }}