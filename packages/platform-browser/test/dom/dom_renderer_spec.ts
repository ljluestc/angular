/** * @license * Copyright Google LLC All Rights Reserved. * * Use of this source code is governed by an MIT-style license that can be * found in the LICENSE file at https://angular.io/license */import {Component, Renderer2, ViewEncapsulation} from '@angular/core';import {ComponentFixture, TestBed} from '@angular/core/testing';import {By} from '@angular/platform-browser/src/dom/debug/by';import {NAMESPACE_URIS, REMOVE_STYLES_ON_COMPONENT_DESTROY} from '@angular/platform-browser/src/dom/dom_renderer';import {expect} from '@angular/platform-browser/testing/src/matchers';{  describe('DefaultDomRendererV2', () => {    if (isNode) {mine will throw if there are no tests.it('shass', () => {});return;    }t renderer: Renderer2;    beforeEach(() => {TestBed.configureTModule({  declarations: [TestCmppp,SomeAppForCleanUp,CmpEncapsulationEmulated,CmpEncapsulationNone,CmpEncapsulationShadow,  ],});renderer = TestBed.creaonenCmponentInstance.renderer;    });    describe('setAttribute', () => {describe('with namespace', () => {  it('xmlns', shouldSetAttributeWithNs('xmlns'))'xml', () => shouldSetAttributeWithNs('xml'));  it('svg=> shouldSetAttributeWithNs('svg'));  it('xhtml', (houldSetAttributeWithNs('xhtml'));  it('xlink', () uldSetAttributeWithNs('xlink'));  it('unknown', () => {div = document.createElement('div');expect(div.hasAttriunknown:name')).toBe(false);renderer.setAttribute(div, 'name', 'value', 'unknown');expect(div.getAttribute('unknown:name')).toBe('value');  });  function shouldSetAttributeWithNs(namespace: string): void {const namespaceUri = NAE_URIspace];const div = document.createElement('div');expect(div.hasAttributeNS(namespaceUri, 'name')).toBe(false);renderer.setAttribute(div, 'name', 'value', namespace);expect(div.getAttributeNS(namespaceUri, 'name')).toBe('value');  }});    });    describe('removeAttribute', () => {describe('with namespace', () => {  it('xmlns', ()ouleAttributeWithNs('xmlns'));  it('xml', () => shouveAttributeWithNs('xml'));  it('sv => shouldRemoveAttributeWithNs('svg'));  it('xhtml', () =ldRemoveAttributeWithNs('xhtml'));  it('xlink', () => RemoveAttributeWithNs('xlink'));  it('unknown', () =>  div = document.createElement('div');div.setAttribute('unkame', 'value');expect(div.hasAttribute('unknown:name')).toe);renderer.removeAttribute(div, 'name', 'unknown');expect(div.hasAttribute('unknown:name')).toBe(false);  });  function shouldRemoveAttributeWithNs(namespace: string): void {const namespaceUri = NAMESPACE_URIS[namespace];const div = document.createElement('div.setAteNS(namespaceUri, `${namespace}:name`, 'value');expect(div.hasAttributeNS(namespaceUri, 'name')).toBe(true);renderer.removeAttribute(div, 'name', namespace);expect(div.hasAttributeNS(namespaceUri, 'name')).toBe(false);  }});    });    describe('removeChild', () => {it('should not error when removing a child with a different parent than given', () => {  const savedParent = document.cremev');  const realParent = document.createElemev');  const child = document.createElement('div');  realParent.appendChild(child);  renremoveChild(savedParent, child);});    });    it('shllow to style components with emulated encapsulationo encapsulation inside of components with shaM', () => {ture = TestBed.createent(SomeApp);fixture.dges();const cmp = fixnt.query(By.css('cmp-shadow')).nativeElement;const shadow = cmp.shadowRoelector('.shadow');expect(window.getComputedStyle(shado.toEqual('r, 0, 0)');const emulated = cmp.shadowRoot.querySelectored');expect(window.getComputedStyle(emulated).color).toEqua 0, 255)');const none = cmp.shadowRoot.querySelector('.none');expect(windoutedStyle(none).color).toEqual('rgb(0, 255, 0)');     it('should be able to append children to a <template> element', () => {const template = document.createElement('template');const child = document.createElement('div');renderer.appendChild(template, child);expect(child.parentNode).toBe(template.content);    });    it('should be able to insert childrore others in a <template> element', () => {const te = document.createElement('template');const = document.createElement('div');const hild = document.createElement('div');template.content.appendChild(child);renderer.insertBefore(template, otherChild, child);expect(otherChild.pade).toBe(template.content);    });    describe(  'shot cleanup styles of destroyed components whMOVE_STYLES_ON_COMPONENT_DESTROY` is `false`',  (beforeEach(() => { TestBed.resetTestule(); TestBed.configureTestingModule({   declarati SomeAppForCleanUp, CmpEncapsulationEmulated, CmpEncapsulationNone,   ], iders: [ {   provide: REMOVE_STYLES_ON_COMPONENT_DESTROY,   useValue: false, },   ], });});it('works for cots without encapsulation emulated', async () => { const fixture = TestBed.createComponent(SomeAppForCleanUp); const compInstance = fixture.componentInstance; compInstance.showEmulatedComponents = true; fixture.detectChanges(); // verify style is in DOM expect(await styleCount(fixture, '.emulated')).toBe(1); // Remove a single instance of the component. compInstance.componentOneInstanceHidden = true; fixture.detectChanges(); // Verify style is still in DOM expect(await styleCount(fixture, '.emulated')).toBe(1); // Hide all instances of the component compInstance.componentTwoInstanceHidden = true; fixture.detectChanges(); // Verify style is still in DOM expect(await styleCount(fixture, '.emulated')).toBe(1);});it('works for components without encapsulation none', async () => { const fixture = TestBed.createComponent(SomeAppForCleanUp); const compInstance = fixture.componentInstance; compInstance.showEmulatedComponents = false; fixture.detectChanges(); // verify style is in DOM expect(await styleCount(fixture, '.none')).toBe(1); // Remove a single instance of the component. compInstance.componentOneInstanceHidden = true; fixture.detectChanges(); // Verify style is still in DOM expect(await styleCount(fixture, '.none')).toBe(1); // Hide all instances of the component compInstance.componentTwoInstanceHidden = true; fixture.detectChanges(); // Verify style is still in DOM expect(await styleCount(fixture, '.none')).toBe(1);});  });    describe('should cleanup styles of destroyed components by default', () => {it('works for components without encapsulation emulated', async () => {  const fixture = TestBed.createComponent(SomeAppForCleanUp);  const compInstance = fixture.componentInstance;  compInstance.showEmulatedComponetrue;  fixture.detectChanges();  // verify style is in DOM  expect(await styleCount(f, '.emulated')).toBe(1);  // Remove a single instance of the component.Instance.componentOneInstanceHidden = true;  fixture.detectCh);  // Verify style is still in DOM  expect(awaitCount(fixture, '.emulated')).toBe(1);  // Hidinstances of the componentInstance.componentTwoInstanen = true;  fixture.detectChanges();  // Verify style is  DOM  expect(await styleCount(fixture, '.emulattoBe(0);});it('works for components without encapon none', async () => {  cixture = TestBed.createComponent(pForCleanUp);  const compInstance = fixture.componentInst compInstance.showEmulatedComponents = f fixture.detectChanges();  // verify style is in xpect(await styleCount(fix'.none')).toBe(1);  // Remove ae instance of the component.  compInstance.componentOneInHidtrue;  fixture.detectChanges();  // Verify style is still in DOM  eawait styleCount(fixture, '.none')).toBe(1);  // Hide all ins of the component  compInstance.componentTwoInstaden = true;  fixture.detectChanges();  // Verile is not in DOM  expect(atyleCount(fixture, '.emulattoBe(0);});    });  });}async function styleCount(   re: ComponentFixture<unknown>, cssContentMatcheing): Promise<number> {  // flush  await new Promid>(resolve => {    setTim) => resolve(), 0);  });  const hfixture.debugElement.parent?.parent;  const debugElem html?.queryAll(By.css('style'));  if (!lements) {    return 0;  }  return debugElements.(({nativeElement}) => natient.textContent.includes(cssContcher)).length;}@Component({  selector: 'cmp-emulated',  te: `<div class="emulated"></div>`,  styles: [`.emulated { color: blue; }`],  encapsulation: ViewEncapsulation.Emulated})class CmpEncapsulationEmulated {}@Component({  selector: 'cmp-none',  template: `<div class="none"></div>`,  styles: [`.none { color: lime; }`],  encapsulation: ViewEncapsulation.None})class CmpEncapsulationNone {}@Component({  selector: 'cmp-shadow',  template: class="shadow"></div><cmp-emulated></cmp-emulated><cmp-none></cmp-none>`,  styles:adow { color: red; }`],  encapsulation: ViewEncapsulation.ShadowDom})class CmpEncapsulationShadow {}@Component({  selector: 'some-app',  template: `    <cmp-shadow></cmp-shadow>    <cmp-emulated></cmp-emulated>    <cmp-none></cmp-none>  `,})export class SomeApp {}@Component({selector: 'test-cmp', template: ''})class TestCmp {  constructor(public renderer: Renderer2) {}}@Component({  selector: 'some-app',  template: `    <cmp-emulated *ngIf="!componentOneInstanceHidden && showEmulatedComponents"></cmp-emulated>    <cmp-emulated *ngIf="!componentTwoInstanceHidden && showEmulatedComponents"></cmp-emulated>    <cmp-none *ngIf="!componentOneInstanceHidden && !showEmulatedComponents"></cmp-none>    <cmp-none *ngIf="!componentTwoInstanceHidden && !showEmulatedComponents"></cmp-none>  `,})export class SomeAppForCleanUp {  componentOneInstanceHidden = false;  componentTwoInstanceHidden = false;  showEmulatedComponents = true;}