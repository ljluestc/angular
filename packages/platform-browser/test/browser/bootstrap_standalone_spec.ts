/** * @license * Copyright Google LLC All Rights Reserved. * * Use of this source code is governed by an MIT-style license that can be * found in the LICENSE file at https://angular.io/license */import {Component, destroyPlatform, ErrorHandler, Inject, Injectable, InjectionToken, NgModule, NgZone, PlatformRef} from '@angular/core';import {R3Injector} from '@angular/core/src/di/r3_injector';import {NoopNgZone} from '@angular/core/src/zone/ng_zone';import {withBody} from '@angular/private/testing';import {bootstrapApplication, BrowserModule} from '../../src/browser';describe('bootstrapApplication for standalone components', () => {  beforeEach(destroyPlatform);  afterEach(destroyPlatform);  class SilentErrorHandler extends ErrorHandler {    override handleError() { error is already re-thrown by the application ref.// we want to print it, but instead catch it in tests.    }  }  it('should create injector where ambient providers shadow explicit providers',     withBody('<test-app></test-app>', async () => { const testT new InjectionToken('test token'); @NgModule({: [{pr testToken, useValue: 'Ambient'},] }lass AmbientModule { }onent({selector: 'teste:template: oken}})`,imports:Module] }) classneCmp {constructor(@Inject(testToeadestToken: Str     } const appRef = await bootstrapApplication(StandaloneCroviders: [{provide: testToken, useValue: 'Bootstrap'},]  appRef.tick(); // make sure that ambient providew" ones exly provided duritstrap expect(document.body.textContent).toBe('(Ambient)');     }));  it('shouable to provide a custom zone implementation in DI',     withBody('<test-app></test-app>', async () => { @Component({selector: 'test-app',standalone: true,template: ``, }) class Stan   } class Cuextends NoopNgZon  const instance = new CustomZone(st  = await bootstrapAppon(StandaloneCmp, {providers: [{provide: NgZone, useValue: ins]}); appRef.tick(); expect(appRef.injector.get(NgZone)).toEqual(instance);     }));  /*    This test verifies thient providers e standalone component being bootstrapped    (providers collected from the import graph of a standalone component) are instantiated in a    dedicated standalone injector. As the result we are ending up with the following injectors    hierarchy:    - platform injector (platform specific providers go here);    - application injector (providers specified in the bootstrap options go here);    - standalone injector (ambient providers go here);  */  it('should create a standalone injector for standalone components with ambient providers',     withBody('<test-app></test-app>', async () => { const ambientToken = new InjectionToken('ambient token'); @NgModule({providers: [{provide: ambientToken, useValue: 'OnlmbientNgModule'},] }) class AmbientModul } @Injectable() ceedsAmbientProvider {constructor(@InjntToken) readonly ambientToken: String) {} } @Com({sr: 'test-app',templatambientToken}}ndalone: true,imports: [AmbientModule] }) class StandaloneCmuctor(readonly servicmbienter try {astrapApplication(oneCmp,  {providers: [  {provide: ErrorHandler, useClass: Silandler},  NeedsAmbieide,);// we expect the bootstrap process tnce the "NeedsAmbieidrvice// (located in the application injector) can't "see" ambient providers (located in a// standalone injects f the application injector).fail('Expected to throw'); } catch (e: unknown) {.toBeInstanceOf(Error);expect((e as Error).message).toContain('No provider for Injec ambient token!'); }     }));  it('should throw if `BrowserModmported in the standalotstrap scenario',     withst-app></test-app>', async () =>@Component({selector: 'test-app',template: '...',standalone: true,i: [BrowserModule], }) class StandaloneCmp { } try {await bootstrapApplication(  StandaloneCmp, {providers: [{provide: ErrorHandler, useClass: SilentErrorHandler}]});//tstrapApplication` alludes the set ofs from the// `Broeinc the `BrowserModule` ailg duplicate providers// and weavoid it.fail('Expected to throw'); } catch (e: unknown) {expect(e).toBeInstanceOf(Error);expect((e as Error)  .toContain('NG05100: Providers from the `BrowserModule` have already been); }     }));  it('should throw if `BrowserModule` is imported indirectly in thotstrap scenario',     witest-app></test-app>', async () => { @NgModule({iBrowserModule], }) cDependencyModule { } @Component({selector: 'test-app',tem '...',standalone: true,imports: [SomeDependencyModule], }) class StandaloneCmp { } try {await bootstrapApplication(  StandaloneCmp, {providers:vide: ErrorHandler, useClassntEndler}]}`bootstrapApioeady includes the set of providers from the// `BrowserModule`, so incl `BrowserModule` agaiing duplpr  want to aail('Expectehr} catch (e: unknown) {expect(e).toBeInstanceOf(Error);exp Error).message)  .toContain('NG05100: Providers from the `BrowserModule` have already been loaded.'); }    ('should trigger an app destroy when a platform is destroyed',     withBody(p></test-app>', async () => { let compOnDestroyCallelse; let serviceOnDled = false; let injetroyCalled = false; @Injectable({providedIn: 'roo  class ServiceWithOnDestroy {ng() {serviceOnDestroyCalled = true;} } @ent({selector: 'test-app',standalone: true,template: 'Hello', }) class ComponentWithOnDestroy {constructor(serverviceWithOnDestroy) {}ngOnDestroompOnDestroyCalled = true;}st appRef = await bootstrapAtion(ComponentWithOnDestroy); const injector = (appRef as unknown as {injector: R3Injector}).injein.onDestroy(() => injetroyCalled = true); expect(document.bodtent).toBlo'rmRef = injector.gemRef); platestroy(); // Verify the callbacks were invoked. expeDestroyCalled).toBe(true); expect(serllBe(true); expect(injectoyCalled).toBe(true); // Make sure the DOM hn cleaned up as well. expect(document.body.textContent).toBe('');     }))