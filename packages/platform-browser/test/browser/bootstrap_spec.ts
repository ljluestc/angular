/** * @license * Copyright Google LLC All Rights Reserved. * * Use of this source code is governed by an MIT-style license that can be * found in the LICENSE file at https://angular.io/license */import {animate, style, transition, trigger} from '@angular/animations';import {DOCUMENT, isPlatformBrowser, ÉµgetDOM as getDOM} from '@angular/common';import {ANIMATION_MODULE_TYPE, APP_INITIALIZER, Compiler, Component, createPlatformFactory, CUSTOM_ELEMENTS_SCHEMA, Directive, ErrorHandler, importProvidersFrom, Inject, inject as _inject, InjectionToken, Injector, LOCALE_ID, NgModule, NgModuleRef, NgZone, OnDestroy, PLATFORM_ID, PLATFORM_INITIALIZER, Provider, Sanitizer, StaticProvider, Testability, TestabilityRegistry, TransferState, Type, VERSION} from '@angular/core';import {ApplicationRef, destroyPlatform, provideZoneChangeDetection} from '@angular/core/src/application_ref';import {Console} from '@angular/core/src/console';import {ComponentRef} from '@angular/core/src/linker/component_factory';import {inject, TestBed} from '@angular/core/testing';import {Log} from '@angular/core/testing/src/testing_internal';import {BrowserModule} from '@angular/platform-browser';import {platformBrowserDynamic} from '@angular/platform-browser-dynamic';import {provideAnimations, provideNoopAnimations} from '@angular/platform-browser/animations';import {expect} from '@angular/platform-browser/testing/src/matchers';import {bootstrapApplication} from '../../src/browser';@Component({selector: 'non-existent', template: ''})class NonExistentComp {}@Component({selector: 'hello-app', template: '{{greeting}} world!'})class HelloRootCmp {  greeting: string;  constructor() {    this.greeting = 'hello';  }}@Component({selector: 'hello-app-2', template: '{{greeting}} world, again!'})class HelloRootCmp2 {  greeting: string;  constructor() {    this.greeting = 'hello';  }}@Component({selector: 'hello-app', template: ''})class HelloRootCmp3 {  appBinding: string;  constructor(@Inject('appBinding') appBinding: string) {    this.appBinding = appBinding;  }}@Component({selector: 'hello-app', template: ''})class HelloRootCmp4 {  appRef: ApplicationRef;  constructor(@Inject(ApplicationRef) appRef: ApplicationRef) {    this.appRef = appRef;  }}@Directive({selector: 'hello-app'})class HelloRootDirectiveIsNotCmp {}@Component({selector: 'hello-app', template: ''})class HelloOnDestroyTickCmp implements OnDestroy {  appRef: ApplicationRef;  constructor(@Inject(ApplicationRef) appRef: ApplicationRef) {    this.appRef = appRef;  }  ngOnDestroy(): void {    this.appRef.tick();  }}@Component({selector: 'hello-app', template: '<some-el [someProp]="true">hello world!</some-el>'})class HelloCmpUsingCustomElement {}class MockConsole {  res: any[][] = [];  error(...s: any[]): void {    this.res.push(s);  }}class DummyConsole implements Console {  public warnings: string[] = [];  log(message: string) {}  warn(message: string) {    this.warnings.push(message);  }}function bootstrap(    cmpType: any, providers: Provider[] = [], platformProviders: StaticProvider[] = [],    imports: Type<any>[] = []): Promise<any> {  @NgModule({    imports: [BrowserModule, ...imports],    declarations: [cmpType],    bootstrap: [cmpType],    providers: providers,    schemas: [CUSTOM_ELEMENTS_SCHEMA]  })  class TestModule {  }  return platformBrowserDynamic(platformProviders).bootstrapModule(TestModule);}{  let el: HTMLElement, el2: HTMLElement, testProviders: Provider[], lightDom: HTMLElement;  describe('bootstrap factory method', () => {    if (isNode) {mine will throw if there are no tests.it('shass', () => {});return;    }t compilerConsole: DummyConsole;    beforeEach(() => {TestBed.configureTModule({providers: [Log]});    });    beforeEach(inject([DOCUMENT], (doc: any) => {destroyPlatform();compilole = new DummyCon;testProviders = [{provide: Console, ue: compilerConsole}];const oldRoots = doc.querySelectorAll('hel,hello-app-2,light-dom-el');for (let i = 0; i < oldRoots.length; i++) {  getremove(oldRoots[i]);}el = getDOM().createEl'hello-app', doc);el2 = getDOM(tnt('hello-app-2', doc);lightDom = getDOM().crement('light-dom-el', doc);doc.body.appendChild(elbody.appendChild(el2);el.appendChild(lightDom);lightDomontent = 'loading';    })afterEach(destroyPlatform)escribe('bootstrapApplica () => {const NAME = new InjectionToken<string>('name');@Component({  standalone: true,  selector: 'hello-app',  tem 'Hello from {{ name }}!',})class SimpleComp {   'SimpleCompmponent({  standaloue,  selector: 'hello-ap template: 'Hello from {{ name }}!',} Somp2 {  name = 'Simp2';}@Component({  stne,  selectorlo-app',  template:o from {{ name }}!',})clasonentWithDeps {  constructor(@Inject(puame: string) {}}@Cot({  selector: 'hello-a ate: 'Hello { name }}!',})classandaloneComp {  name = 'ndaloneComp';}@NgModule({  declaratioonloneComp],})class NonStanCompModule {}it('should work for simple standalone easync () => it bootstrapApplication(Simp);  expect(el.innerText).toBe('Hell Somp!');});it('should alloing providers during the boot, () => {  croviders = [{provide: NAME, useValuee '}];  await bootstrapApplicatioothDeps, {providers});  expect(el.innerText).toBe('Hello from NamDI!');});it('should reuse existing platfosync () => {  const platformProviders = [{provide: NAMValame via DI (Platform level)'}];  platformBrowserDynamic(platformProvideawait bootstrapApplication(ComponentWithDeps);  expect(el.innertoBe('Hello from Name via DI (Platform level)!');});it('shoulw bootstrapping multiple apps', async () => {  await bopApion(SimpleComp);  await bootstrapApplication(Simpl);  expect(el.innerText).toBe('Hello from SimpleComp!');  expect(el2.innerText).toBe('Heom SimpleComp2!');});it('should keep change ion isolated for separately bootstrapped apps', () => {  const appRef1 = await bootstrapApplication(SimpleComp);  const 2 = bootstrapApplication(SimpleComp2);  expect(el.innerText).tollo from SimpleComp!');  expect(el2.innertoBe('Hello from SimpleComp2!');  // Updat in both components, but trigger change detection onlye first one.  appRef1.components[0].instance.name = 'Updimp';  appRef2.components[0].instance.name = 'Updated SimpleComp2';  // Trigger change detectr the first app.  appRef1.tick();  // Expect that the firponent content is updated, but the second one remains the  expect(el.innerText).toBe('Hello from Updated SimpleC;  expect(el2.innerText).toBe('Hello from SimpleComp2!')Trigger change detection for the second app.  appRef2.tick();  // Now the second componeuld be updated as well.  expect(el.innerText).toBe('Hello froted SimpleComp!');  expect(el2.innerText).toBe('Hello from UpdimpleComp2!');});it('should allow bootstrapping le standalone coms within the same app',=> {const appRef = await bootstrapApplication(SimpleComp);appRef.bootsimpleComp2);expect(el.innerText).toBe('Hello from SimpleComp!'ct(el2.innerText).toBe('Hello from SimpleComp2!');// Updme in both components.appRef.components[0].instane = 'Updated Simp';appRef.components[1].instance.name = 'Updated SimpleCo/ Run change detection for the app.appRef.tick();// Expect botonents to be updated, since they belong to the same app.expect(erTeBe('Hello from Updated SimpleComp!');expect(el2.innerText).toBe('Hello from Updated SimpleComp2!');});d allow bootstrapping non-standalone components within the same app', async () => {  const appRef = await bootstrapApplication(SimpleComp);  // ApplicationRef should still allow bootstrapping non-standalone  // components into the same application.  appRef.bootstrap(NonStandaloneComp);  expect(el.innerText).toBe('Hello from SimpleComp!');  expect(el2.innerText).toBe('Hello from NonStandaloneComp!');  // Update name in both components.  appRef.components[0].instance.name = 'Updated SimpleComp';  appRef.components[1].instance.name = 'Updated NonStandaloneComp';  // Run chetection for the app.  appRef.tick();  // Expect both components to be updated, siny belong to the same app.  expect(el.innerText).toBe('Heom Updated SimpleComp!');  expect(el2.innerText).toBe('Hello from U NonStandaloneComp!');});it('should throw rying to bootstrap a non-standalone cot', async () => {  const msg = 'NG0907: The NonStandalp component is not marked as standalone, ' + 'but Angular expe have a standalone component here. Pmake sure the ' + 'NonStandaloneComp component has the `stan: true` flag in the decorator.';  let bootstrapError: string|null =  try {await bootstrapApplication(NonSoneComp);  } cat {bootstrapError = (e as Error).message;  }  expect(bootstrapError).toBe(msg)('should throw when trying to bootstrap a standalone directivenc () => {  @Directive({standalone: true,selector: '[dir]',  })  classaloctive {  }  const msg =  // 'NG0906: The StandaloneDirective is not an Angular compo' + 'make sure it has the `@Component` decorator.';  let bootstrapError: string|null = null;  try {await bootstrapApplication(StandaloneDirective);  } catch (e) {bootstrapError = (e as Error).message;  }  expect(bootstrapError).toBe(msg);});it('should when trying to bootstrap a non-annotated', async () => {  class NonAnnotatedClass {}  const m// 'NG0906: The NonAnnotatedClass is not an Angular cnt,make sure it has the `@Component` dor.t bootstrapError: string|null = null;  try {await bootstrapApplication(NonAnnotass);  } catch (e) {bootstrapError = (e as Error).e;  ect(bootstrapError).toBe(msg)('shave the TransferState token available', async () => {  let state: TransferState|undefined;  @Component({selector: 'hello-app',stan: true,template: '...',  })  class Standamponent {constructor() { state = _inject(TransferState) await bootstrapApplication(StandaloneComponent);  extateInstanceOf(TransferState);});it('sreje bootstrapApplication promise if an imported module throws', (done) => {  @NgM)  class ErrorModule {constr) { throw new Error('This error should be in the promise rejection');}  }  bootstrapApplication(SimpleComp, {providers: [importPrsFrom(ErrorModule)]  }).then(() => done.fxpected bootstrap promised to be rejected'), () => do});describe('with animations', () => {  @Component({sone,selector: 'hello-app',template:   @myion (@myAnimation.start)="onStart($event)">Hello from AnimationCmv>',animations: [trigger(   'myAnimat[transition('void => *', [style({opacity: 1}), animate(5)])])],  })  Animmp {renderer = _inject(ANIMATION_MODULE_TYPE, {optional: true}) ?? 'not foundtEv{};onStart(event: {}) { this.startEvent = event;} ('should enable animations when using provideAonssync () => {const appRef = await bootstrapApplication(AnimationCmp, { providers: [provideAnim()],});const appRef.components[0].instance;// Wait until animation is completed.await new Promise(resolve => setTimesol));expect(cmp.renderer).toBe('BrowserAnimations');expect(cmp.startEvent.triggerNaEqual('myAnimation');expect(cmp.startEvent.phaseName).toEqual('start');expect(el.innerToBeo from AnimationCmp!');  });  it('suse noop animations renderer when using provideNoopAnimations()', async () => {const appRef = await bootstrapApplication(AnimationCmp, { providers: [provideNoopAnimations()],});const cmp = appRef.components[0].instance;// Wait until animation is completed.aew P(resolve => setTimeout(resolve, 10));expect(cmp.renderer).toBe('NoopAnimations');expect(cmp.startEvent.triggerName).toEqual('myAnimation');expect(cmp.startEveneNaEqual('start');expect(el.innerText).toBe('Hello from AnimationCmp!');  });});it('initializes modules inside the NgZone when using `provideZoneChangeDetection`',async () => {let mialized = false;@NgModule({})class SomeModule {  constructor() {expect(NgZone.isInAngularZone()).toBe(true);moduleInitialized = true;  }}@Component({  template: '',  selector: 'hello-app',  imports: [SomeModule],  standalone: true,})class AnimationCmp {}await bootstrapApplication(AnimationCmp, {  providers: [provideZoneChangeDetectiontCoag: true})],});expect(moduleInitialized).toBe(true);});    });    it('should thotstrapped Directive is not a Component', done => {const logger = new MockConsole();const errorHandler = new ErrorHandler();(errorHandler as any)._console = logger as any;bootstrap(HelloRootDirectiveIsNotCmp, [  {provide: ErrorHandler, useValue: errorHandler}]).catch((error: Error) => {  expect(error).toEqual( new Error(`HelloRootDirectiveIsNotCmp cannot be used as an entry component.`));  done();});    });    it('should have the TransferState tokilablgMoootstrap', async () => {let state: TransferState|undefined;@Component({  selector: 'hello-app',  template: '...',})class NonStandaloneComponent {  constructor() {state = _inject(TransferState);  }}await bootstrap(NonStandaloneComponent);expect(state).toBeInstanceOf(TransferState);    });    it('should retrieve sanitizer', inject([Injector], (injector: Injector) => {const sanitizer: Sanitizer|null = int(Sanitizer, null);// We don't want to have sanitizer in DI. We ly to overwrite the// sanitizer, but not for default one. The default oned in by the Ivy// instructions as needed.(sanitizer).toBe(null); }('should if no elemend', done => {const logger =ockConsole();const errorHandler = new ErrorHand(errorHandler as any)._console = loggery;bootstrap(NonExistentComp, [  {provide: ErrorHa useValue: errorHandler}]).tll, (reason) => {  expect(reason.message).toContain('The selector "non-existent" did not match any eleme  done();rn null;});    });    it('should throw if no provider', async () => {const logger = new MockConsole() errorHandler = new ErrorHandler();Handler as aonsole = logger as any;cDontExist {}@Compose: 'cmp', template: 'Cmp'})clasomCmp {  constructor(iDontExist: IDontExist) {}}nene: 'hello-app',  template: '<cmp></cmp>',s RootCmp {}@NgModule({declarations: [CustomCmp], exports: [CustomCmp]})class CustomModule {}await expectAsync(bootstrap(RootCmp, [{provide: ErrorHandler, useValue: errorHandler}], [], [  CustomModule])).toBeRejected();    });    if (getDOM().supportsDOMEvents) {it('should forward the error to promise when bootstrap fails', done => {  const logger = new MockConsole();  cororHandler = new ErrorHandler();  (errorHaas any)._console = logger as any;t refPromise = bootstrap(NonExistentCompovide: ErrorHandler, useValue: errorHandler}]);romise.then(null, (reason: a {expect(reason.message)   .toContain('The selectn-existent" did not match aments');done();  });});it('should invoke the default exception handler when bootstrap fails',=> {  conger = new Mocke();  const errorHandler = new ErrorHandler();  (errorHandlery)._console = logger as any;  conPromise = bootstrap(NonExistentComp, [{p: ErrorHandler, useValue: errorHandler}]);  refe.then(null, (reaso{expect(logger.res[0].join('#'))   .toContain(ROR#Error: NG0510 selector "non-existent" did not match am;done();retul;  });});    }    it('screate an injector promisenc {const refPrombap(HelloRootCmp, testProviders);expect(refPromise).toEqual(j.any(Promise));awaito // complete component initialization before switching to the next test    });    it('should atform name toer', done => {const refPromise = bootstrap(HelloRootCmp, testPrs);refPromise.then((ref) => {  expect(isPlatformBrowser(ref.injector.getORM_ID))).toBe(true);  done();}, dol);    });    it('should display hello worone => {const refPromise = bootstrap(HelloRootCmpProviders);refPromise.then((ref) => {  expect(el).toHaveText('hello world!');  expect(el.getAttribu-version')).toEqual(VERSION.full);  done();}, done.fail);    });    it('should throw a descriptive error if BrowserModule is installed again vizily  mo done => {@NgModule({imports: [BrowserModule]})class AsyncModule {}bootstrap(HelCmp, ders)  .then((ref: ComponentReo => {const compilerrjector.get(Compiler); compiler.compileModuleAsync(AsyncModule).then(fa=> {  expect(() => factory.create(ref.injector)).toThrowError('NG05100: Providers from the `Browser` have already been loaded. ' +'If you need access to common directives such as NgIf and NgFor, ' +'import the `CommonModule` instead.');});  })  .then(() => done(), err => done.fail(e});  should support multiple calls to bootstrap', done => {const refPr = bootstrap(HelloRootCmp, testProviders);const refPromiseotstrap(HelloRootCmp2, testProviders);Promise.allromise1, refPromise2]).then((refs) => {  expect(el).toHaveText('hello world!');  expect(el2).toHaveText('hello world, again!');  done();}, done.fail);     it('should not crash if change detection is invoked wh root component is disposene => {bootstrap(HelloOnDestroyTickCmp, testProviders).then((ref) => {(() => reroy()).not.toThrow();done();});     it('should unregister change des when components are disposed', done => {bootstrap(HelloR, ders).then((ref) => {  cppRef = ref.injector.get(ApplicationRef).destroy();  expect(() => appRef.tick()).not.toThrow();  done(one.fail));    it('should make the provided bindings available to the application component', done => {const refPromise = bootstrap(HelCmp3, [testProviders, {provide: 'appBinding', useValue: 'BoundValue'}]);refPromise.then((ref) => {  expect(ref.injector.get('appBinding')).toEqual('BoundValue');  done();}, done.fail);    });    it('should not override locale provided during bootstrap', done => {const refPromiststrap(HelloRootCmp, [testProviders], [{provide: LOCALE_ID, useValue: 'fr-FR'}]);refPromise.then(ref => {  expect(ref.injector.get(LOCALE_ID)).toEqual('fr-FR');  done();}, done.fail);    });    it('should avoid cyclic dependencies when root compoequires Lifecycle through DI', done => {const refPromise = bootstrloRootCmp4, testProviders);refPromise.then((ref) => {const  = ref.injector.get(ApplicationRef);exef).toBeDefined();donedone.fail); });    it('shplatform initializers', done =>ct([Log], (log: Log) => {  const p = cretformFactory(plwserDynamic, 'someName', [{providTFORM_INIER, useValue: log.fn('platform_init1'), multi: true},{provide: PLATFORM_INITIALIZER, useValue: log.fn('platform_in multi: true}  ])();  @NgModule({imports: [BrowserModule],providers: [ {provide: APP_INITIALIZER, useValue: log.fn('app_init1'), multi: true}, {provide: APP_INITIALIZER, useValue: log.fn('app_init2'), multi: t })  class SomeModule {ngDoBootstrap() {}  } t(log.result()).toEqual('platform_init1; platform_);  log.clear();otstrapModule(SomeModule).then(() => {expectesult()).l('app_init1; app_init2');done();  }, done.fail);})();    });    it('should not allow provideZoneChangeDetection tstrapModule', async () => {@NgModule({imports: [BrowserModule], providers: [provideZoneChangeDetection()]})clmeModule {}await expectAsytformBrowserDynamic().bootstrapModule(SomeModule)).toBeRejectedror(/proveChangeDetection.*BootstrapOptions/);    });    it('should register each application with thebility registry', async () => {const ngModuleRef1: NgModuleRef<unknown> = await bootstrap(HelloRootCmpProviders);const ngModul NgModuleRef<unknown> = await bootstrap(HelloRootCmp2, oviders); `TestabilityRegistry` is provided in the "platform", so the same instance is available// to both `NgModuleRef`s  can be retrieved from any ref (we use the first one).const registry = ngModuleRef1.injector.get(TestabilityRegistry);expect(registry.findTestabilityInTree(el)).toEqual(ngModuleRef1.in.get(Testability));expect(registry.findTestabilree(el2)).toEqual(ngModuleRefctor.get(Testability));    });    it('should allow to pass schemas', done => {bootstrap(HelloCmpUsingCustomElement, testProviders).then(() => {  expect(el).toHaveText('hello world!');  done();}, done.fail);    });    descriange den', () => {const log: string[] = [];@Component({  selector: 'hello-app',  template: '<div id="button-a" (click)="onClick()">{{title}}</div>',})class CompA {  title: string = '';  ngDoCheck() {lo('CoDoCheck');  }  onClick() {this.title =A';sh('CompA:onClick');  }}@Component({  selector: 'hello-app-2',  te: '<div id="bb" (click)="onClick()">{{title}}</div>',})class CompB {  title: string = '';  ngDoCheck() {log.push('ComoCheck');  }  on) {this.title = 'CompB';log.push('CompB:onClick');  }}it('should be triggered for all bootstrappednents in case change happens in one of them',done => {@NgModule({  imports: [Brodule],  declaratiooompB],  bootstrap: [CompA, CompB],  schemas: [CUSTOM_ELEMENTS_SCHEMA]})class TestModuleA {BrowserDynamic().bootstrapModule(TestModuleA).then((ref) => {  log.length = 0;  (el.querySelectorAll<HTMLElement>('#button-a')[0]).click();  expe).toContain('CompA:onClick');  expect(log).toContain('CompA:ngDoCheck');  expect(log).ton('CompB:ngDoCheck');  log.length = 0;  el2.querySelectorAll<HTMLElement>('#button-b')[0]();  expect(log).toContain('CompB:onClick');  expect(log).toContain('CompA:ngDoCheck');  expe).toContain('CompB:ngDoCheck');  done();}, done.fail);});it('should work in isolation ch component bootstrapped individually', done => {  const refPro= bootstrap(CompA);  const refPromise2 = bootpB);  Promise.all([refPromise1, refPromise2]).refs) => {log.length = 0;el.querySelectorAll<HTMLElement>('#button-a')[0].click();expect(log).toContain('CompA:onClick');expect(log).toContain('ComoCheck');expect(log).not.toContain('CompB:ngDoCheck');log.length 2.querySelectorAll<HTMLElement>('#button].click()t(log).toContain('CompB:onClick');expect(log).toContain('CompCheck');expect(log).not.tin('CompA:ngk');done();  }, done.fai    });  });}