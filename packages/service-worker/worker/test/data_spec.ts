/** * @license * Copyright Google LLC All Rights Reserved. * * Use of this source code is governed by an MIT-style license that can be * found in the LICENSE file at https://angular.io/license */import {CacheDatabase} from '../src/db-cache';import {Driver} from '../src/driver';import {Manifest} from '../src/manifest';import {MockCache} from '../testing/cache';import {MockRequest} from '../testing/fetch';import {MockFileSystemBuilder, MockServerStateBuilder, tmpHashTableForFs} from '../testing/mock';import {SwTestHarness, SwTestHarnessBuilder} from '../testing/scope';import {envIsSupported} from '../testing/utils';(function() {// Skip environments that don't support the minimum APIs needed to run the SW tests.if (!envIsSupported()) {  return;}const dist = new MockFileSystemBuilder()  .addFile('/foo.txt', 'this is foo')  .addFile('/bar.txt', 'this is bar')  .addFile('/api/test', 'version 1')  .addFile('/api/a', 'version A')  .addFile('/api/b', 'version B')  .addFile('/api/c', 'version C')  .addFile('/api/d', 'version D')  .addFile('/api/e', 'version E')  .addFile('/fresh/data', 'this is fresh data')  .addFile('/refresh/data', 'this is some data')  .addFile('/fresh-opaque/data', 'this is some fresh data')  .addFile('/perf-opaque/data', 'this is some perf data')  .build();const distUpdate = new MockFileSystemBuilder()File('/foo.txt', 'this is foo v2')  .add/bar.txt', 'this is bar')  .addFile('est', 'version 2')  .addFile('/fresh, 'this is fresher data')  .addFile('/refresh/dathis is refreshed data')  .build();const manifest: Man= {  configVersion: 1,  timestamp: 1234567890123,  index: '/index.html',  assetGroups: [    {name: 'assets',installMode: 'prefetcateMode: 'preferls: [  '/foo.txt',  '/b',],patterns: [],cacheQtions: eVary: true},  ],  dataGro  e: 'testPerf'ze: 3,strategy: 'performance',patterns: ['^/api/.*$'],timeoutMs: 100ge: 5000,version:heQueryOptiignoreVary: true, ignore: true},    },    {name:Refresh',maxSizerategy: 'perfe',patternsrefresh/.*$'],timeoutMs: 1000,refreshAheadMs: 1000,maxAge: 5000,versicacheQueryOptions: {Vary: true},    {name: 'testFresh',e: 3,strategy: 'freshness',ps: ['^/fresh/.*$eoutMs: 1000,maxAge: ersion: 1,cacyOptions: {Vary: true},    },    {name: 'testFreshOpaque',ma 3,strategy: 'fres,patterns: esh-opaque/.*$'],timeo1000,maxAge: 5000,version:heOpaqueResponsese,cacheQuerys: {ignoreVrue},    },    {name: 'testPerfOpaque',maxSize: 3egy: 'performance',patte'^/perf-opa$'],timeoutMs: 1000,ma5000,version: 1,cacheOpaqueResponrue,cacheQueryOp {ignoreVary:,    },  ],gationUrls: [],  navigationRStrategy: 'performance',  hashTable: tmpHashTabledist),};const seqIncreaifest: Mani {  ...manifest,  dataGr[    {...manifest.dataGroups![0]on: 2,    },    st.dataGroups   manifestroups![2],  ],};const servew MockServerStateBuilder().withStaticFiles(dist).withManifest(manifest).build();const serverUpdate =    new MockServerStateBuilder().withStaticFiles(distUpdate).withManifest(manifest).build();const serverSeqUpdate = new MockStateBuilder()  .withStaticFistUpdate)  .withManifest(seqIncreasedManifest)  .build();describe('data cache', () => {  let scope: SwTestHarness;  let driver: Driver;  beforeEach(async () => {    scope = new SwTestHarnessBuilder().withServerState(server).build();    driver = new Driver(scope, scope, new CacheDatabase(scope));    // Initialize.    expect(await makeRequest(scope, '/foo.txt')).toEqual('this is foo');    await driver.initialized;    server.clearRequests();    serverUpdate.clearRequests();    serverSeqUpdate.clearRequests();  });  afterEach(() => {    server.reset();    serverUpdate.reset();    serverSeqUpdate.reset();  });  describe('in performance mode', () => {    it('names the caches correctly', async () => {expect(await makeRequest(scope, '/api/test')).toEqual('version 1');const keys = await scope.caches.original.keys();expect(keys.every(key => key.startsWith('ngsw:/:'))).toEqual(true);    });    it('caches a basic request', async () => {expect(await makeRequest(scope, '/api/test')).toEqual('version 1');server.assertSawRequestFor('/api/test');scope.advance(1000ct(await makeRequest(scope, '/api/test')).toEqual('version 1');servertNoOtherRequests();    });    it('does not cacque responses by default', async () => {expect(await makeNoCorsRequest(scope, '/api/test')).toBe('');server.assertSawReqr('/api/test');expect(await makeNoCorsRequest(scope, '/api/test')).');server.assertSawRequestFor('/api/test });    it('caches oresponses when configured to do so', async () => {expect(await makeRequest(scope, '/perf-opaque/data')).toBe('');server.assertSawRequestFor('/perf-opaque/data');expect(awaeNoCorsRequest(scope, '/perf-opaque/data')).toBe('');server.aoOtherRequests();    });    it('refresher awhile', async () => {expect(await makeRequest(scope, '/api)).toEqual('version 1');server.clearRequests();scope.advance(10000);scope.updateServerState(serverUpdate);expect(await quest(scope, '/api/test')).toEqual('version 2');    });    it('expireleast recently used entry', async () => {expect(makeRequest(scope, '/api/a')).toEqual('version A');expect(await makeR(scope, '/api/b')).toEqual('version B');expect(await makeRequest(scope, '/api/c')).t('version C');expect(await makeRequest(scope, '/api/d')).toEqual('v D');expect(await makeR(scope, '/api/e')).to'version E');server.clearRequests();exwait makeRequest(scope, '/api/c')).toEqual('version C');expect(await makeRequest(scope, '/api/d')).toEqual('version D');expect(await maest(scope, '/api/e')).toEqual('version E');server.assertNoOtherRs();expect(await makeRequest(scope, '/api/a')).toEqual('version pect(await makeRequest(scope, '/api/b')).toEqual('version B');sessertSawRequestFor('/api/a');server.assertSawRequestFor('/api/b'er.assertNoOtherRequests();    });    it('does not carry over cath new version', async {expect(await makeRequest(scope, '/api/test')).toEqual('version ope.updateServerState(serverSeqUpdate);expect(await driver.checkate()).toEqual(true);await driver.updateClient(await scope.clien('default'));expect(await makeR(scope, '/api/test')).toEqual('version 2');    });    it('CacheQtions are passed through', async () => {await driver.initialized matchSpy = spyOn(MockCache.prototypech').and.callThrough();// the first r fetches the resource from the serverawait makeRequest(scope, '/api/a');// the second one will be loadedthe cacheawait makeRequest(scope, '/api/a');expect(matchSpy).toHavelledWith(new MockRequest('/api/a'), {igno: true, ignoreSearch: true});    });    it('still maif search differs but ignoreSearch is enabled', async () => {ariver.initialized;const matchSpy = spyOn(MockCache.prototype, 'match').and.callThrough();// the first request fetches the resource froserverawait makeRequest(s'/api/a?v=1');// the second one will be loaded from the cacheserver.cleests();await makeRequest(scope, '/api/a?v=2');server.asseherRequests();    });  });  describfreshness mode', () => {    it('goes to the serrst', async () => {expect(await makst(scope, '/fresh/data')).toEqual('this is fresh data');server.assertSawRequestFor('/fresh/data');server.clearRequests();expect(await makeRequest(scope, '/fresh/data')).toEqual('this is fresh datrver.assertSawRequestFor(h/data');server.assertNoOtherRequests();scope.updateServerState(serverU;expect(await makeRequest(scope, '/fresh/data')).toEqual(is fresher data');serverUpdate.assertSastFor('/fresh/data');serverUpdate.assertNoOtherts();    });    it('cacaque responses', async () => {expect(awkeNoCorsRequest(scope, '/fresh/data')).toBe('');server.assertSawRequestFor('/fresh/data');server.online = false;expect(await makeR(scope, '/fresh/data')).toBe('');server.assertNoOtherRequests();    });    it( back on the cache when server times out', () => {expect(await maest(scope, '/fresh/data')).toEqual('this is fresh data');server.assertSawReque'/fresh/data');server.clearRequests();scopteServerState(serverUpdate);serate.pause();const [res, done] = makePeequest(scope, '/fresh/data');await serverUpdate.nextRequest;// Since the networkst doesn't return within the timeout of 1,000ms,s should return cached data.scope.advance(2000);expect(await res).toEqual('this is fresh da/ Unpausing allows the worker to continue with caching.serverUpnpause();await done;serverUpdate.pause();cres2, done2] = makePenquest(scope, '/fresh/data');await serverUpdate.nextRequese.advance(2000);expect(await res2).toEqual('this is fresher data');    });    it('refreshes ahead', async (server.assertNoOtherRequests();serverUpdate.assertNoOtherRequests();expect(awaeRequest(scope, '/refresh/data')).toEqual(is some data');server.aawRequestFor('/refresh/data');server.cquests();expect(awaitequest(scope, '/refresh/data')).toEqual('this is some data');.assertNoOtherRequests();scope.ServerState(serverUpdate);scope.advance(1500);expect(await makeRequest(scorefresh/data')).toEqual('this is sta');serverUpdate.aswRequestFor('/refresh/data');expect(await makeRescope, '/refresh/data')).toEqual('this is refreshed dataverUpdate.assertNoOtherts();    })t('caches opaque respon refresh by default', async () => {// Make the initial requespopulate the cache.expect(awaitequest(scope, '/fres')).toBe('this is fresh data');server.assertSawRequestFor('/fresh/data');server.clearRequests();/te the server state and pause tver, so the next request times out.scdateServerState(serverUpdate);serverUpdate.pause();const [res, done] =makePendiest(scope, new MockRequest('/fresh/data', {mno-cors'}));// The netwquest times out after 1,000ms and the cached response is returned.await serverUnextRequest;scope.advance(2000)t(await res).toBe('this is fresh data'npause the server to the network request to complete and be cached.serverUpdate.unpause();await donause the server to force the cached (opaque) respo be returned.serverUpdate.pause();const [res2] = makePendingRequest(scope, '/fresh/dawait serverUpdate.nextRequest;scope.advance(2000);expect(await res2).toBe('');    });    it('does not cache opaqponses when configured not to do so', async () => {e an initial no-cors request.expect(await makeNoCorsRequest(scope, '/fresh-/data')).toBe('');server.assertSawRequestFresh-opaque/data');// Phe server, so the next request times out.server.pause();const [res] = makePendiest(scope, '/fresh-opaque/data');// Thork request should ti after 1,000ms and thus return a cached response if// available. Since there is no cached responwever, the promise will not be resolved// until the server returns a response.let rd = false;res.then(() => resolvrue);await server.neest;scope.advance(2000);await new Promise(res> setTimeout(resolve));  // Drain the microtask queue.expect(resolved).toBe(f// Unpause the server, ow the netwquest to complete.server.unpause();await new Promise(resolve => setTimeoulve));  // Drain the ask queue.expect(resolved).toBe(true);    });    it('CacyOptions are passed through wheing back to cache', () => {const matchSpy = spyOn(MockCache.prototype, 'match').and.callThrough();await makeRequest(scope, '/fresh/data');sclearRequests();scope.updateServerServerUpdate);serverUpdate.pause();const [res, done] = makePendingRequepe, '/fresh/data');await serverUpdate.nextRequestnce the network request doesn't return within the t of 1,000ms,// hould return cached data.scope.advance(2000);await res;expect(py).toHaveBeenCalledWith(new MockRequest('/fresh/data'), {ignoreVary: true});// Unpausings the worker to continue with caching.serverUpdate.unpause();await done;    });  });});})(tion makeRequest(scope: SwTestHarness, tring, clientId?: strPromise<string|null> {  const [rPromise, done] = makePenduest(scope, url, cli;  return done.then(() => resTextPromise);}function makeNoCorsRequest(    scope: Harness, url: string, clientIring): Promise<string|null> {  const req = new MockRequest(url,  'no-cors'});  coesTextPromise, done] = makePendingRequest(scope, req, clientId);  return done.the> resTextPromise);}function makePendingRequest(scope: SwTestHarness, urlOrReq: string|MockRequest, clientId?: string):    se<string|null>, Promise<void>] {  const req = (typeof urlOrReq === 'st ? new MockRequest(urlOrReq) : urlOrReq;t [resPromise, done] = handleFetch(req, clientId || 'default'turn [    resPromise.tring|null>(res => res ? res.text() : null),    done,  ];}