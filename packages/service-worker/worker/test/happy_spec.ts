/** * @license * Copyright Google LLC All Rights Reserved. * * Use of this source code is governed by an MIT-style license that can be * found in the LICENSE file at https://angular.io/license */import {processNavigationUrls} from '../../config/src/generator';import {CacheDatabase} from '../src/db-cache';import {Driver, DriverReadyState} from '../src/driver';import {AssetGroupConfig, DataGroupConfig, Manifest} from '../src/manifest';import {sha1} from '../src/sha1';import {clearAllCaches, MockCache} from '../testing/cache';import {MockWindowClient} from '../testing/clients';import {MockRequest, MockResponse} from '../testing/fetch';import {MockFileSystem, MockFileSystemBuilder, MockServerState, MockServerStateBuilder, tmpHashTableForFs} from '../testing/mock';import {SwTestHarness, SwTestHarnessBuilder} from '../testing/scope';import {envIsSupported} from '../testing/utils';(function() {// Skip environments that don't support the minimum APIs needed to run the SW tests.if (!envIsSupported()) {  return;}const dist =    new MockFileSystemBuilder()File('/foo.txt', 'this is foo')  .add/bar.txt', 'this is bar')  .addFile('xt', 'this is baz')  .addFile('/qux.tthis is qux')  .addFile('/quux.txt', is quux')  .addFile('/quuux.txt', 'thisuux')  .addFile('/redirect-target.txt', 'as a redirect')  .addFile('/lazy/unchanged1.txt', 'this ianged (1)')  .addFile('/lazy/unchanged2.txt', 'this is unch(2)')  .addFile('/lazy/redirect-target.txt', 'this was a re too')  .addUnhashedFile('/unhashed/a.txt', 'this is unhashed', {'Control': 'max-age=10'})  .addUnhashedFile('/unhashed/b.txt', 'this is unhashed b', {'Cachrol': 'no-cache'})  .addUnhashedFile('/api/foo', 'this is api foo', {'Cache-Control': 'no-})  .addUnhashedFile('/api-static/bar', 'this is static api bar', {'Cache-Controo-cache'})  .build();const distUpdate =    new MockFileSystemBuilder()  .addFile('/foo.txt', 's foo v2')  .addFile('/bar.txt', 'this is bar')  .addFile('/t', 'this is baz v2')  .addFile('/qux.txhis is qux v2')  .addFile('/quux.txt's is quux v2')  .addFile('/quuux.txt', 's quuux v2')  .addFile('/redirect-target 'this was a redirect')  .addFile('/lazy/ued1.txt', 'this is unchanged (1)')  .addFiley/unchanged2.txt', 'this is unchanged (2)')  .addUnhashed/unhashed/a.txt', 'this is unhashed v2', {'Cache-Control': ge=10'})  .addUnhashedFile('/ignored/file1', 'this is not h by the SW')  .addUnhashedFile('/ignored/dir/file2', 'this is not handled by the SW either') d();const brokenFs = new MockFileSystemBuilder().addFile('/foo.txt', is foo (broken)').addFile('/bar.txt', 'this is bar (broken)').build();const brokfest: Manifest = {  configVersion: 1,  timestamp: 1234523,  index: '/foo.txt',  assetGroups: [{    'assets',    installMode: 'prefetch',    upde: 'prefetch',    urls: ['/foo.txt',    ],    patterns: [],    cacheQueryOptions: {ignoreVary: true},  }],  dataGroups: [],  navigationUrls: processNavigationUrls(''),  navigationRequestStrategy: 'performance', able: tmpHashTableForFs(brokenFs, {'/foo.txt': true}),};const brokenLazyManifest: Manifest = {  configVersion: 1,  timestamp: 1234567890123,  index: '/foo.txt',  assetGroups: [    {name: 'assets',installMode: 'prefetch',updateMode: 'prefetch',urls: [  '/foo.txt',],patterns: [],cacheQueryOptions: {ignoreVary: true},    },    {name: 'lazy-assets',installMode: 'lazy',update'lazy',urls: [ .txt',],patterns: [],cacyOptions: {ignoreVary:     }, ataGroups: []igrls: processNionUrls(''),  navigationRequestStrategy: 'perform  hashTable: tmpHashorFs(brokenFs, {'/ba: true}),};// Manifthout nion urls to tckompatibility  versions < 6.0.0.interface ManifestV5 {  configVersion: number;  appData?: {[key: string]: string};  index: string;  assetGroups?: AssetGroupConfig[];  dataGroups?: DataGroupConfig[];  hashTable: {[url: string]: string};}// To simulate versions < 6.0.0const manifestOld: ManifestV5 = {  configVersion: 1,  index: '/foo.txt',  hashTable: tmpHashTableForFs(dist),};const manifest: Manifest = {  configVersion: 1,  timestamp: 1234567890123,  appData: {    version: 'original',  },  index: '/foo.txt',  assetGroups: [    {name: 'assets',installMode: 'prefetch',updateMode: 'prefetch',urls: [  '/foo.txt',  '/bar.txt',  '/redirected.txt',],patterns: [  '/unhashed/.*',],cacheQueryOptions: {ignoreVary: true},    },    {name: 'other',installMode: 'lazy',updateMode: 'lazy',urls: [  '/baz.txt',  '/qux.txt',  '/lairected.txt',],ns: [],cacheQueryOptionsoreVary: true},    },  e: 'lazetch',install'lazy',update'prefetch',urls: [  .t'/quuux.txtlazy/unchanged1.t'/nchanged2.txt',],patterns: [],cacheQueryOptions: eVary: true}, ],  dataGroups: [   : 'api',version: 42e: 3600xSize: 100,st: 'freshness'rns: [  '/api/.*',],cachept{ignoreVary:     },    {name: 'api-static',version: 43,maxAge:00,maxSize: 100,strateerformance',patterns/api-static/.*',],cacheptions:reVary: true},  ],  navigatio processNavigationUrls(''vigationRequestStrategy: rm  hashTable: hTableForFs(dist),};const manifestUpdate: Manifest = {  configVersi  timestamp:67890123,  a: {    version: e',  },  indeoo.txt',  assetGroups:{name: 'assnstallMode: tcateMode: 'prefetch',urls: [  '/foo.txt',  '/bar.t'/redirected.txt',]rns: [  '/un/.*',],cacheQuerns: {ignoreVaue},    },    {name: 'otnstallMode:',updateMode: 'lazy: az.txt',  '/qux.txt',],patterns: [],cacheQueryOptions: {ignoreVary: true},    },    {name: 'lazy_prefetch',installMode: 'lazy',updateMode: 'prefetch',urls: [  '/quux.txt',  '/quuux.txt',  '/lazy/unchanged1.txt',  '/lazy/unchanged2.txt',],patterns: [],cacheQueryOptions: {ignoreVary: true},    }  ],  navigationUrls: processNavigation',[  '/**/file1**/file2',  '!/ignored/f  '!/ignored/dir/**',])igationtStrategy: 'pance',  hashTtmpHashTableForFs(ditenst serverBBase = new MockSeater().withStaticFiles(dist).withRedirect('/redirect', '/redirectt.txt').withRedirecty/redirected.txt', /redireget.txt').wit('/error.txt't  = serverBuile.withManifest(manifest).build();const serverRoll    serverBuilderBase.nifest({...manifest,tamp: manifest.timestam).buildst serverUpdatw MockServerStader().withStaticFiles(dise).withManifest(manifestU.wirect('/redirtxt', '/redirect-target.txt').build();const brokenServer =    new MockServerStateBuildethSiokenFs).withMa(brokenManifesld();const brokenLazr =    new MockServeruilder().withStaticFiles(brokenFs).withManifest(brokenLazyManifest).build();const server404 = new MockServerStateBuilder().withStaticFiles(dist).build();const manifestHash = sha1(JSON.stringify(manifest));const manifestUpdateHash = sha1(JSON.stringify(manifestUpdate));describe('Driver', () => {  let scope: SwTestHarness;  let driver: Driver;  beforeEach(() => {    server.reset();    serverUpdate.reset();    server404.reset();    brokenServer.reset();    scope = new SwTestHarnessBuilder().withServerState(server).build();    driver = new Driver(scope, scope, new CacheDatabase(scope));  });  it('activates without waiting', async () => {    const skippedWaiting = await scope.startup(true);    expect(skippedWaiting).toBe(true);  });  it('claims all clients, after activation', async () => {    const claimSpy = spyOn(scope.clients, 'claim');    await scope.startup(true);    expect(claimSpy).toHaveBeenCalledTimes(1);  });  it('cleans up old `@angular/service-worker` caches, after activation', async () => {    const claimSpy = spyOn(scope.clients, 'claim');    const cleanupOldSwCachesSpy = spyOn(driver, 'cleanupOldSwCaches');    // Automatically advance time to trigger idle tasks as they are added.    scope.autoAdvanceTime = true;    await scope.startup(true);    await scope.resolveSelfMessages();    scope.autoAdvanceTime = false;    expect(cleanupOldSwCachesSpy).toHaveBeenCalledTimes(1);    expect(claimSpy).toHaveBeenCalledBefore(cleanupOldSwCachesSpy);  });  it('does not blow up if cleaning up old `@angular/service-worker` caches fails', async () => {    spyOn(driver, 'cleanupOldSwCaches').and.callFake(() => Promise.reject('Ooops'));    // Automatically advance time to trigger idle tasks as they are added.    scope.autoAdvanceTime = true;    await scope.startup(true);    await scope.resolveSelfMessages();    scope.autoAdvanceTime = false;    server.clearRequests();    expect(driver.state).toBe(DriverReadyState.NORMAL);    expect(await makeRequest(scope, '/foo.txt')).toBe('this is foo');    server.assertNoOtherRequests();  });  it('initializes prefetched content correctly, after activation', async () => {    // Automatically advance time to trigger idle tasks as they are added.    scope.autoAdvanceTime = true;    await scope.startup(true);    await scope.resolveSelfMessages();    scope.autoAdvanceTime = false;    server.assertSawRequestFor('/ngsw.json');    server.assertSawRequestFor('/foo.txt');    server.assertSawRequestFor('/bar.txt');    server.assertSawRequestFor('/redirected.txt');    server.assertSawRequestFor('/redirect-target.txt');    expect(await makeRequest(scope, '/foo.txt')).toEqual('this is foo');    expect(await makeRequest(scope, '/bar.txt')).toEqual('this is bar');    server.assertNoOtherRequests();  });  it('initializes prefetched content correctly, after a request kicks it off', async () => {    expect(await makeRequest(scope, '/foo.txt')).toEqual('this is foo');    await driver.initialized;    server.assertSawRequestFor('/ngsw.json');    server.assertSawRequestFor('/foo.txt');    server.assertSawRequestFor('/bar.txt');    server.assertSawRequestFor('/redirected.txt');    server.assertSawRequestFor('/redirect-target.txt');    expect(await makeRequest(scope, '/foo.txt')).toEqual('this is foo');    expect(await makeRequest(scope, '/bar.txt')).toEqual('this is bar');    server.assertNoOtherRequests();  });  it('initializes the service worker on fetch if it has not yet been initialized', async () => {    // Driver is initially uninitialized.    expect(driver.initialized).toBeNull();    expect(driver['latestHash']).toBeNull();    // Making a request initializes the driver (fetches assets).    expect(await makeRequest(scope, '/foo.txt')).toEqual('this is foo');    expect(driver['latestHash']).toEqual(jasmine.any(String));    server.assertSawRequestFor('/ngsw.json');    server.assertSawRequestFor('/foo.txt');    server.assertSawRequestFor('/bar.txt');    server.assertSawRequestFor('/redirected.txt');    server.assertSawRequestFor('/redirect-target.txt');    // Once initialized, cached resources are served without network requests.    expect(await makeRequest(scope, '/foo.txt')).toEqual('this is foo');    expect(await makeRequest(scope, '/bar.txt')).toEqual('this is bar');    server.assertNoOtherRequests();  });  it('initializes the service worker on message if it has not yet been initialized', async () => {    // Driver is initially uninitialized.    expect(driver.initialized).toBeNull();    expect(driver['latestHash']).toBeNull();    // Pushing a message initializes the driver (fetches assets).    scope.handleMessage({action: 'foo'}, 'someClient');    await new Promise(resolve => setTimeout(resolve));  // Wait for async operations to complete.    expect(driver['latestHash']).toEqual(jasmine.any(String));    server.assertSawRequestFor('/ngsw.json');    server.assertSawRequestFor('/foo.txt');    server.assertSawRequestFor('/bar.txt');    server.assertSawRequestFor('/redirected.txt');    server.assertSawRequestFor('/redirect-target.txt');    // Once initialized, pushed messages are handled without re-initializing.    await scope.handleMessage({action: 'bar'}, 'someClient');    server.assertNoOtherRequests();    // Once initialized, cached resources are served without network requests.    expect(await makeRequest(scope, '/foo.txt')).toEqual('this is foo');    expect(await makeRequest(scope, '/bar.txt')).toEqual('this is bar');    server.assertNoOtherRequests();  });  it('handles non-relative URLs', async () => {    expect(await makeRequest(scope, '/foo.txt')).toEqual('this is foo');    await driver.initialized;    server.clearRequests();    expect(await makeRequest(scope, 'http://localhost/foo.txt')).toEqual('this is foo');    server.assertNoOtherRequests();  });  it('handles actual errors from the browser', async () => {    expect(await makeRequest(scope, '/foo.txt')).toEqual('this is foo');    await driver.initialized;    server.clearRequests();    const [resPromise, done] = scope.handleFetch(new MockRequest('/error.txt'), 'default');    await done;    const res = (await resPromise)!;    expect(res.status).toEqual(504);    expect(res.statusText).toEqual('Gateway Timeout');  });  it('handles redirected responses', async () => {    expect(await makeRequest(scope, '/foo.txt')).toEqual('this is foo');    await driver.initialized;    server.clearRequests();    expect(await makeRequest(scope, '/redirected.txt')).toEqual('this was a redirect');    server.assertNoOtherRequests();  });  it('caches lazy content on-request', async () => {    expect(await makeRequest(scope, '/foo.txt')).toEqual('this is foo');    await driver.initialized;    server.clearRequests();    expect(await makeRequest(scope, '/baz.txt')).toEqual('this is baz');    server.assertSawRequestFor('/baz.txt');    server.assertNoOtherRequests();    expect(await makeRequest(scope, '/baz.txt')).toEqual('this is baz');    server.assertNoOtherRequests();    expect(await makeRequest(scope, '/qux.txt')).toEqual('this is qux');    server.assertSawRequestFor('/qux.txt');    server.assertNoOtherRequests();  });  it('updates to new content when requested', async () => {    expect(await makeRequest(scope, '/foo.txt')).toEqual('this is foo');    await driver.initialized;    const client = scope.clients.getMock('default')!;    expect(client.messages).toEqual([]);    scope.updateServerState(serverUpdate);    expect(await driver.checkForUpdate()).toEqual(true);    serverUpdate.assertSawRequestFor('/ngsw.json');    serverUpdate.assertSawRequestFor('/foo.txt');    serverUpdate.assertSawRequestFor('/redirected.txt');    serverUpdate.assertSawRequestFor('/redirect-target.txt');    serverUpdate.assertNoOtherRequests();    expect(client.messages).toEqual([{  type: 'VERSION_DETECTED',  version: {hash: manifestUpdateHash, appData: {version: 'update'}},},{  type: 'VERSION_READY',  currentVersion: {hash: manifestHash, appData: {version: 'original'}},  latestVersion: {hash: manifestUpdateHash, appData: {version: 'update'}},},    ]);    // Default client is still on the old version of the app.    expect(await makeRequest(scope, '/foo.txt')).toEqual('this is foo');    // Sending a new client id should result in the updated version being returned.    expect(await makeRequest(scope, '/foo.txt', 'new')).toEqual('this is foo v2');    // Of course, the old version should still work.    expect(await makeRequest(scope, '/foo.txt')).toEqual('this is foo');    expect(await makeRequest(scope, '/bar.txt')).toEqual('this is bar');    serverUpdate.assertNoOtherRequests();  });  it('detec n even if only `manifest.tip` is different', async () => {    expect(await makeRequest(scope, 'xtw')).toEqual('this is foo await driver.initialized;    scope.updateServerState(serverUpdate);   t(await driver.checkForUpdate()).toEqual(true);    expect(await makeRequese, '/foo.txt', 'newerClient')).toEqual('this is foo v2');    scope.updateServerState(serverRollback);    expect(await driver.checkForUpdate()).toEqual(true);    expect(await makeRequest(scope, '/foo.txt', 'newestClient')).toEqual('this is foo');  });  it('updates a specific client to new content on request', async () => {    expect(await makeRequest(scope, '/foo.txt')).toEqual('this is foo');    await driver.initialized;    const client = scope.clients.getMock('default')!;    expect(client.messages).toEqual([]);    scope.updateServerState(serverUpdate);    expect(await driver.checkForUpdate()).toEqual(true);    serverUpdate.clearRequests();    await driver.updateClient(client as any as Client);    expect(client.messages).toEqual([{type: 'VERSION_DETECTED', version: {hash: manifestUpdateHash, appData: {version: 'update'}}},{  type: 'VERSION_READY',  currentVersion: {hash: manifestHash, appData: {version: 'original'}},  latestVersion: {hash: manifestUpdateHash, appData: {version: 'update'}},},{  type: 'UPDATE_ACTIVATED',  previous: {hash: manifestHash, appData: {version: 'original'}},  current: {hash: manifestUpdateHash, appData: {version: 'update'}},}    ]);    expect(await makeRequest(scope, '/foo.txt')).toEqual('this is foo v2');  });  it('handles empty client ID', async () => {    // Initialize the SW.    expect(await makeNavigationRequest(scope, '/foo/file1', '')).toEqual('this is foo');    await driver.initialized;    // Update to a new version.    scope.updateServerState(serverUpdate);    expect(await driver.checkForUpdate()).toEqual(true);    // Correctly handle navigation requests, even ientId` is null/empty.    expect(await makeNavigationRequest(scope, '/foo/file1', '')).toEqual(iv2');  });  it('checks fates on restart', async () => {    expect(await makeRequest(scope, '/fo)).toEqual('this is foo');    await driver.initialized;    scope = new SwTnedwithCacheState(scope.cachesnal.dehydrate()) .withServerState(serverUpdate) .build();    drivew Driver(scope, scope, new CacheDatabase(scope));    expect(await muest(scope, '/foo.txt')).toEqual('this is foo');    await driver.initialized;    serverUpdate.assertNoOtherRequests();    scope.advance(12000);    await driver.idle.empty;    serverUpdate.assertSawRequestFor('/ngsw.json');    serverUpdate.assertSawRequestFor('/foo.txt');    serverUpdate.assertSawRequestFor('/redirected.txt');    serverUpdate.assertSawRequestFor('/redirect-target.txt');    serverUpdate.assertNoOtherRequests();  });  it('checks for updates on navigation', async () => {    expect(await makeRequest(scope, '/foo.txt')).toEqual('this is foo');    await driver.initialized;    server.clearRequests();    expect(await makeNavigationRequest(scope, '/foo.txt')).toEqual('this is foo');    scope.advance(12000);    await driver.idle.empty;    server.assertSawRequestFor('/ngsw.json');  });  it('does not make concurrent checks for updates on navigation', async () => {    expect(await makeRequest(scope, '/foo.txt')).toEqual('this is foo');    await driver.initialized;    server.clearRequests();    expect(await makeNavigationRequest(scope, '/foo.txt')).toEqual('this is foo');    expect(await makeNavigationRequest(scope, '/foo.txt')).toEqual('this is foo');    scope.advance(12000);    await driver.idle.empty;    server.assertSawRequestFor('/ngsw.json');    server.assertNoOtherRequests();  });  it('preserves multiple client assignments across restarts', async () => {    expect(await makeRequest(scope, '/foo.txt')).toEqual('this is foo');    await driver.initialized;    scope.updateServerState(serverUpdate);    expect(await driver.checkForUpdate()).toEqual(true);    expect(await makeRequest(scope, '/foo.txt', 'new')).toEqual('this is foo v2');    serverUpdate.clearRequests();    scope = new SwTestHarnessBuilder() .withCacheState(scope.caches.original.dehydrate()) .withServerState(serverUpdate) .build();    driver = new Driver(scope, scope, new CacheDatabase(scope));    expect(await makeRequest(scope, '/foo.txt')).toEqual('this is foo');    expect(await makeRequest(scope, '/foo.txt', 'new')).toEqual('this is foo v2');    serverUpdate.assertNoOtherRequests();  });  it('updates when refreshed', async () => {    expect(await makeRequest(scope, '/foo.txt')).toEqual('this is foo');    await driver.initialized;    const client = scope.clients.getMock('default')!;    scope.updateServerState(serverUpdate);    expect(await driver.checkForUpdate()).toEqual(true);    serverUpdate.clearRequests();    expect(await makeNavigationRequest(scope, '/file1')).toEqual('this is foo v2');    expect(client.messages).toEqual([{  type: 'VERSION_DETECTED',  version: {hash: manifestUpdateHash, appData: {version: 'update'}},},{  type: 'VERSION_READY',  currentVersion: {hash: manifestHash, appData: {version: 'original'}},  latestVersion: {hash: manifestUpdateHash, appData: {version: 'update'}},},{  type: 'UPDATE_ACTIVATED',  previous: {hash: manifestHash, appData: {version: 'original'}},  current: {hash: manifestUpdateHash, appData: {version: 'update'}},}    ]);    serverUpdate.assertNoOtherRequests();  });  it('sends a notification message after finding the same version on the server and installed',     async () => { expect(await makeRequest(scope, '/foo.txt')).toEqual('this is foo'); await driver.initialized; const client = scope.clients.getMock('default')!; expect(await driver.checkForUpdate()).toEqual(false); serverUpdate.clearRequests(); expect(client.messages).toEqual([O_NEW_VERSION_DETECTED',version: {hash: manifestHash, appData: {version: 'original'}},}vte.assertNoOtherRequests(););  it('cleans up properly when manually requested', async () => {  ct quest(scope, '/foo.txt')ual('this is foo');    await driver.initialized;    scope.updateServerServerUpdate);    expect(await driver.checkForUpdate()).toEqual(true);    spdeests();    expect(await makst(scope, '/foo.txt', 'new')).toEqual('this is foo v2');    // Dehe default client.    scope.clients.remove('default');    // After the old version should no longer be cached.    await driver.cleanupCaches();    expect(await makeRequest(scope, '/foo.txt')).toEqual('this is foo v2');    serverUpdate.NoOtherRequests();  });  it('cleans up properly on restart', async ()   expect(await makeRequese, '/foo.txt')).toEqual('this is foo');    await dinitialized;    scope = new SwTestHarnessBuilder() .wieState(scope.caches.original.dte()) .withServerState(serverUpdate) .build();    driver = new Driver(scope, scope, new CacheDatabase(scope));    expect(aakeRequest(scope, '/foo.txt')).toEqual('this is foo');    await driver.initialized;    serverUpdate.assertNoOtherRequests();    let keys = await scope.caches.keys();    let hasOriginalCaches = keys.some(name => name.startsWith(`${manifestHash}:`));    expect(hasOriginalCaches).toEqual(true);    scope.clients.remove('default');    scope.advance(12000);    await driver.idle.empty;    serverUpdate.clearRequests();    driver = new Driver(scope, scope, new CacheDatabase(scope));    expect(await makeRequest(scope, '/foo.txt')).toEqual('this is foo v2');    keys = await scope.caches.keys();    hasOriginalCaches = keys.some(name => name.startsWith(`${manifestHash}:`));    expect(hasOriginalCaches).toEqual(false);  });  it('cleans up properly when failing to load stored state', async () => {    // Initialize the SW and cache the original app-version.    expect(await makeRequest(scope, '/foo.txt')).toBe('this is foo');    await driver.initialized;    // Update and cache the updated app-version.    scope.updateServerState(serverUpdate);    expect(await driver.checkForUpdate()).toBeTrue();    expect(await makeRequest(scope, '/foo.txt', 'newClient')).toBe('this is foo v2');    // Verify both app-versions are stored in the cache.    let cacheNames = await scope.caches.keys();    let hasOriginalVersion = cacheNames.some(name => name.startsWith(`${manifestHash}:`));    let hasUpdatedVersion = cacheNames.some(name => name.startsWith(`${manifestUpdateHash}:`));    expect(hasOriginalVersion).withContext('Has caches for original version').toBeTrue();    expect(hasUpdatedVersion).withContext('Has caches for updated version').toBeTrue();    // Simulate failing to load the stored state (and thus starting from an empty state).    scope.caches.delete('db:control');    driver = new Driver(scope, scope, new CacheDatabase(scope));    expect(await makeRequest(scope, '/foo.txt')).toBe('this is foo v2');    await driver.initialized;    // Verify that the caches for the obsolete original version are cleaned up.    // await driver.cleanupCaches();    scope.advance(6000);    await driver.idle.empty;    cacheNames = await scope.caches.keys();    hasOriginalVersion = cacheNames.some(name => name.startsWith(`${manifestHash}:`));    hasUpdatedVersion = cacheNames.some(name => name.startsWith(`${manifestUpdateHash}:`));    expect(hasOriginalVersion).withContext('Has caches for original version').toBeFalse();    expect(hasUpdatedVersion).withContext('Has caches for updated version').toBeTrue();  });  it('shows notifications for push notifications', async () => {    expect(await makeRequest(scope, '/foo.txt')).toEqual('this is foo');    await driver.initialized;    await scope.handlePush({notification: {  title: 'This is a test',  body: 'Test body',}    });    expect(scope.notifications).toEqual([{title: 'This is a test',options: {title: 'This is a test', body: 'Test body'},    }]);    expect(scope.clients.getMock('default')!.messages).toEqual([{type: 'PUSH',data: {  notification: {title: 'This is a test',body: 'Test body',  },},    }]);  });  describe('notification click events', () => {    it('broadcasts notification click events with action', async () => {expect(await makeRequest(scope, '/foo.txt')).toEqual('this is foo');await driver.initialized;await scope.handleClick({title: 'This is a test with action', body: 'Test body with action'}, 'button');const message = scope.clients.getMock('default')!.messages[0];expect(message.type).toEqual('NOTIFICATION_CLICK');expect(message.data.action).toEqual('button');expect(message.data.notification.title).toEqual('This is a test with action');expect(message.data.notification.body).toEqual('Test body with action');    });    it('broadcasts notification click events without action', async () => {expect(makeRequest(scofoo.txt')).toEqual('this i);await driver.initi;await scope.handleClick({  title: 'This is a testut action',  body: 'Testwithout action',});const message = scope.clients.getMock('default')!.messages[0];expect(message.type).toEqual('NOTIFICATION_CLIxpect(messageaction)'');expect(message.data.notification.title).toEqual('This ist w action');expect(message.data.notification.body).toEqual('Test body without action');    });    describe('Client interactions', () => ibe('`openWindow` operation', () => {  it('opens a new client windowl', async () => {expect(aakeRequest(scope, '/foo.txt')).toEqual('this is foo');spyOn(scope.clients, 'openWindow');const url = 'foit driver.initialized;await scope.handleClick(   { title: 'Thi test with url', body: 'Test body with url', data: ActionClick: {     foo: {operation: 'openWindol},   }, },   },   'foo');expect(scope.clients.openWindow)   .toHaveBeenCalled${scope.registration.scope}${url}`);  });  it('opens a new client window with `/` when no `url`', async () => {expect(await makeRequest(scope, '/foo.txt')ual('this is foo');spyOn(scope.clients, 'openWindow');await driver.iized;await scope.handleCl { title: 'This is a testut url', body: 'Test body without url', d   onActionClick: {     foo: {opera'opow'},   }, },   },   'foo');expect(scope.clients.openWindow).teenCalledWith(`${scope.registration.scope}`);  });}ribe('`focusLastFocusedOrOpen` operat() => {  it('focuses last client keeping previous url', async () => {expect(awaitequest(scope, '/foo.txt')).toEqual('this is foo');scope.clients.add('fooBar', 'http://localhost/unique', 'window');const mock = scope.clients.getMock('fooBar') as MockClient;const url = 'foo';expect(mockClient.url).toBe('http://localhost/unique');expect(mockClient.focused).toBeFalse();await driver.initialized;await scope.handleClick(   { title: 'This is a test with operation focusLastFocusedOrOpen', body: 'Test body with operation focusLastFocusedOrOpen', data: {   onActionClick: {     foo: {operation: 'focusLastFocusedOrOpen', url},   }, },   },   'foo');expect(mockClient.url).toBe('http://localhost/unique');expect(mockClient.focusedTrue(;  it('falls back to openWindow at url when no last client to focus', async () => {expect(await makeRequest(scope, '/foo.txt')).toEqual('this is foo');spyOn(scope.clients, 'openWindow');spyOn(scope.clients, 'matchAll').and.returnValue(Promise.resolve([]));const url = 'foo';await driver.initialized;await scope.handleClick(   { title: 'This is a test with operation focusLastFocusedOrOpen', body: 'Test body with operation focusLastFocusedOrOpen', data: {   onActio: {  : {ion: 'focusLastFocusedOrOpen', url},   }, },   },   'fxpect(scope.clients.openWindow)   .toHaveBeenCalledWith(`${scope.registration.scope}${url}`);  });  it('falls back to openWindow at `/` when no last client and no `url`', async () => {expect(await makeRequest(scope, '/foo.txt')).toEqual('this is foo');spyOn(scope.clients, 'openWindow');spyOn(scope.clients, 'matchAll').and.returnValue(Promise.resolve([]));await driver.initialized;await scope.handleClick(   { title: 'This is a test with operation focusLastFocusedOrOpen', body: 'Test body with operation focusLastFocusedOrOpen', data: {   onActionClick: {     foo: {operation: 'focusLastFocusedOrOpen'},   }, },   },   'foo');expect(scope.clients.openWindow).toHaveBeenCalledWith(`${scope.registration.scope}`);  });});describe('`navigateLastFocOpen`tion', () => {  it('navigates last client to `url`', async () => {expect(await makeRequest(scope, '/foo.txt')).toBe('this is foo');scope.clients.add('fooBar', 'http://localhost/unique', 'window');const mockClient = scope.clients.getMock('fooBar') as MockWindowClient;const url = 'foo';expect(mockClient.url).toBe('http://localhost/unique');expect(mockClient.focused).toBeFalse();await driver.initialized;await scope.handleClick(   { title: 'This is a test with operation navigateLastFocusedOrOpen', body: 'Test body with operation navigateLastFocusedOrOpen', data: {   onActionClick: {     foo: {operation: 'navigateLastFocusedOrOpen', url},     },o');expect(mockClient.url).toBe(`${scope.registration.scope}${url}`);expect(mockClient.focused).toBeTrue();  });  it('navigates last client to `/` if no `url`', async () => {expect(await makeRequest(scope, '/foo.txt')).toBe('this is foo');scope.clients.add('fooBar', 'http://localhost/unique', 'window');const mockClient = scope.clients.getMock('fooBar') as MockWindowClient;expect(mockClient.url).toBe('http://localhost/unique');expect(mockClient.focused).toBeFalse();await driver.initialized;await scope.handleClick(   { title: 'This is a test with operation navigateLastFocusedOrOpen', body: 'Test body with opernavigtForOpen', data: {   onActionClick: {     foo: {operation: 'teLastFocusedOrOpen'},   }, },   },   'foo');expect(mockClient.url).toBe(scope.registration.scope);expect(mockClient.focused).toBeTrue();  });  it('falls back to openWindow at url when no last client to focus', async () => {expect(await makeRequest(scope, '/foo.txt')).toEqual('this is foo');spyOn(scope.clients, 'openWindow');spyOn(scope.clients, 'matchAll').and.returnValue(Promise.resolve([]));const url = 'foo';await driver.initialized;await scope.handleClick(   { title: 'This is a test with operation navigateLastFocusedOrOpen', body: 'Test body with operation navigateLastFocusedOrOpen', data: {   onActionClick: {     foo: {operation: 'navigateLastFocusedOrOpen', url},   }, },   },   'foo');expect(scope.clients.openWindow)   .toHaveBeenCalledW{scopstration.scope}${url}`);  });  it('falls back to openWindow at `/` when no last client and no `url`', async () => {expect(await makeRequest(scope, '/foo.txt')).toEqual('this is foo');spyOn(scope.clients, 'openWindow');spyOn(scope.clients, 'matchAll').and.returnValue(Promise.resolve([]));await driver.initialized;await scope.handleClick(   { title: 'This is a test with operation navigateLastFocusedOrOpen', body: 'Test body with operation navigateLastFocusedOrOpen', data: {   onActionClick: {     foo: {operation: 'navigateLastFocusedOrOpen'},   }, },   },   'foo');expect(scope.clients.openWindow).toHaveBeenCalledWith(`${scope.registration.scope}`);  });});describe('`sendRequest` operation', () => {  it('sends a GET requeste spe URL', async () => {// Initialize the SW.expect(await makeRequest(scope, '/foo.txt')).toBe('this is foo');await driver.initialized;server.clearRequests();// Trigger a `notificationlick` event.const url = '/some/url';await scope.handleClick(   { title: 'Test notification', body: 'This is a test notifiction.', data: {   onActionClick: {     foo: {operation: 'sendRequest', url},   }, },   },   'foo');// Expect request to the server.server.assertSawRequestFor('/some/url');  });  it('falls back to sending a request to `/` when no URL is specified', async () => {// Initialize the SW.expect(await makeRequest(scope, '/foo.txt')).toBe('this is foo');awaver.iized;server.clearRequests();// Trigger a `notificationlick` event.await scope.handleClick(   { title: 'Test notification', body: 'This is a test notifiction.', data: {   onActionClick: {     bar: {operation: 'sendRequest'},   }, },   },   'bar');// Expect request to the server.server.assertSawRequestFor('/');  });});describe('No matching onActionClick field', () => {  it('no client interaction', async () => {expect(await makeRequest(scope, '/foo.txt')).toEqual('this is foo');spyOn(scope.clients, 'openWindow');await driver.initialized;await scope.handleClick(   { title: 'This is a test without onActionClick field', boest bthoctionClick field', data: {   onActionClick: fooz: {operation: 'focusLastFocusedOrOpen', url: 'fooz'},   }, },   },   'foo');expect(scope.clients.openWindow).not.toHaveBeenCalled();  });});describe('no action', () => {  it('uses onActionClick default when no specific action is clicked', async () => {expect(await makeRequest(scope, '/foo.txt')).toEqual('this is foo');spyOn(scope.clients, 'openWindow');const url = 'fooz';await driver.initialized;await scope.handleClick(   { title: 'This is a test without action', body: 'Test body without action', data: { tionC{     default: {operation: 'openWindow', url},   }, },   },   '');expect(scope.clients.openWindow)   .toHaveBeenCalledWith(`${scope.registration.scope}${url}`);  });  describe('no onActionClick default', () => {it('has no client interaction', async () => { expect(await makeRequest(scope, '/foo.txt')).toEqual('this is foo'); spyOn(scope.clients, 'openWindow'); await driver.initialized; await scope.handleClick( {title: 'This is a test without action', body: 'Test body without action'}); expect(scopnts.odowtoHaveBeenCalled();});  });});describe('no onActionfield', () => {  it('has no client interaction', async () => {expect(await makeRequest(scope, '/foo.txt')).toEqual('this is foo');spyOn(scope.clients, 'openWindow');await driver.initialized;await scope.handleClick(   {title: 'This is a test without action', body: 'Test body without action', data: {}});await scope.handleClick(   {title: 'This is a test with an action', body: 'Test body with an action', data: {}},   'someAction');expect(scope.clients.openWindow).noveBeed()});describe('URL resolution', {  it('should resolve relative to service worker scope', async () => {(scope.registration.scope as string) = 'http://localhost/foo/bar/';expect(await makeRequest(scope, '/foo.txt')).toEqual('this is foo');spyOn(scope.clients, 'openWindow');await driver.initialized;await scope.handleClick(   { title: 'This is a test with a relative url', body: 'Test body with a relative url', data: {   onActionClick: {     foo: {operation: 'openWindow', url: 'baz/qux'},   }, },   },   'foo');expect(scope.clients.openWindow).toHavalledhttp://localhost/foo/bar/baz/qux');  });  it('should resolve with an absolute path', async () => {(scope.registration.scope as string) = 'http://localhost/foo/bar/';expect(await makeRequest(scope, '/foo.txt')).toEqual('this is foo');spyOn(scope.clients, 'openWindow');await driver.initialized;await scope.handleClick(   { title: 'This is a test with an absolute path url', body: 'Testwith oluh url', data: {   onActionClick: {     fooration: 'openWindow', url: '/baz/qux'},   }, },   },   'foo');expect(scope.clients.openWindow).toHaveBeenCalledWith('http://localhost/baz/qux');  });  it('should resolve other origins', async () => {(scope.registration.scope as string) = 'http://localhost/foo/bar/';expect(await makeRequest(scope, '/foo.txt')).toEqual('this is foo');spyOn(scope.clients, 'openWindow');await driver.initialized;await scope.handleClick(   { title: 'This is a test with external origin', bodyt bod ex origin', data: {   onActionClick: foo: {operation: 'openWindow', url: 'http://other.host/baz/qux'},   }, },   },   'foo');expect(scope.clients.openWindow).toHaveBeenCalledWith('http://other.host/baz/qux');  });});    });  });  it('prefetches updates to lazy cache when set', async () => {    expect(await makeRequest(scope, '/foo.txt')).toEqual('this is foo');    await driver.initialized;    // Fetch some files from the `lazy_prefetch` asset group.    expect(await makeRequest(scope, '/quux.txt')).toEqual('this is quux');    expect(await makeRequest(scope, '/lazy/unchanged1.txt')).toEqual('this isnged     // Install update.    scope.updateServerState(serverUpdate);    expect(await driver.checkForUpdate()).toBe(true);    // Previously requested and changed: Fetch from network.    serverUpdate.assertSawRequestFor('/quux.txt');    // Never requested and changed: Don't fetch.    serverUpdate.assertNoRequestFor('/quuux.txt');    // Previously requested and unchanged: Fetch from cache.    serverUpdate.assertNoRequestFor('/lazy/unchanged1.txt');    // Never requested and unchanged: Don't fetch.    serverUpdate.assertNoRequestFor('/lazy/unchanged2.txt');    serate.cquests();    // Update client.    await driver.updateClient(await scope.clients.get('default'));    // Already cached.    expect(await makeRequest(scope, '/quux.txt')).toBe('this is quux v2');    serverUpdate.assertNoOtherRequests();    // Not cached: Fetch from network.    expect(await makeRequest(scope, '/quuux.txt')).toBe('this is quuux v2');    serverUpdate.assertSawRequestFor('/quuux.txt');    // Already cached (copied from old cache).    expect(await makeRequest(scope, '/lazy/unchanged1.txt')).toBe('this is unchanged (1)');    serverUpdate.assertNoOtuests // Not cached: Fetch from network.    expect(await makeRequest(scope, '/lazy/unchanged2.txt')).toBe('this is unchanged (2)');    serverUpdate.assertSawRequestFor('/lazy/unchanged2.txt');    serverUpdate.assertNoOtherRequests();  });  it('bypasses the ServiceWorker on `ngsw-bypass` parameter', async () => {    // NOTE:    // Requests that bypass the SW are not handled at all in the mock implementation of `scope`,    // therefore no requests reach the server.    await makeRequest(scope, '/some/url', undefined, {headers: {'ngsw-bypass': 'true'}});    server.assertNoRequestFor('/some/url');    await makeRequest(scope, '/some/url', undefined, {headers: {'ngsw-bypass': 'anything'}});    server.assertNoRequestFor('/some/url');    await makeRequest(scope, '/some/url', undefined, {headers: {'ngsw-bypass': null!}});    server.assertNoRequestFor('/some/url');    await makeRequest(scope, '/some/url', undefined, {headers: {'NGSW-bypass': 'upperCASE'}});    server.assertNoRequestFor('/some/url');    await makeRequest(scope, '/some/url', undefined, {headers: {'ngsw-bypasss': 'anything'}});    server.assertSawRequestFor('/some/url');    server.clearRequests();    await makeRequest(scope, '/some/url?ngsw-bypass=true');    server.assertNoRequestFor('/some/url');    await makeRequest(scope, '/some/url?ngsw-bypasss=true');    server.assertSawRequestFor('/some/url');    server.clearRequests();    await makeRequest(scope, '/some/url?ngsw-bypaSS=something');    server.assertNoRequestFor('/some/url');    await makeRequest(scope, '/some/url?testparam=test&ngsw-byPASS=anything');    server.assertNoRequestFor('/some/url');    await makeRequest(scope, '/some/url?testparam=test&angsw-byPASS=anything');    server.assertSawRequestFor('/some/url');    server.clearRequests();    await makeRequest(scope, '/some/url&ngsw-bypass=true.txt?testparam=test&angsw-byPASS=anything');    server.assertSawRequestFor('/some/url&ngsw-bypass=true.txt');    server.clearRequests();    await makeRequest(scope, '/some/url&ngsw-bypass=true.txt');    server.assertSawRequestFor('/some/url&ngsw-bypass=true.txt');    server.clearRequests();    await makeRequest(  scope,  '/some/url&ngsw-bypass=true.txt?testparam=test&ngSW-BYPASS=SOMETHING&testparam2=test');    server.assertNoRequestFor('/some/url&ngsw-bypass=true.txt');    await makeRequest(scope, '/some/url?testparam=test&ngsw-bypass');    server.assertNoRequestFor('/some/url');    await makeRequest(scope, '/some/url?testparam=test&ngsw-bypass&testparam2');    server.assertNoRequestFor('/some/url');    await makeRequest(scope, '/some/url?ngsw-bypass&testparam2');    server.assertNoRequestFor('/some/url');    await makeRequest(scope, '/some/url?ngsw-bypass=&foo=ngsw-bypass');    server.assertNoRequestFor('/some/url');    await makeRequest(scope, '/some/url?ngsw-byapass&testparam2');    server.assertSawRequestFor('/some/url');  });  it('unregisters when manifest 404s', async () => {    expect(await makeRequest(scope, '/foo.txt')).toEqual('this is foo');    await driver.initialized;    scope.updateServerState(server404);    expect(await driver.checkForUpdate()).toEqual(false);    expect(scope.unregistered).toEqual(true);    expect(await scope.caches.keys()).toEqual([]);  });  it('does not unregister or change state when offline (i.e. manifest 504s)', async () => {    expect(await makeRequest(scope, '/foo.txt')).toEqual('this is foo');    await driver.initialized;    server.online = false;    expect(await driver.checkForUpdate()).toEqual(false);    expect(driver.state).toEqual(DriverReadyState.NORMAL);    expect(scope.unregistered).toBeFalsy();    expect(await scope.caches.keys()).not.toEqual([]);  });  it('does not unregister or change state when stode is 5rvice unavailable)',     async () => { expect(await makeRequest(scope, '/foo.txt')).toEqual('this is foo'); await driver.initialized; spyOn(server, 'fetch').and.callFake(async (req: Request) => new MockResponse(null, {status: 503,statusText: 'Service Unavailable'  })); expect(await driver.checkForUpdate()).toEqual(false); expect(driver.state).toEqual(DriverReadyState.NORMAL); expect(scope.unregistered).toBeFalsy(); expect(await scope.caches.keys()).not.toEqual([]);     });  describe('serving ngsw/state', () => {    it('should show debug info (when in NORMAL state)', async () => {expect(await makeRequest(scope, '/ngsw/state')).toMatch(/^NGSW Debug Info:\n\nDriver version: .+\nDriver state: NORMAL/);    });    it('should show debug info (when in EXISTING_CLIENTS_ONLY state)', async () => {driver.state = DriverReadyState.EXISTING_CLIENTS_ONLY;expect(await makeRequest(scope, '/ngsw/state')).toMatch(/^NGSW Debug Info:\n\nDriver version: .+\nDriver state: EXISTING_CLIENTS_ONLY/);    });    it('should show debug info (when in SAFE_MODE state)', async () => {driver.state = DriverReadyState.SAFE_MODE;expect(await makeRequest(scope, '/ngsw/state')).toMatch(/^NGSW Debug Info:\n\nDriver version: .+\nDriver state: SAFE_MODE/);    });    it('should show debug info when the scope is not root', async () => {const newScope =new SwTestHarnessBuilder('http://localhost/foo/bar/').withServerState(server).build();new Driver(newScope, newScope, new CacheDatabase(newScope));expect(await makeRequest(newScope, '/foo/bar/ngsw/state')).toMatch(/^NGSW Debug Info:\n\nDriver version: .+\nDriver state: NORMAL/);    });  escribe('cache naming', () => {    let uid: number;    // Helpers    cacheKeysFor = (baseHref: , manifestHash: string) =>  [`ngsw:${baseHref}:db:control`,`ngsw:${baseHref}:tHash}:assets:eager:cache`,`ngsw:${baseHref}:db:${mani:asseer:meta`,`ngsw:${baseHref}:${manifestHash}:as:cache`,`{baseHref}:db:${manifestHash}:assets:l,`ngsw:${baseHrefata:api:cache`,`ngsw:${baseHref}ta:api:lgsw:${baseHref}:db:42:dge`,    ];    const createManifestWith= (baseHref: string, distDir: MockFileSystem): Manifest => ({configVersion: 1,timestamp: 1234567890123,indebaseHref}foo.txt`,assetGroups: [  {name: 'eager',installMode: 'prefetch',updateMode: 'prefetch',urls: [ `${baseHref}foo.txt`, `${baseHref}bar.txt`,],patterns: [],cacheQueryOptions: {ignoreVary: true},  },  {name:',installMode: 'lazy',updateMode: 'lazy',urls: [ `${ba}baz.txt`, `${baseHref}qux.txt`,],patterns: [],cacheQueryOptions: {ignoreVary: true},  },],dataGroups: [  {name: 'api',version: 42,maxAge: 3600000,maxSize: 100,strategy: 'freshness',patterns: [ '/api/.*',],cacheQuerns: {ignoreVary: true},  },],navigationUrlcessNavigationUrls(baseHref),navigationRequestStrategy: 'performance',hashTable: tmpHashTableForFs(distDir, {}, baseHref),    });    const getClientAssignments = async (sw: SwTestHarness, baseHref: stringconst cache =await sw.caches.original.open(`ngsw:${baseHref}:db:control`) as unknown as MockCache;consdrated = cache.dehydrate();return JSON.parse(dehydrated['/asnts'].body!) as any;    };    const initializeSwFor = async (baseHref: string, initialCacheState = '{}') => {const newDistDir = dist.extend().addFile('/foo.txt', `this is foo v${++uid}`).build();const newManifest = createManifestWithBaseHref(baseHref, newDistDir);const newManifes= sha1(JSON.stringify(newManifest));const serverState = new MockServerStateBuilder().withRootDirectory(baseHref).withStaticFiles(newDistDir).withManifest(newManifest).build();const newScope = new SwTestHarnessBuilder(`http://localhost${baseHref}`) .withCacheState(initialCacheState) .withServerState(serverState) .build();const newDriver = new Driver(newScope, newScope, new CacheDatabase(newScope));awaitequest(newScope, ifest.index, baseHref.rep\//g, '_'));await newDriver.lized;return [pe, newManifestHash] as [SwTestHarness, string];    };    beforeEach(() => {uid = 0;    });    it('includes the SW scope in all cache names', async () => {// SW with sc`.coootScope, rootManifestHash] = await initializeSwFor('/');const cacheNames = await rootScope.caches.original.keys();expect(cacheNames).toEqual(cacheKeysFor('/',anifh)ct(cacheNames(name => name.includes('/'))).toBe(true);// SW with scope `/foo/`.const [fooScope, fooManifestHash] = await initializeSwFor('/foo/');const feNamwaScope.caches.original.keys();expect(fooCacheNamequal(cacheKeysFor('/foo/', fooManifestHaspect(fooCacheNames.every(name => name.includes('/foo/'))).toBe(true);    });    it('does not affect caches from other scopes', async () => {ate SW with scope `/foo/`.const [fooScope, fooManifestHash] = await initializeSwFor('/foo/');constsignments = await getClientAssignmentcope, '/foo/');expect(fooAssignments).toEqual({_foo_: fooManifestHash});// Add new SW with different scope.const [barScope, barManifestHash] =await lizeSwFor('/bar/', await fooScope.caches.original.dehydrate());const barCacheNames = aarScope.caches.original.keys();const barAssignments = await getClientments(barScope, '/bar/');expect(barAssignments).toEqual({_barManifestHash});expect(barCacheNames).toEqual([  ...cacheKeysFor('/foo/', fooManifestHash),  ...cacheKeysFor('/bar/', barManifestHash),])e caches for `/foo/` should be intact.const fooAssignments2 = await getClientAssignments(barScope, '/foo/');expect(fooAssignments2).toEqual({_foo_:nifestHash});    });    it('updates existing caches for same scope', async ()  Create SW with scope `/foo/`.const [fooScope, fooManifestHash] = await initiwFor('/foo/');await makeRequoScope, '/foo/foo.txt', '_bar_');const fooAssignments = await getClientAssignments(fooScopoo/');expect(fooAssignments).toEqual({  _foo_: fooManifestHash,  _bar_: fooManish,});expect(await maest(fooScope, '/foo/baz.txt', '_foo_')).toBe('this is baz');expect makeRequest(fooScope, '/foo/baz.txt', '_bar_')).toBe('thbaz');// Add new SW with same scope.const [fooScope2, fooManifes] =await initializeSwFor('/foo/', await fooScope.caches.originalrate());// Update client ` but not client `_bar_`.await fooScope2.handleMessage({action: 'CHR_UPDATES'}, '_foo_');await fooScope2.handleMessage({action:VATE_UPDATE'}, '_foo_');const fooAssignments2 = await getClientAssignmooScope2, '/foo/');expect(fooAssignments2).toEqual({  _foo_: fooManifestHash2,  _bar_: fooManifestHash,});// Everything should still work as ed.expect(await makeRequest(fooSc'/foo/foo.txt', '_foo_')).toBe('this is foo v2');expect(await makeR(fooScope2, '/foo/foo.txt', '_bar_')).toBe('this is foo v1');expect(aakeRequest(fooScope2, '/foo/baz.txt', '_foo_')).toBe('thiaz');expect(await makeRequest(fooSc'/foo/baz.txt', '_bar_')).toBe('this is baz');    });  });  describe('request metadata', () => {    it('passesrs through to the server', async () => {// Request a lazy-casset (so that it is fetched from the network) and provide headers.conInit = {  headers: {SomeHeader: 'SomeValue'},};expect(awaeRequest(scope, '/baz.txt', und, reqInit)).toBe('this is baz');// Verify th headers were passed through to the network.[ba= server.getRequestsFor('/baz.txt');expect(.headers.get('SomeHeader')).toBe('SomeValue');    });    it('does not on-allowed metadata through to the server', async () => {// Request a lazy-cached asset (so that it is fetched from the networkprovide some// metadata.const re= {  credentials: 'include',  mode: 'same-origin',  unknownOption: WN',};expect(await makeRequest(scope, '/baz.txt', und, reqInit)).toBe('this is baz');// Verify that the metadata were not  through to the network.const [b = server.getRequestsFor(txt');expect(bazReq.crede).tame-origin');  // The default value.expect(bazReq.mode).toBe('cors'); // The defalue.expect((bazReq as any).unknownOption).toBeUndefined();    });    describe('forect requests', () => {it('pasaders through to the server', async () => {  // Request a redirected, lazy-cached asset (so that it is fetched fe network) and  // provide headers.  const reqInheaders: {SomeHeader: 'SomeValue'},  };  expect(await makeRequest(scopazy/redirected.txt', undefined, reqInit)) .toBe('this was a redirect;  // Verify that the headers were passed through to the network.  consirectReq] = server.getRequestsFory/redirect-target.txt');  (redirectReq.headers.get(eadtoBe('SomeValue');});it('does not pass non-a metadata through to the server', async () => {  // Request a redirected, lazy-cached (so that it is fetched from the network) and  // provide some metadata.  const reqIncredentials: 'include',mode: 'same-origin',unknownOption: 'UNKNOWN',  };  expect(aakeRequest(scope, '/lazy/redirected.txt', undefined, reqInit)) .toBe('this was a redirect too');  // Verify that the metadata were not passed through to the network.  const [redirectReq] = sertRequestsFor('/lazy/redirect-target.txt');  expect(redirectReq.credentials).toBe('same-origi// The default vaexpect(redirectReq.mode).toBe('cors')helt value.  expect((redirectReq as any).unknownOption).toBeUndefined();});    });  });ribe('unhashed requests', () => {    beforeEach(async () => {eawait makeRequest(scope, '/foo.txt')).toEqual('thiso');await driver.initialized;server.clearRequests();    });    it('are cached appropriately', async () => {expect(await makeRequest(scope, '/unhastxt')).toEqual('this is unhashed');server.assertSawRequestFor('/unhashed/a.txt');expect(makeRequest( '/unhashed/a.txtEqual('this is unhashed')r.assertNoOtherRequest  });    it(`don't error whchrol' is 'no-cache'`, async () => {expect(await makeRequest(scope, '/unhashed/b.txt'))al('this is unhashed b');server.assertSawRequestFor('/unhashed/b.txpect(await makeRequest(scope, '/unhashed/b.txt')).t('this is unhashed b');server.assertNoOtherRequests();    });    it('apaque responses', async () => {expect(await makeRequest, '/unhashed/a.txt', 'default', {  credentials: 'include'})).toEqual('this is unhashed');server.assertSawRFor('/unhashed/a.txt');expect(await makeRequest(scope, 'hed/a.txt')).toEqual('this is unhashed');server.assertNoOtherRequests();    });    it('exccording to Cache-Coneaders', async () => {expect(await makeRequest(scope, shed')).toEqual('this is unhashed');server.clearRequests();// Update the resource on the server.scope.updateServerStrverUpdate);// Move ahead by 15 seconds.scope.advance(15000);expait makeRequest(scope, '/unhashed/a.txt')).toEqual('this is unhashed');servte.assertNoOtherRequests();// Another 6 seconds.scope.advance(6000t didle.empty;await new Promise(resolve => setTimeout(resolve));  // Wait for aperations to complete.serverUpdate.assertSawRequestFor('/unhashed/a.txt');// Now the new n of the resource should bed.expect(await makeRequest(scope, '/unhashed/a.txt')).toEqual('this is unhashed v2');sessererRequests();    });    it('survive serialization', async () => {expect(await makeRequest(scope, '/unhashed/a.txoEqual('this is unhashed');server.clearRequests();const state = scopes.original.dehydrate();scope = new SwTestHarnessBuilder().withCacheState(stithServerState(server).build();driver = new Driver(scope, scope, new CacheDatscope));expect(await makeRequest(scope, '/foo.txt')).toEqual('s foo');await driver.initialized;server.assertNoRequestFor('/ed/a.txt');server.clearRequests();expect(await makeRequest(scope, '/unhashed/a.txtEqual('this is unhashed');server.assertNoOtherRequests();// Advance ock by 6 seconds, triggere idle tasks. If an idle task// was scheduled from the request above, it meansthe metadata was not// properly saved.scope.advance(6000);await driver.idle.empter.assertNoRequestFor('/unhashed/a.txt');    }it('get carried over during updates', async () => {expect(await makeRequest(scopnhashed/a.txt')).toEqual('this is unhashed');server.clearRequests();scope = new SwTestHarnessBuilder()   .wieState(scope.caches.original.dehydrate())   .withServerState(serverUpdate)   .builiver = new Driver(scope, scope, new CacheDatabope));expect(await makeRequest(scope, '/foo.txt')).toEqual('this is foo');await drnitialized;scope.advance(15000);await driver.idle.empty;serverUpdate.assertNoRequestunhashed/a.txt');serverUpdate.clearRequests();expect(await maket(scope, '/unhashed/a.txoEqual('this is unhashed');servee.assertNoOtherRequests();scope.advance(15000) driver.idle.empty;serverUpdate.assertSawRequestFor('/unhashed/a.txt');expect(awkeRequest(scope, '/unhashed/a.txt')).toEqual('this is unhashed v2');serverUpdate.assertNoOtherRequests(});  });  describe('routing', () => {    const navRequest = (url: string, init =>  makeNavigationRequese, url, undefined, init);    beforeEanc () => {expect(await makeRequest(scofoo.txt')).toEqual('this is await driver.initialirver.clearRequests();    });    it('redirects to index on a route-like request', () => {expect(await navRequest('/bazEqual('this is foo');.assertNoOtherReques   });    it('redirects ex on a request to the scope URL', async () => {expect(await navRequest('http://localhost/'))al('this is foo');server.assertNoOtherRequests();     it('does not redirect to index on a non-GET request', () => {expect(await navRequest('/baz', {method: 'POST'})).toBeNull();server.assertSestFor('/baz');expect(await navRequest('/qux', {method: 'PUT'})).toBeNull();server.SawRequestFor('/qux');    });    it('does not redirect to index on a non-navigatquest', async () => {exwait navRequest('/baz', {mode: undefined})).toBe;server.assertSawRequestFor('/baz');    });    it('does not redirect to index on a reques does not accept HTML', async () => {expect(await navRequest', {headers: {}})).toBeNull();server.assertSawRequestFor('/baz');expait navRequest('/qux', {h: {'Accept': 'text/plain'}})).toBeNull();servertSawRequestFor('/qux'});    it('does not redirect to index on a request with an extension', async () pect(await navRequest('/baz.htmoBeNull();server.assertSawRequestFor('/baz.html');// Only considers the last egment when checking for a file extension.expect(await navRequest('/baz.htm)).toBe('this is ferver.assertNoOtherRs();    });    it('does direct to index if the URL contains `__`', async () => {expect(await navRequest('/baz/x__x')).toBeNull();sessertSawRequestFor('/baz/x__x');expect(await navRequest('/baz/x__x/qux')).toBeNuerver.assertSawRequestFaz/x__x/qux');expect(await navRequest('/baz/__')).toBeNull();server.assertSawRequestFor('/baz/__');expect(await navRequest('/baz/__/.toBeNull();server.assertSawRequestFor('/baz/__/qux');    })escribe('(with custom `navigationUrls`)', () => {beforeEach(async () scope.updateServerState(Update);  await drivekForUpdate();  serverUpdearRequests();});it('redirects to index on a reques matches any positive patternnc () => {  expect(await navRequest('/foo/file0')).toBeNull();  serverUpdate.assRequestFor('/foo/file0');  expect(awaRequest('/foo/file1')('this is foo v2');  serate.assertNoOtherRequests();  expect(await navRequesr/file2')).toBe('this is foo v2');  serverUpdate.assertNoOtherRequests();});it('doeredirect to index on a request that matches any negative pattern', async () => {  expect(await navRequest('/ignored/file1')).toBs is not handled by the SW');  serverUpdate.assertSawRequestFor('/ignored/file1')ect(await navRequest('/ignored/dir/file2')).toBe('this is not handlehe SW either');  serverUpssertSawRequestFor('/ignored/dir/file2');  expect(await navRequest('/ignored/directory/file2')).this is foo v2');  serverUpdate.assertNoOtherRequests();'strips URL query before checking `navigationUrls`', async () => {  expect(await navRequest('/foo/file1?query=).toBe('this is foo v2');  serverUpdate.assertNoOtherRequests();  expait navRequest('/ignored/file1?query=/a/b')).toBe('this is not handled by the SW');  serverUpdate.assertSawReor('/ignored/file1');  expect(await navRequest('/ignored/dir/fuery=/a/b')) .toBe('this is not hany the SW either');  serverUpdate.assertSawRequestFor('/ignorefile2');});it('strips registration scope before checking `navigationUrls`', async () => {  expect(await navRequest('httpalhost/ignored/file1')) .toBe('this is not handled by the SW');erUpdate.assertSawRequestFor('/ignored/file1');});    });  });  describe('with relative base href', () => {    const createManifestlativeBaseHref = (distDir: MockFileSystem): Manifest => ({cersion: 1,timestamp: 1234567890123, './index.html',assetGroups: [  {name: 'eager',installMode: 'prefetch',updateModefetch',urls: [ './index.html', './main.js', './styles.css',],patterns: [ '/unhashed/.*',],cacheQueryOptions: {ignoreVary: t },  {name: 'lazy',installMode: 'lazy',updateModefetch',urls: [ './changed/chunk-1.js', 'ged/chunk-2.js', './unchanged/chunk-3.js', './unchanged/chunk-4.js',],patte '/lazy/unhashed/.*',],cacheQueryOptions: {ignoreVary: true}, vigationUrls: processNavigationUrls('./'),navigationRequestStrategy: 'performance',hashTable: tmpHashTableForFs(d, {}, './'),    });    const createServerWithBase (distDir: MockFileSystem): MockServerSt  new MockServerStateBuilder() .withRootDirectory('/bef') .withStaticFiles(distDir) .withManifesteManifestWithRelativeBaseHref(distDir)) .build(const initialDistDir = new MockFileSyslder() .addFile('/index.html', 'This is index.html'File('/main.js', 'This is main.js') .addFile('/styles.css', 'This is styles.css') .addFile('/changed/chjs', 'This is chunk-1.jsdFile('/changed/chunk-2.js', 'This is chjs') .addFile('/unchanged/chunk- 'This is chunk-3.js') .addFilehanunk-4.js', 'This is chunk-4.js') .build();    const serverWithBaseHref = createServerseHref(initialDistDir);    beforeEach(() => {serverWeHref.reset();scope = new SwTestHarnessBuilder('hlocalhost/base/href/')   .withServerState(serverWithBaseHref)   ();driver = new Driver(scope, scope, neeDatabase(scope));    });    it('initializes prefetched content tly, after a request kicks it off', asy=> t(await makeRequest(scope, '/base/href/index.html')).toBe('This is index.html');await driver.lized;serverWithBaseHref.assertSawRequestFor('/base/href/ngsw.json');serverWithBasessertSawRequestFor('/base/href/index.html');serverWitref.assertSawRequestFor('/base/href/main.js');serverWithBaseHref.assertSawRequestFor('/base/hrles.css');serverWithBaseHref.assertNoOtherRequests();expeit makeRequest(scope, '/base/href/main.js')).toBe('This is main.js');expect(awkeRequest(scope, '/base/href/styles.cssBe(is styles.css');serverWithBaseHref.assertNoOtherRequests();    });   refetches updates to lazy cache when set', async () => {// Helperconst requ(url: string) => makeRequest(scope, urlct(await request('/base/href/index.html')).toBe('This is index.html');await driver.initializedtch some files from the `lazy` asset group.expect(awauest('/base/href/changed/chunk-1.js')).toBe('This is chunk-1.js');expect(await request('/base/href/unchangnk-3.js')).toBe('This is chunk-3.js');// Install update.cpdatDir = initialDistDir.extend()   .addFile('/changed/chunk-1.js', 'This is chun v2')   .addFile('/changed/chunk-2.js', 'This is chunk-2.js v2')   .build();const updatedServer = crrverWithBaseHref(updatedDistDir);scope.updateServerStdatedServer);expect(await driver.checkForUpdate()).toBe(true);// Previously requested and changed: Fetch from network.updatedServer.assertSawRequestbase/href/changed-1.js');// Never requestechanged: Don't fetch.uServer.assertNstFor('/base/href/changed/chunk-2.js');// Previously requested and unchanged: Fetch from cache.updatedServer.assertNoRequestFor('/base/href/unchanged/chunk-3.js');// Never requested andngedt fetch.updatedServer.assertNoRequestFor('/base/href/unchanged/chunk-4.js');updatedServer.clearRequests();// Update client.await driver.updateClient(await scope.clients.get('default'));// Already cached.expect(await request('/base/href/chanunk))'This is chunk-1.js v2');updatedServer.assererRequests();// Not cached: Fetch from neexpect(await request('/base/href/changed/chunk-2.js')).toBe('This is chunk-2.js v2');updatedServer.assertSawRequestFor('/base/href/changek-2.js');// Already cached (copied from old cache).expect(await request('/base/href/unchanged/chunk-3.js')).toBe('This is chunk-3.js');updatedServer.assertNoOtherRequests();// Not cached: Fetch from network.expect(await request('/base/href/unchanged/chunk-4.js')).toBe('This is chunk-4.js');updatedServer.assertSawRequestFor('/base/href/unchanged/chunk-4.js');updatedServer.assertNoOtherRequests();    });    describe('routing', () => {beforeEach(async () => {  expect(await makeRequest(scope, '/base/href/index.html')).toBe('This is index.html');  await driver.initialized;  serverWithBaseHref.clearRequests();});it('redirects to index on a route-like request', async {  expect(await makeNavigaquest(scope, '/base/href/baz')).toBe('This is index.html');  serverWithBaseHref.assertNoOtherRequests();});it('red to index on a request to the scope URL', async () => {  expect(await makeNavigationRequest(scope, 'http://localhost/base/href/')) .toBe('This is index.html');  WithBaseHref.assertNoOtherRequests();});    });  });  describe('cleanupOldSwCaches()'> {    it('should delete rrect caches', async () => {const oldSwCacheNames = [  // Examphe names from the beta versions of `@angular/service-worker`.  'ctive',  'ngsw:staged',  'ngsw:manifest:a1b2c3:super:duper', ample cache names from the beta versions of `@angular/service-wo  'ngsw:a1b2c3:assets:foo',  'ngsw:db:a1b2cts:bar',];const otherCacheNames = [  'ngsuu:active',  'not:ngsw:active',  'NgSwd',  'ngsw:/:db:control',  'ngsw:/foo/:active',  'ngsw:/bar/:staged',];const allCache= oldSwCacheNames.concat(otherCacheNames);await Promise.all(allCacheNames.map(name => scope.caches.original.open(naexpect(awope.caches.original.keys()).toEqual(jasmine.arrayWithExacnts(allCacheNames));await driver.cleanupOldSwCaches();expect(await scope.coriginal.keys()).toEqual(e.arrayWithExactContents(otherCacheNames));    }it('should delete other caches even if deleting one of them fails', async () => {cldSwCacheNames = ['ngsw:active', 'ngsw:staged', 'ngsw:manifest:a1b2c3:super:duper'];deleteSpy =spyOn(saches.original, 'delete')   .and.callFake(   (cacheName: string) => Promise.reject(`Failed to delete cache '${cacheName}'.`));await Promise.all(oldSwCacheNames.map(name => scopes.original.open(name)));const error = await driver.cleanupOldSs().catch(err => err);expect(error).toBled to delete cache \'ngsw:active\'.');expect(del).toHaveBeenCalledTimes(3);oldSwCacheNames.forEach(name ect(deleteSpy).toHaveBeenCalledWith(name));    });  });  describe(' () => {    it('does not crash with bad inde', async () => {scope = new SwTestHarnessBuilder().withServerStatenServer).build();(scope.registration as any).scope = 'htite.com';driver = new Driver(scope, scope, new CacheDatabase(scope))t(await makeRequest(scope, '/foo.txt')).toEquas is foo (broken)');    });    it('enters degraded mode when update bad index', async () => {expect makeRequest(scofoo.txt')).toEqual('this is foo');await driver.initialized;serearRequests();scopw SwTestHarnessBuilder()   .withCacheState(scope.caches.original.dehydrate())   .withState(brokenServer)   .build();driver Driver(scope, scope, new CacheDatacope));await driver.checkForUpdate();scope.advance(12000);await driver.idle.empty;expiver.state).toEqual(DriverReadyState.EXISTING_CLIENTS_ONLY);    });('enters degraded mode when failing to wricache', async () => {// Initialize the SW.await makeRequest(scope, '/foo.txt');awaitr.initialized;expect(driver.state).toBerReadyState.NORMAL);server.clearRs();// Operate normally.expect(await makeRequest(scope, '/foo.txt')).toBe('this is ferver.assertNoOtherRequests();// Clear the caches and make them unwriawait clearAllCaches(scope.caches);spyOn(MockCache.prototype, 'put').and.thrr('Can\'t touch this');/r degraded mode and serve from network.expect(await makeRequest(scope, '/foo.txt')).toBs is foo');expect(driver.stoBe(DriverReadyState.EXISTING_CLIENTS;sessertSawRequestFor('/foo.txt');    });    it('keeps serving apests with freshness strategy when failing to write to cache', async () => {// Initialize texpect(await makeRequest(scope, '/foo.txt')).l('wait driver.initializ.clearRequests();// Make the caches unwritable.MockCache.protot').and.throwError('Can\'his');spyOn(driver.debug');expect(await makeRequest(spi/foo')).t('this is api foo');expect(driver.state).toBerR.NORMAL);// Since we are swallerror here, make sure it is at least properly loggedexpect(driver.debugg.toHaveBeedWith(  new Error('Can\'h thitaGroup(api@42).safeCacheResponse(/api/foo, status: 200)');server.assertuest/foo'); }); 'keeps serving auests with performance strategy when g to write to cache', async () => {// Initialize the (await makeRequest(scopeo.txt')).toEqual('this is fwait driver.initialized;serverRe();// Make the caches unwe.spyOn(MockCachet').and.throwError('is');spyOn(drivegger, 'log');expect(awkeRequest(scopstatic/btoEqual('thtic api barec.toBe(DriverReadyState.NORMAce we are swallowing an error here sure it is at least properly ect(driver.debugger.log)  .toHlledWith(  new Erro\'t touch this'),  'DataGroup(api-static@43).safeCacheResponsatic/bar, status: 200)');server.asserquestForatic/bar'); });    it('keeving mutating api requests when failing to wache', // sw can invalidate LRU cache entry and try to write to cache storage on mutating request async () => {// Initialize the SW.expect(await mak '/foo.txt')).toEqual('this is foo');await driver.initialized;server.clearRequests();// Makcaches unwritable.spyOn(MockCache.prototype, 'put').and.throwError('Can\'t touch this');spyOn(driver.debugger, 'log');expect(await makeRequest(scopeoo', 'de, {meth'})).toEqual('this is api foo');expect(driver.state).toBe(DriverReadRMAL);ce we are swan error here, make sure least properly loggedexpect(dlog)  .toHaveBeenCalledWith(new Error('Can\'t touch this'), 'D).syncLru()');server.asserstFor('/api/foo')   it('enters degraded mode when somethinong with the latest version', a> {await driver.initialized;// Two clieitial version.expect(await makeRequest(scope, '/foo.txt', 'clie.toBe('oo');expect(await makeRequest(scope, '/foo.txt', 'client2')).toBe(is foo');// Install a broken vbar.txt` has invalid haspe.updateServerState(brokenLazyServer);await driver.checkFor();// Update `client1` but not `client2`.await makeNavigationRequest(scope, '/', 'client1');server.clearRequests();brokenLazyServer.clearRequests();expect(aakeRequest(scope, '/foo.txt', 'client1')).toBe('this is foo (broken)ect(await makeRequest(scofoo.txt', 'client2')).this is foo');server.assertNoOtherRequests();brokenLazyServer.assertNoOtherRequests();// Trying to fetch `bar.txt` (which has an invash) should invalidate the latest// version, enter degraded md "forget" clients that are onversion (i.e.// `clieexpect(await makeRequest, '/bar.txt', 'client1')).toBe('this is bar (broken)');expect(driver.state).toBe(DriverReadyState.EXISTING_CLIENTS_ONLY);brokenLazyServer.assertSawRequ('/bar.txt');brokenLaer.clearRequests();// `client1` shoull be served from the lateoken) version.expect(await makeRequest(scope, '/foo 'client1')).toBe('thiso (broken)');brokenLver.assertNoOtherRequests();// `client2` should still be served fe old version (since it never u).expect(await makeRequest(scope, '/foo.txt',nt2')).toBe('this is foo');server.aoOtherRequests();brokenLazyServer.assertNoOtherRequests();// New clienuld be served from the network.expect(await maest(scope, '/foo.txt', 'client3')).toBe('this is foo (broken)');bazyServer.assertSawRequestFor('/foo.txt');    });    it('enters do enter degraded mode when something goes wrong with an older version', async () => {await driver.initialized;// Three clients on initial n.expect(await makeRequest(scope, '/foo.txt', 'client1')).toBe('this is foo');expect(await makeRequest(scope, '/foo.txt', 'client2')).toBe('this is foo');expect(await makeRequest(scope, '/foo.txt', 'client3')).toBe('this is foo');// Install a broken version (`bar.txt` has invalid hash).scope.updateServerState(brokenLazyServer);await driver.checkForUpdatdate `client1` and `clienot `client3`.await makeNavigationReqe, '/', 'client1');await makeNavigationRequest(scope, '/', 'client2');serveruests();brokenLazyServer.clearRequests();expect(await makeRequest(scope, '/f'clientoBe('this is foo (broken)');expect(await makeRequest(scope, '/f'client2')).toBe('this is foo (br);expect(await makscope, '/foo.txt', 'client3')).toBe('this server.assertNoOtherRequests()zyServer.assertNoOtherRequests();// Install a newer,en version.scope.updateServerState(serverUpdate);awr.checkForUpdate();// Update `client1` bot not `cli`client3`.await makeNavquest(scope, '/', 'client1');expemakeRequest(scope, '/foo.txt', 'client1')).toBe('this is foo v2');// Trying to fetch  (which has an invalid hash on the broken version) from// `client2` should invalidateticular version (which is not the latest one).// (NOTE: Since the file is nolocally, it is fetched from theexpect(await makeRequest(scope, txtt2')).toBe('this is bar');expect(driveroBe(DriverReadyState.NORMAL);UpdRequests();// Existing clientstill be served from their assigned versions.expect(eRequese, '/foo.txt', 'client1')).toBe('this ');expect(await makeRequest(scope, '/foo.txt', 'client2')).toBe('this is foo (bexpect(await makeRequest(scope, '/foo.txt', 'client3')).toBe('this is foo');server.therRequests();brokenLazyServer.assertNoOtherRequests();serverUpdate.assertNoOtherReq/ New clients should be served from the latest version.expect(await makeRequest/foo.txt', 'client4')).toBe('this is foo v2');serverUpdate.assertNoOtherRequ     });    it('recovers from degraded `EXISTING_CLY` mode as soon as there is adate', async () => {await driver.initialized;expect(driver.state).eState.NORMAL);// Install a broken version.scope.updateServerState(brokenwait drieckForUpdate();expect(driate).toBe(DriverReadyStatTING_CLIE;// Install a good version.scope.updateServerState(serverU;await driverUpdate();expect(driver.state).erReadyState.NORMAL); });    it('r degraded mode if manifest for lh is missing uptialization', async () => {//ze the SW.scodleMessage({action: 'INITIALIZull);await driver.initiaect(driver.staBe(DriverReadyState.NORMAL);// Ensure the data has tored in the DB.const dkCache = await scope.caches.open(ntrol') as any;conestHashFromDb = async ()  (await db.match('/latest')).json()).latesct(LatestHashFromDb()).toBe(man);// Change the latest hash to not coro any mt.await db.put('/new MockResponlatest": "wrong-hash"}'));expect(await geDb()).toBe('wrong-hash');tialize the SW and ensure it does not egraded mode.driver.inzescope.handleMessage({action: 'INITIALIZE'}, null);await driver.initialized;expectr.state).toBe(ReadyState.NORMAL);expect(await getLatestHashFromDb()).toBe(manifestHash));    it('iginvy-if-cached` requests ', async () => {const o = (cache: Requestcached', mode: RequestMode) =>makeRequest(scope, efined, {cache, mode});expect(awadefault', 'no-cors')).toBe('this is foo');expect(await re'only-if-cac'same-origin')).toBe('this is foo');expect(await requestFoo('only-', 'no-cors')).toBe;    });    it('ignores passivontent requ, async () => {const scopeFetchSpy = pe, 'fetch').and.callThrough();const getReque = () =>(scop.calls.allArgs() as [Request][]).map(args => args[0].urconst hteUrl = 'http://mock.origin.dev' httpsScopeUps://mock.origin.dev';    ttptUrl = 'http://other.origin.sh/unknown.pnconst htuestUrl = 'ther.origin.sh/unknown.pnp';// Registration stp:`(scope.registration.scopering) = httpScopeUrl;await makeRequest(scope, httpRequestUrl);await makeRequest(scope, httpsRequestUrl);const requestUrls1 = getRequestUrls();expect(tUrls1).toContain(httpRequestUrl);expect(requestUrls1).toContain(httpsRequestUrl);scopeFetchSpy.calls.reset();// Registration scope: `https:`(scope.registration.scope as string) = httpsScopeUrl;await makeRequest(scope, httpRequestUrl);await makeRequest(scope, httpsRequestUrl);const requestUrls2 = getRequestUrls();expect(requestUrls2).not.toContain(httpRequestUrl);expect(requestUrls2).toContain(httpsRequestUrl);    });    it('does not enter degraded mode when offline while fetching an uncached asset', async () => {// Trigger SW initialization and wait for it to complete.expect(await makeRequest(scope, '/foo.txt')).toBe('this is foo');await driver.initialized;// Request an uncached asset while offline.// The SW will not be able to get the content, but it should not enter a degraded mode either.server.online = false;await expectAsync(makeRequest(scope, '/baz.txt')).toBeRejectedWithError(   'Response not Ok (fetchAndCacheOnce): request for /baz.txt returned response 504 Gateway Timeout');expect(driver.state).toBe(DriverReadyState.NORMAL);// Once we are back online, everything should work as expected.server.online = true;expect(await makeRequest(scope, '/baz.txt')).toBe('this is baz');expect(driver.state).toBe(DriverReadyState.NORMAL);    });    describe('unrecoverable state', () => {const generateMockServerState = (fileSystem: MockFileSystem) => {  const manifest: Manifest = {configVersion: 1,timestamp: 1234567890123,index: '/index.html',assetGroups: [{ name: 'assets', installMode: 'prefetch', updateMode: 'prefetch', urls: fileSystem.list(), patterns: [], cacheQueryOptions: {ignoreVary: true},}],dataGroups: [],navigationUrls: processNavigationUrls(''),navigationRequestStrategy: 'performance',hashTable: tmpHashTableForFs(fileSystem),  };  return {serverState: new MockServerStateBuilder() .withManifest(manifest) .withStaticFiles(fileSystem) .build(),manifest,  };};it('notifies affected clients', async () => {  const {serverState: serverState1} = generateMockServerState( new MockFileSystemBuilder() .addFile('/index.html', '<script src="foo.ha></script>') .addFile('/foo.hash.js', 'console.log("FOO");') .build());  const {serverState: serverState2, manifest: manifest2} = generateMockServerState( new MockFileSystemBuilder() .addFile('/index.html', '<script src="bar.hash.js"></script>') .addFile('/bar.hash.js', 'console.log("BAR");') .build());  const {serverState: serverState3} = generateMoerState( new MockFileSystemBuilder() .addFile('/index.html', '<script src="baz.hash.jcript>') .addFile('/baz.hash.js', 'console.log("BAZ");') .build());  // Create initial server state and initialize the SW.  scope = new SwTestHarnessBuilder().withServerState(serverState1).build();  driver = new Driver(scope, scope, new CacheDatabase(scope));  // Verify that all three clients are able to make the request.  expect(await makeRequest(scope, '/foo.hash.js', 'client1')).toBe('console.log("FOO");');  expect(await makeRequest(scope, '/foo.hash.js', 'client2')).toBe('console.log("FOO");');  expect(await makeRequest(scope, '/foo.hash.js', 'client3')).toBe('console.log("FOO");');  await driver.initialized;  serverState1.clearRequests();  // Verify that the `foo.hash.js` file is cached.  expect(await makeRequest(scope, '/foo.hash.js')).toBe('console.log("FOO");');  serverState1.assertNoRequestFor('/foo.hash.js')Update the ServiceWorker to the second version.  scope.updateServerState(serverState2);  expect(await driver.orUpdate()).toEqual(true);  // Update the first two clienthe latest version, keep `client3` as is.  const [client1, client2] = Promise.all([scope.clients.get('client1'), scope.clients.get('client2')]);  await Promise.all([driver.updateClient(cl, driver.updateClient(client2)]);  // Update the Servker to the latest version  scope.updateServerState(serverState3);  expect(await driver.checkForUpdate()).toEqual(true);  // Remove `ba.js` from the cache to emulate the browser evicting files from the cache.  await removeAssetFromCache(scope, manifest2, '/bar.hash.js');  // Get aents and verify theirges  const mockClient1 = scope.clients.getMock('clie;  const mockClient2 = scope.clients.getMlient2')!;  const mockClient3 = scope.clietMock('client3')!;  // Try to retrievehash.js`, which is neither in the cache nor on rver.  // This should put the SW in an unrecovertate and notify clients.  exwait makeRequest(scope, '/bar.h', 'client1')).toBeNull();  serverState2.assertSawReqr('/bar.hash.js');  const unrecoverableMe= {type: 'UNRECOVERABLE_STATE',reason:   ' to retrieve hashed resource from the . (AssetGroup: assets | URL: /bar.hash.js)'  };  exockClient1.messages).toContain(unrecoverableMessage);  expect(mockClient2.messages).toContain(unrecoverableMessage);  expect(mockClient3.messages).not.ton(unrecoverableMessage);  // Because `client1` failed, `c` and `client2` have been moved to the latest version.  // Verifyby retrieving `baz.hash.jxpect(await makeRequest(scope, '/baz.hash.jlient1')).toBe('console.log("BAZ");');  serverState2.assertNoRequestFor('/baz.hash.js');  expeit makeRequest(scope, hash.js', 'client2')).toBe('console.log("BAZ");');  serverState2.assertNoRequestFor('/baz.hash.js');  // Ensure that `client3` remains on the first version and can request `fh.js`.  expect(await makeRequest(scope, '/foo.hash.client3')).toBe('console.log("FOO");');  serverState2.assertNoRFor('/foo.hash.js');}enters degraded mode', async () => {  const originalFiles = new MeSystemBuilder()    .addFile('/index.html', '<script src="foo.hash.js"></script>')    .addFile('/foo.s', 'console.log("FOO");')    .build();  const updatedFiles = newileSystemBuilder()   .addFile('/index.html', '<script src="bar.hash.js"></script>')   .addFile('/bar.hash.js', 'console.log("BAR");')   .build();  const {serverState: originalServer, manifest} = generateMockServerState(originalFiles);  const {serverState: updatedServer} = generateMockServerState(updatedFiles);  // Create initial server state and initialize the SW.  scope = new SwTestHarnessr().rverState(originalServer).build();  driver = new Driver(scope, scope, new CacheDatabase(scope));  expect(await makeRequest( '/fh.toBe('console.log("FOO");');  await driver.inzed;  originalServer.clearRequests();  // Verify that the `foo.hash.js` file is cached.  expect(await makeRequest(scope, '/foo.hash.js')).toBe('console.log("FOO");');  originalServer.assertNoRequestFor('/foo.hash  // Update the server state to emulate deploying a new version (where `foo.hash.js` does not  // exist any more). Keep the cache though.  scope = new SwTestHarnessBuilder()     .withCacheState(scope.caches.original.dehydrate())     erverState(updatedServer)     .build();  driver = new Driver(scope, scope, new CacheDatabase(scope));  // The SW is still able to serve `foo.hash.js` from the cache.  expect(await makeRequest(scope, '/foo.hash.jsBe('console.log("FOO");');  updatedServer.assertNoReque'/foo.hash.js');  // Remove `foo.hash.js` from the cache to emulate the brovicting files from the cache.  await removeAssetFromCache(scopifest, '/foo.hash.js');  // Try to retrieve `foo.hash.js`, whichither in the cache nor on the server.  // This should put the SW in an unrecoverable stateotify clients.  expect(await makeRequest(scope, '/foo.hash.js')).toBeNull();  updatedServertSawRequestFor('/foo.hash.js');  // This should also enter the `SW` into degraded mode, b the broken version was theatest one.  expect(driver.stateual(DriverReadyState.EXISTING_CLIENTS_ONLY);});it(ndled correctly even if some of the clients no longer exist', async () => {  coiginalFiles = new MockFileSystemBuilder()    .addFindex.html', '<script src="foo.hash.js"></script>') dFile('/foo.hash.js', 'console.log("FOO"  .build();  const updatedFiles = new MockFileSystemBu)   .addFile('/index.html', '<script src="bar.hash.js"></script>')   .addFile(hash.js', 'console.log("BAR");')   .build();  const {serverState: originalServer, manifest} = generateMockSerte(originalFiles);  const {serverState: updatedServer} = generateMockServerState(uFiles);  // Create initial server state and initiale SW.  scope = new SwTestHarnessBuilder(ServerState(originalServer).build();  driver = new Driope, scope, new CacheDatabase(scope));  expect(await makeRequest(scope, '/foo.hash.js', 'clien.toBe('console.log("FOO");');  expect(await makeRequest(scope, hash.js', 'client-2')).toBe('console.log("FOO" await driver.initialized;  // Update the server state tate deploying a new version (where `foo.hash.js` does noexist any more). Keep the cache though.  scope = new SwTnessBuilder()     .withCacheState(scope.caches.original.dehydrate())     .withServerupdatedServer)     .build();  driver = new Driver(scope, scope, new Cachese(scope));  // The SW is still able to serve `foo.hash.js` from the cachpect(await makeRequest(scope, '/foo.hash.js', 'clie).toBe('console.log("FOO");');  expect(await makeRequest(scope, '/foo.hash.js', 'client-2')).toBe('console.log("FOO");');  // Remove `foo.hash.js` from the cache tote twser evicting files from the cache.  await removeAssetFromCache, manifest, '/foo.hash.js');  // Remove one of the clients to e closing a browser tab.  scope.clients.remove('client-1');  // Retrhe remaining client to ensure it is notified.  const mockClient2 = scope.clients.getMock('cli)!;  expect(mockClient2.messages).toEqual([])Try to retrieve `foo.hash.js`, which is neither in the cache nor on the server.  // This sput the SW in an unrecoverable state and notify cl(even if some of the  // previously known clients no longer exist).  expect(await makeRequope, '/foo.hash.js', 'client-2')).toBeNull();  expckClient2.messages).toEqual([jasmine.objectContaining( {type: 'UNRECOVERABLE_STATE'})] This should also enter the `SW` into degraded mode, because the broken version was the  /st one.  expect(driver.state).toEqual(DriverReadySXISLIENTS_ONLY);});    });    describe('bac compatibility with v5', () => {beforeEach(() => {  const serverV5 = new MockServerStateBuilder()   .withStaticFiles(dist)   .withManifest(<Manifest>manifestOld)   .build();  scope SwTestHarnessBuilder().withServerState(serverV5).build();  driver = new Driver(scope, scope, new CacheDatabase(scope));});// Test this bug: https://github.com/angular/angular/is7209it('fills previous versions of manifests with default navigation urls for backwards cbility',async () => {expect(await makeRequest(scope, '/foo.txt')).toEqual('thfoo');await driver.initialized;scope.updateServerState(Update);expect(await driver.checkForUpdate()).toEqual(true);});    });  });  be('navigationRequestStrategy', () => {    it('doesn\'t createate request in performance mode', async () => {await makeRequest(scope, '/foo.twait driver.initialized;awaver.clearRequests();// Create mulnavigation requests to prove no navigation requestade.// By default the navigation request is not sent, it's replaced// with the request - thus, the `this is foo` value.expect(awaitavigationRequest(scope, '/', '')).toBe('this is foo');expect(await makeNavigationRequest(scopoo', '')).toBe('this is foo');expect(await migationRequest(scope, '/foo/bar', '')).toBe('this is foo');server.assertNoOtherRequests();    });    it('sends the request to the server in fss mode', async ()  const {server, scope, driver} = createSwFonessStrategy();await makeRequest(scope, '/foo.txt');await driveralized;await server.clearRequests();// Create multiption requests to prove the tion request is constantly made.// When enabled, thgation request is made each time and not replaced// with the index request - thus, the `null` expect(await makeNavigationRequest(scope, '/', '')).toBe(null)t(await makeNavigationRequest(scope, '/foo', '')).toBe(null);expect(await makeNavigaquest(scope, '/foo/bar', '')).toBe(null);server.assertSawRequestFor('/');.assertSawRequestFor('/foo');server.assertSawRequestFor('/foo/server.assertNoOtherRequests();    });    function cwForFreshnessStrategy() {const freshnessManifest: Manifest = {...manifest, navigationRequesegy: 'freshness't server = serverBuilderBase.withManifest(freshnessManifest).build();coope SwTestHarnessBuilder().withServerState(server).build();const driver = new Driver(sccope, new CacheDatabase(scope));return {server, scope, driver};    }  });});})();async function removeAssetFromCache(    scope: SwTestHarness, appVersionManifest: Manifest, assetPating) {  const assetGroupName =appVersionManifest.assetGroups?.find(group => group.urls.includes(assetPath))?.name;  const cacheName = `${sha1(JSON.stringify(appVersionManifest))ts:${assetGroupName}:cache`;  const cache = await scope.caches.open(cacheName);  return celete(assetPath);}async function makeRequest(    scope: SwTestHarness, url: s clientId = 'default', init?: Object): Promise<string|n  const [resPromise, done] = scope.handleFetch(new MockRequest(url, init), cl);  await done;  const res = await resPromise;  if (res !== und && res.ok) {    return res.text();  }  return null;}function makeNavigationRequest(    scwTestHarness, url: string, clientId?: string, init: Object = {}): Promise<string|null> {  rmakeRequest(scope, url, cli {    headers: {Accept: 'text/plain, text/html, text/css',...(init as any).headers,    },    'navigate',    ...init,  });}