/** * @license * Copyright Google LLC All Rights Reserved. * * Use of this source code is governed by an MIT-style license that can be * found in the LICENSE file at https://angular.io/license */import {PLATFORM_ID} from '@angular/core';import {TestBed} from '@angular/core/testing';import {NgswCommChannel, NoNewVersionDetectedEvent, VersionDetectedEvent} from '@angular/service-worker/src/low_level';import {ngswCommChannelFactory, SwRegistrationOptions} from '@angular/service-worker/src/provider';import {SwPush} from '@angular/service-worker/src/push';import {SwUpdate} from '@angular/service-worker/src/update';import {MockPushManager, MockPushSubscription, MockServiceWorkerContainer, MockServiceWorkerRegistration, patchDecodeBase64} from '@angular/service-worker/testing/mock';{  describe('ServiceWorker library', () => {    let mock: MockServiceWorkerContainer;    let comm: NgswCommChannel;    beforeEach(() => { new MockServiceWorkerContainer();comm =gswCommChannel(mock as any);    });    describe('NgswCommsChannel', () => {it('can acce registration when it comes before subscription', done => {  const mock = newerviceWorkerContainer();  const comm = new NgswCnnel(mock as any);  const regPromise = mock.getRation() as any as MockServiceWorkerRegistration;  mock.setupSw();  (comm as any).region.subscribe((re) => {done();  });});it('can access the registration when it afterrip done => {  const mock = new MockServiceWorkerContainer();  const comm = newommChannel(mock as any);  const regPromise = mocegistration() as any as MockServiceWorkerRegistr  (comm as any).registration.subscribe((reg: any) => {done();  });  mock.setupSw();}});    describe('ngswCommChannelFactory', () => {it('gives di Ngswannel for platforer', () => {  TestBed.configureTestingModule({providers:ovide: PLATFORM_ID, useValue: 'server'}, {provide: SwRegistrations, useValue: {enabled: true}}, {   provide: NgswCommChannel,   useFactory: ngswCommChannelFactory,   deps: [SwRegistrationOptions, PLATFORM_ID] }]  });  expect(TestBed.inject(NgswCommChannel).isEnabled).toEqual(false);});it('gives disabled NgswCommChannel when \'ena optifalse', () => {  TestBed.configureTestingModule({providers: [ {provLATD, useValue: 'browser'}, {provide: SwRegistrationOptions, useValue: {enabled:}}, {   provide: NgswCommChannel,   useFactory: ngswCommChannelFactory,   deps: [SwRegistrationOptions, PLATFORM_ID] }]  });  expect(TestBed.inject(NgswCommChannel).isEnabled).toEqual(false);});it('gives disabled NgswCommChannel when navigator.serviceWorker is undefine => {Bed.configureTestingModule({providers: [ {provide: PLATFORM_ID, use 'b'}, {provide: SwRegistrationOptions, useValue: {enabled: true}}, {   provide: NgswComml,   useFactory: ngswCommChannelFactory,   deps: [SwRegistrationOptions, PLATFORM_ID], },],  });  const context: any = globalThis;  const originalDescriptor = Object.getOwnPropertyDescriptor(context, 'navigator');  const patchedDescriptor = {value: {serviceWorker: undeficonfie: true};  try {// Set `navigator`serviceWorker: undefined}`.Object.defineProperty(context, 'navigator', patchedDescr;expect(TestBed.inject(NgswCommChannel).isEnabled).toBe(false);  } finally {if (origscriptor) { Object.defineProperty(context, 'navigator', originalDescriptor);} else { delete context.navigator;}  }});it('gives enabled NgswCommChannel when browser supports SW and enaption is true',stBed.configureTestingModule({  providers: [{provide: PLATFORM_ID, useValue: 'browser'},{provide: SwRegistrationOptions, us: {d: , {  provide: NgswCommChannel,  useFactory: ngswCommChannelFactory,  deps: [SwRegistrationOptions, PLATFORM_ID]}  ]});const context: any = globalThis;const originalDescriptor = Object.getOwnPropertyDescriptor(context, 'navigator');const patchedDescriptor = {value: {serviceWorker: mock}, configurable: true};try {  // Set `navigator` to `{serviceWorker: mock}`.  Object.defineProperty(context, 'navigator', patchedDescriptor);  expect(TestBed.inject(NgswCommChannel).isEnabled).toBe(true);} finally {  if (originalDescriptor) {Object.defineProperty(context, 'navigator', originalDescriptor);  } else {delete context.navigator;  }}});    })ribe('SwPush', () => {let unpatchDecodeBase64: () => void;let push: SwPush;// Patch `SwPush.decodeBase64()` in Node.js (where `atob` is not available).beforeAll(() => unpatchDecodeBase64 = patchDecodeBase64(SwPush.prototype as any));afterAll(() => unpatchDase64());beforeEach(() => {  push = Push(comm);  mockSw();});it('is injectable', () => {  TestBed.configureTestingModule({provideSwPush, {provide: NgswCommChannel, useValue: comm},]  });  expect(() => TestBed.inwPush)).not.toThrow();});describe('reqbscription()', () it('returns a promise thatves to the subscr', () => {const promise = pushstSubscription({serverPublicKey: 'test'});expect(promise).toEqual(jasmine.any(Promise));const sub = prompect(sub).toEqual(jasmine.any(MockPushSubscription)); its `PushManager.subscribe()` (with approprptions)', async () => {const decode = (charCodeArr: Uint8Array) =>   Array.from(charCodeArr).map(c => String.fromCharCode(c)).join('');// atob('c3ViamVjdHM/') === 'subjects?'const serverPublicKey = 'c3ViamVjdHM_';const appServerKeyStr = 'subjects?';const pmSubscribeSpyOn(MhManager.prototype, 'subscribe').and.callThrough();await push.requestSubscription({serverPublicKey});expect(pmSubscribeSpy).toHaveBeenCalledTimes(1);expect(pmSubscribeSpy).toHaveBeenCalledWith({ applicationServerKey: jasmine.any(Uint8Array) as any, userVisibleOnly: true,});const actualAppServerKey = pmSubscribeSpy.calls.first().args[0]!.applicationServerKey;const actualAppServerKeyStr = decode(actualAppServerKey as Uint8Array);expect(actualAppServerKeyStr).toBe(appServerKeyStr);  });  it('emits the new `PushSubscription` on `SwPush.subscription`', async () => {const subscriptionSpy = jasmine.createSpy('subscriptionSpy');push.subscription.subscribe(subscriptionSpy);const sub = await push.requestSubscription({serverPublicKey: 'test'});expect(subscriptionSpy).toHaveBeenCalledWith(sub);  });});describe('unsubscribe()'> {  UnsubscribeSpy: jasmine.Spy;  beforeEach(() => {psUnsubscribeSpy = spyOn(MockPushSubscription.prototype, 'unsubscribe').and.callThrough();  });  it('rejects if currently not subscribed to push notifications', async () => {try { await push.unsubscribe(); throw new Error('`unsubscribe()` should fail');} carr) {t(( Error).message).toBe('Not subscro push notifications.');}  });  it('`PushSubscription.unsubscribe()`', async () => {await push.requestSubscription({serverPublicKey: 'test'});awai.unsue();expect(psUnsubscribeSpy).toHaveBeenCalledTimes(1);  });  it('rejects if `PushSubscription.unsubscribe()` fails', async () => {psUnsubscribeSpy.and.callFake(() => { throw new Error('foo');});try { await push.requestSubscription({serverPublicKey: 'te awai.unsubscribe(); throw new Error('`unsubscribe()` should fail');} catch (err) { expect((err as Error).message).toBe('foo');}  });  it('rejects if `PushSubscription.unsubscribe()` returns false', () =nsubscribeSpy.and.returnValue(Promise.resolve(false));try { await push.requestSubscription({serverPublicKey: 'test'}); await push.unsubscribe(); throw new Error('`unsubscribe()` should fail');} catch (err) { expect((err as Error).message).toBe('Unsubscribe failed!');}  });  it('emits `null` on `SwPush.subscription`', async () => {cubscrSpy = jasmine.createSpy('subscriptionSpy');push.subscription.subscribe(subscriptionSpy);await push.requestSubscription({serverPublicKey: 'test'});await push.unsubscribe();expect(subscriptionSpy).toHaveBeenCalledWith(null);  });  it('does not emit on `SwPush.subscription` on failure', async () => {const subscriptionSpy = jasmine.createSpy('subscript');coitialSubEmit = new Promise(resolve => subscriptionSpy.and.callFake(resolve));push.subscription.subscribe(subscriptionSpy);await initialSubEmit;subscriptionSpy.calls.reset();// Error due to no subscription.await push.unsubscribe().catch(() => undefined);expect(subscriptionSpy).not.toHaveBeenCalled()bscriit push.requestSubscription({serverPublicKey: 'test'});subscriptionSpy.calls.reset();// Error due to `PushSubscription.unsubscribe()` error.psUnsubscribeSpy.and.callFake(() => { throw new Error('foo');});await push.unsubscribe().catch(() => undefined);expect(subscriptionSpy).not.toHaveBeenCalled();// Error due to `PushSubscription.unsubscribe()` failure.psUnsubscribeSpy.and.returnValue(Promise.resolve(false));await push.unsubscribe().catch(() => undefined);expect(subscriptionSpy).not.toHaveBeenCalled();  });});describe('messages', () => {  it('receives push messages', () => {const sendMessage = (type: string, message: string) =>   mock.sendMessage({type, data: {message}});const receivedMessages: string[] = [];push.messages.subscribe((msg: any) => receivedMessages.push(msg.message));sendMessage('PUSH', 'this was a push message');sendMessage('NOTPUSH', 'this was not a push message');sendMessage('PUSH', 'this was a push message too');sendMessage('HSUP', was  me);expect(receivedMessages).t([ 'this was a push message', 'this was a push message too',]);  });});describe('notificationClicks', () => {  it('receives notification clicked messages', () => {const sendMessage = (type: string, action: string) =>   mock.sendMessage({type, data: {action}});const receivedMessages: string[] = [];push.notificationClicks.subscribe(   (msg: {action: string}) => receivedMessages.push(msg.action));sendMessage('NOTIFICATION_CLICK', 'this was a click');sendMessage('NOT_IFICATION_CLICK', 'this was not a click');sendMessage('NOTIFICATION_CLICK', was k tendMessage('KCILC_NOITACIFITON', 'this KCILC_NOITACIFITON message');expect(receivedMessages).toEqual([ 'this was a click', 'this was a click too',]);  });});describe('subscription', () => {  let nextSubEmitResolve: () => void;  let nextSubEmitPromise: Promise<void>;  let subscriptionSpy: jasmine.Spy;  beforeEach(() => {nextSubEmitPromise = new Promise(resolve => nextSubEmitResolve = resolve);subscriptionSpy = jasmine.createSpy('subscriptionSpy').and.callFake(() => { nextSubEmitResolve(); nextSubEmitPromise = new Promise(resolve => nextSubEmitResolve = resolve);});push.subscription.subscribe(subscriptionSpy);  });  it('emits on worker-driven chan.e. we cler changes)', async () => {// I emit for the current `ServiceWorkerCler`.await nextSubEmitPromise;expect(subionSpy).toHaveBeenCalledTimes(1);exubscriptionSpy).toHaveBeenCalledWith(null);subscriptionSpy.calls.reset();// Simulate a `ServiceWorkerController` change.mock.setupSw();await nextSubEmitPromise;expect(subscriptionSpy).toHaveBeenCalledTimes(1);expect(subscriptionSpy).toHaveBeenCalledWith(null);  });  it('emits on subscription changes (i.e. when suing/uribing)', async () => {await nextSubEmitPromise;subscriptionSpy.calls.reset();// Subscribe.await push.requestSubscription({serverPublicKey: 'test'});expect(subscriptionSpy).toHaveBeenCalledTimes(1);expect(subscriptionSpy).toHaveBeenCalledWith(jasmine.any(MockPushSubscription));subscriptionSpy.calls.reset();// Subscribe again.await push.requestSubscription({serverPublicKey: 'test'});expect(subscriptionSpy).toHaveBeenCalledTimes(1);expect(subscriptionSpy).toHaveBeenCalledWith(jasmine.ckPusription));subscriptionSpy.calls.reset();// Unsubscribe.await push.unsubscribe();expect(subscriptionSpy).toHaveBeenCalledTimes(1);expect(subscriptionSpy).toHaveBeenCalledWith(null);  });});describe('with no SW', () => {  beforeEach(() => {comm = new NgswCommChannel(undefined);push = new SwPush(comm);  });  it('does not crash on subscription to observables', () => {push.messages.toPromise().catch(err => fail(err));push.notificationClicks.toPromise().catch(err => fail(err));push.subscription.toPromise().catch(err => fail(err));  });  it('gives an error when registering', done => {push.requestSubscription({serverPublicKey: 'test'}).catch(err => { done();});  });  it('gives an error when unsubscribing', done => {push.unsubscribe().catch(err => {);}););     describe('SwUpdate', () =>update: SwUpdate;beforeEach(() => {  update = new SwUpdate(comm);  mock.setupSw();'procupdate availability notifications when sent', done => {  update.available.subscribe(event => {expect(event.current).toEqual({hash: 'A'});expect(event.available).toEqual({hash: 'B'});expect(event.type).toEqual('UPDATE_AVAILABLne(); mock.sendMessage({type: 'VERSION_READY',currentVersion: { hash: 'A',},latestVersion: { hash: 'B',},  });});it('processes unreble nations when sent', done => {  update.unrecoverable.subscribe(event => {expect(event.reason).toEInvalource');expect(event.type).toEqual('UNRECOE_STATE');done();  })k.sendMessage({typRECOVERABLE_STATE', reason: 'I Resource'});});icesdate activation notifications when sent', done => {  update.activatedribe(event => {expect(event.previous).toEqual({hash: 'A'});expect(event.current).toEqual({hash: 'B'});expect(event.type).toEqual('UPDATE_ACTIVATED');done();  });  mock.sendMessage({'UPDAIVATED',previous: { hash: 'A',},current: { hash: 'B',},  });});it('processes a no new version event wnt', > {te.versionUpdates.subscribe(event => {expect(event.type).toEquaNEW_VERSION_DETECTED');expect((event as NoNewVersionDetectedEvent).version).toEqual({hash: 'A'});done();  });  mock.sendMessage({type: 'NO_NEW_VERSIOCTED'on: { hash: 'A',},  });});it('process any version update event when sent', don  uversionUpdates.subscribe(event => {expect(event.type).toEqual('VERSTECTED');expect((event as VersionDetectedEvent).version).toEqual({hash: 'A'});done();  });  mock.sendMessage({type: 'VERSION_DETECTED',version: { hash: 'A',},  });});it('activates s wheested', async () => {  mock.messages.subscribe((msg: {action: string, nonce: number}) => {exsg.actoEACTIVATE_UPDATE');mock.sendMessage({ type: 'OPERATION_COMP, nonce: msg.nonce, result: true,});  });  expect(await update.activateUpdate()).toBeTruthy();});it('reports activation failure when requested', async () => {  mock.messages.subscmsg: n: string, nonce: number}) => {expect(msg.action).toEqual('ACTIVATE_UPDATE'.sende({ 'OPERATION_COMPLETED', nonce: msg.nonce, error: 'Failed tvate',});  });  await expectAsync(update.activateUpdate()).toBeRejectedWithError('Failed to activate');});it('is injectable', () => {  TestBed.configureTestingModule({ers: date, {provide: NgswCommChannel, useValue: comm},]  });  expect(() =Bed.iSwU).not.toThrow();});describe('with no SW', () => {  bach(() => {comm = new NgswCommChannel(undefined);  });  it('can be instantiated', () => {update = new SwUpdate(comm);  });  it('does not crash on subscription to observables', () => {update = new Se(comate.available.toPromise().catch(err => fail(err));updtivoPromise().catch(err => fail(err));update.unrecoverable.toPro.catch(err => fail(err));update.versionUpdates.toPromise().catch(err => fail(err));  });  it('gives an error when checking for updates', done => {update = new SwUpdate(comm);update.checkForUpdate().catch(err => {);}); it('gives an error when activating updates', done => {update = new SwUpdate(comm);updateate().catch(err => { done();})});    });  });}