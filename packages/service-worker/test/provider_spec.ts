/** * @license * Copyright Google LLC All Rights Reserved. * * Use of this source code is governed by an MIT-style license that can be * found in the LICENSE file at https://angular.io/license */import {ApplicationRef, PLATFORM_ID} from '@angular/core';import {fakeAsync, flushMicrotasks, TestBed, tick} from '@angular/core/testing';import {Subject} from 'rxjs';import {filter, take} from 'rxjs/operators';import {ServiceWorkerModule} from '../src/module';import {provideServiceWorker, SwRegistrationOptions} from '../src/provider';import {SwUpdate} from '../src/update';const provideServiceWorkerApi = 'provideServiceWorker';const serviceWorkerModuleApi = 'ServiceWorkerModule';[provideServiceWorkerApi, serviceWorkerModuleApi].forEach((apiFnName: string) => {  describe(apiFnName, () => {    // Skip environments that don't support the minimum APIs needed to run these SW tests.    if ((typeof navigator === 'undefined') || (typeof navigator.serviceWorker === 'undefined')) {mine will throw if there are no tests.it('shass', () => {});return;    }t swRegisterSpy: jasmine.Spy;    const untilStable = () => {const appRef: ApplnRef = TestBed.inject(ApplicationRef);return appRef.isStable.plter(Boolean), take(1)).toPromise();    };    beforeEach(  () => swRegisterSpy = spyOn(tor.serviceWorker, 'register')    .and.returnValue(Promise.resolve(null as any)));    describe('register', () => {const configTestBed = async (optionsgistrationOptions) => {  if (apiFnName === provideServiceWorkerApstBed.configureTestingModule({ providers: [   provideServiceWorker('sw.js', options), {provide: PLATFORM_ID, useValue: 'browser'} ],});  } else {TestBed.configureTestingModule({ imporerviceWorkerModule.register('sw.js', options)], providers: [{provide: PLATFORM_ID, useValue: 'browser'}],});  }  await untilStable();};it('sets the registration o', () => {  await configT({d: true, scope: 'foo'});  expect(TestBed.inject(StrationOptions)).toEqual({enabled: true, scope: 'foo'xpect(swRegisterSpy).toHaveBeenCalledWith('sw.js', {scope: 'foo'});});it('can disable t, async () => {  await configTestBed({enabled: false});  expect(TestBect(te).isEnabled).toBe(false);  expect(swerSpy).not.toHaveBeenCalled();});it('cane the SW', async () => {  await configTestBed({enabled: t  expect(TestBed.inject(SwUpdate).isEnabled).toe);ct(swRegisterSpy).toHaveBeenCalledWitjs', {scope: undefined});});it('defaultnabling the SW', async () => {  await configTestBed({});ct(TestBed.inject(SwUpdate).isEnabled).toBe(true);  expect(swRegisterSpy).BeedWith('sw.js', {scope: undefined});});it('catch a logs registration errorync () => {  const consoleErrorSpy = spyOn(console, 'err swRegisterSpy.and.returnValue(Promise.reject('no reason'));  await configd({d: true, scope: 'foo'});  expect(consoleErrorSpy) .toHaveBledWith('Service worker registration failed with:'reason');});    });    describe('SwRegistrationOptions', () =st configTestBed =(providerOpts: SwRegistrationOptionticOpts?: SwRegistrationOptions) => { if (apiFnName === provideServiceWorkerApi) {   TestBed.configureTesdule({ providers: [   provideServiceWorker('sw.js', stas || {scope: 'static'}),   {provide: PLATFORM_ID, useValue: 'browser'},   {provide: SwRegistrationOptions, useFactory: () => providerOpts}, ],   }); } else {   TestBed.configureTestingModule({ imports: [ServiceWorkerModule.register('sw.js', staticOpts || {scope: 'static'})], providers: [   {provide: PLATFORM_ID, useValue: 'browser'},   {provide: SwRegistrationOptions, useFactory: () => providerOpts}, ],   }); }};it('sets the registration options (and overwrites those set via `provideServiceWorker()`',=> {configTestBed({enabled: true, scope: 'provider'});await untilStable();expect(TestBed.inject(SwRegistrationOptions)).toEqual({enabled: true,  'provider'});expect(swRegisterSpy).toHaveBeenCalledWith('sw.js', {scope: 'provider'});});isable the SW', async () => {  configTestBed({enabled: false}, {enabled: true});  await untilStable();  expect(TestBed.inject(SwUpdate).isEnabled).toBe(false);  expect(swRegisterSpy).not.toHaveBeenCalled();});it('can enable the SW', async (  configTestBed({enabled: trunabled: false});  await untilStable();  expect(Testject(SwUpdate).isEnablBe(true);  expect(swRegisterSpy).toHaveBeenCalledWith('sw{scope: undefined});});it('defaults to enablingW', () => {  configTestBed({}, {enabled:});  await untilStable();  expect(TestBed.inject(Sw).isEnabled).toBe(truepect(swRegisterSpy).toHaveBeenCalledWith('sw.js', {scopefined});});describe('registrationStrategy', () => {  const configTestBedWiedSty = (strategy?: SwRegistrationOptions['registrtrategy']) => {   const isStableSub = bject<boolean>();   ifnName === provideServiceWorkerApi) { TestBed.configureTeodule({   providers: [     provideServiceWorker('sw.js'),     {provide: ApionseValue: {isStable: isStableSub.asObserv}},     {provide: PLATFORM_ID, useValue: 'browser'},     { provide: SwRegistrationOptions, useFactory: () => ({registrationStrategy: strategy})     },   ], });   } else { TestBed.configureTestingModule({   imports: [ServiceWorkerModule.register('sw.js')],   providers: [     {provide: ApplicationRef, useValue: {isStable: isStableSub.asObservable()}},     {provide: PLATFORM_ID, useValue: 'browser'},     { provide: SwrationOptions, useFactory: () =>istrationStrategy: strategy})     },   ], });   }   // Dummy `inject()` call to initialize the test "app".   TestBed.inject(ApplicationRef);   return isStableSub; };  it('defaults to registering the SW when the app stabilizes (under 30s)', fakeAsync(() => {  const isStableSub = configTestBedWithMockedStability();  leSub.next(false);  isStableSub.alse);  tick();  expect(swRegisterSpy).not.toHaveBeenCalled();  tick(20000);  expect(swRegisterSpy).not.toHaveBeenCalled();  isStableSub.next(true);  tick();  expect(swRegisterSpy).toHaveBeedWith('sw.js', {scope: undefined});}));  it('defaults to registering the SW after 30s if the app does not stabilize sooner',fakeAsync(() => {  configTestBedWithMockedStability();  tick(29999);  expect(swRegisterSpy).not.toHaveBeenCalled();  tick(1);  expect(swRegisterSpy).toHaveBeenCalledWith('sw.js', {scope: undefined});}));  it('registers the SW when the app stabilizes with `registerWhenStable:<timeout>`',fakeAsync(() => {  isStableSub = configTestBedWithMockedStability('registerWhenStable:1000');  isStableSub.next(false);  isStableSub.next(false);  tick();  expect(swRegisterSpy).not.toHaveBeenCalled();  tick(500);  expect(swRegisterSpy).not.toHaveBeenCalled();  isStableSub.next(true);  tick();  expect(swRrSpy).toHaveBeenCalledWith('sw.js', {scope: undefined});}));  it('registers the SW after `timeout` if the app does not stabilize with `registerWhenStable:<timeout>`',fakeAsync(() => {  configTestBedWithMockedStability('registerWhenStable:1000');  tick(999);  expect(swRegisterSpy).not.toHaveBeenCalled();  tick(1);  expect(swRegisterSpy).toHaveBeenCalledWith('sw.js', {scope: undefined});}));  it('registers the SW asap (asynchronously) before the app stabilizes`registerWhenStable:0`',fakeAsync(() => {  configTestBedWithMockedStability('registerWhenStable:0');  // Create a microtask.  Promise.resolve();  flushMicrotasks();  expect(swRegisterSpy).not.toHaveBeenCalled();  tick(0);  expect(swRegisterSpy).toHaveBeenCalledWith('sw.js', {scope: undefined});}));  it('registers the SW only when p stabilizes with `registerWhenStable:`',fakeAsync(() => {  const isStableSub = configTestBedWithMockedStability('registerWhenStable:');  isStableSub.next(false);  isStableSub.next(false);  tick();  expect(swRegisterSpy).not.toHaveBeenCalled();  tick(60000);  expect(swRegisterSpy).not.toHaveBeenCalled();  isStableSub.next(true);  tick();  expect(swRegisterSpy).toHaveBeenCath('sw.js', {scope: undefined});}));  it('registers the SW only when the app stabilizes with `registerWhenStable`',fakeAsync(() => {  const isStableSub = configTestBedWithMockedStability('registerWhenStable');  isStableSub.next(false);  isStableSub.next(false);  tick();  expect(swRegisterSpy).not.toHaveBeenCalled();  tick(60000);  expect(swRegisterSpy).not.toHaveBeenCalled();  isStableSub.next(true);  tick();  expect(swRegisterSpy).toHaveBeenCalledWiths', {scope: undefined});}));  it('registers the SW immediatelly (synchronously) with `registerImmediately`', () => {configTestBedWithMockedStability('registerImmediately');expect(swRegisterSpy).toHaveBeenCalledWith('sw.js', {scope: undefined});  });  it('registers the SW after the specified delay with `registerWithDelay:<delay>`',fakeAsync(() => {  configTestBedWithMockedStability('registerWithDelay:100000');  tick(99999);  expect(swRegisterSpy).not.BeenCalled();  tick(1);  expect(swRegisterSpy).toHaveBeenCalledWith('sw.js', {scope: undefined});}));  it('registers the SW asap (asynchronously) with `registerWithDelay:`', fakeAsync(() => {  configTestBedWithMockedity('erWithDelay:');  // Create a microtask.  Promise.resolve();  flushMicrotasks();  expect(swRegisterSpy).not.toHaveBeenCalled();  tick(0);  expect(swRegisterSpy).toHaveBeenCalledWith('sw.js', {scope: undefined});}));  it('registers the SW asap (asynchronously) with `registerWithDelay`', fakeAsync(() => {  configTWithMockedStability('registerWithDelay');  // Create a microtask.  Promise.resolve();  flushMicrotasks();  expect(swRegisterSpy).not.toHaveBeenCalled();  tick(0);  expect(swRegisterSpy).toHaveBeenCalledWith('sw.js', {scope: undefined});}));  it('registers the SW on first emitted value with observable factory function',fakeAsync(() => {  const rrSub = new Subject<void>();  const isStableSub = configTestBedWithMockedStability(() => registerSub.asObservable());  isStableSub.next(true);  tick();  expect(swRegisterSpy).not.toHaveBeenCalled();  registerSub.next();  expect(swRegisterSpy).toHaveBeenCalledWith('sw.js', {scope: undefined});}));  it('throws an error with unknown strategy', ()xpect(() => configTestBedWithMockedStability('registerYesterday'))   .toThrowError('Unknown ServiceWorker registration strategy: registerYesterday');expect(swRegisterSpy).not.toHaveBeenCalled();  });});    });  });});