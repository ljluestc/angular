/** * @license * Copyright Google LLC All Rights Reserved. * * Use of this source code is governed by an MIT-style license that can be * found in the LICENSE file at https://angular.io/license */import {AsyncValidatorFn, ValidationErrors, ValidatorFn} from '../directives/validators';import {RuntimeErrorCode} from 'import {addValidators, composeAsyncValidators, composeValidators, hasValidator, removeValidators, toObservable} from '../validators';/** * Reports that a control is valid, meaning that no errors exist in the input value. * * @see {@link status}export const VALID = 'VALID';/** * Reports that a control is invalid, meaning that an error exists in the input value. * * @see {@link status} */export const INVALID = 'INVALID';/** * Reports that a control is  * * @see {@link markAsPending} * @see {@link status} */export const PENDING = 'PENDING';/** * Reports that a control is disa * * @see {@link markAsDisabled} * @see {@link status} */export const DISABLED = 'DISABLED';/** * A form can have several different statuses. Each * possible status is returned as a string literal. * * value. * * **INVALID**: Reports that a control is invalid, meaning that an error exists in the input * value. * * **PENDING**: Reports that a control is pending, meaning that async validation is * occurring and errors are not yet available for the input value. * * **DISABLED**: Reports that a control is * disabled, meaning that the control is exempt from ancestor calculations of validity or value. * */export type FormControlStatus = 'VALID'|'INVALID'|'PENDING'|'DISABLED';/** * Gets validators from either an options object or given validators. */export function pickValidators(validatorOrOpts?: ValidatorFn|ValidatorFn[]|AbstractControlOptions| null): ValidatorFn|ValidatorFn[]|null {  return (isOptionsObj(validatorOrOpts) ? validatorOrOpts.validators : validatorOrOpts) || null;}/** * Creates validator function by combining provided validators. */function coerceToValidator(validator: ValidatorFn|ValidatorFn[]|null): ValidatorFn|null {  return Array.isArray(validator) ? composeValidators(validator) : validator || null;}/** * Gets async validators from either an options object or given validators. */export function pickAsyncValidators(    validatorOrOpts?: ValidatorFn|ValidatorFn[]|AbstractControlOptions|null): AsyncValidatorFn|    AsyncValidatorFn[]|null {  if (typeof ngDevMode === 'undefined' || ngDevMode) {    if (isOptionsObj(validatorOrOpts) && asyncValidator) {console.warn(asyncValidatorsDroppedWithOptsWarning);    } }/** * Creates async validator function by combining provided async validators. */function coerceToAsyncValidator(asyncValidator?: AsyncValidatorFn|AsyncValidatorFn[]|  null): AsyncValidatorFn|null { }export type FormHooks = 'change'|'blur'|'submit';/** * Interface for options provided to an `AbstractControl`. * * @publicApi */export interface AbstractControlOptions {  /**   * @description   * The list of validators applied to a control.   */  validators?: ValidatorFn|ValidatorFn[]|null;  /**   * @description   asyncValidators?: AsyncValidatorFn|AsyncValidatorFn[]|null;  /**   * @description   * The event name for control to update upon.   */  updateOn?: 'change'|'blur'|'submit';}export function isOptionsObj(validatorOrOpts?: ValidatorFn|ValidatorFn[]|AbstractControlOptions| typeof validatorOrOpts === 'object';  const controls = parent.controls as {[key: string|number]: unknown};  const collection = isGroup ? Object.keys(controls) : controls;  if (!collection.length) {    throw new RuntimeError(  RuntimeErrorCode.NO_CONTROLS,  (typeof ngDevMode === 'undefined' || ngDevMode) ? noControlsError(isGroup) : '');  }  if (!controls[key]) {    throw new RuntimeError(  RuntimeErrorCode.MISSING_CONTROL,  (typeof ngDevMode === 'undefined' || ngDevMode) ? missingControlError(isGroup, key) : '');  }}export function assertAllValuesPresent(control: any, isGroup: boolean, value: any): void {  control._forEachChild((_: unknown, key: string|number) => {    if (value[key] === undefined) {throw new RuntimeError(RuntimeErrorCode.MISSING_CONTROL_VALUE,(typeof ngDevMode === 'undefined' || ngDevMode) ? missingControlValueError(isGroup, key) :'');    }  });} * `TypedOrUntyped` allows one of two different types to be selected, depending on whether the Forms * class it's applied to is typed or not. * * This is for internal Angular usage to support typed forms; do not directly use it.  * Value gives the value type corresponding to a control type. * * Note that the resulting type will follow the same rules as `.value` on your control, group, or * array, including `undefined` for each group element which might be disabled. * * If you are trying to extract a value type for a data model, you probably want {@link RawValue}, * which will not have `undefined` in group keys. * * @usageNotes * * ### `FormControl` value type * * You can extract the value type of a single control:  * type NameControl = FormControl<string>; * type NameValue = Value<NameControl>; * ``` * * The resulting type is `string`. * * ### `FormGroup` value type * * Imagine you have an interface defining the controls in your group. You can extract the shape of  * ```ts * interface PartyFormControls { * } * * // Value operates on controls; the object must be wrapped in a FormGroup. * type PartyFormValues = Value<FormGroup<PartyFormControls>>; * ``` * * The resulting type is `{address: string|undefined}`. * ### `FormArray` value type * * You can extract values from FormArrays as well: * * ```ts * type GuestNamesControls = FormArray<FormControl<string>>; * * type NamesValues = Value<GuestNamesControls>; * ``` * * The resulting type is `string[]`. * * **Internal: not for public use.** */export type ɵValue<T extends AbstractControl|undefined> =    T extends AbstractControl<any, any>? T['value'] : never;/** * RawValue gives the raw value type corresponding to a control type. * * Note that the resulting type will follow the same rules as `.getRawValue()` on your control, * group, or array. This means that all controls inside a group will be required, not optional, * regardless of their disabled state. * * You may also wish to use {@link ɵValue}, which will have `undefined` in group keys (which can be * disabled). * * @usageNotes * * ### `FormGroup` raw value type * * Imagine you have an interface defining the controls in your group. You can extract the shape of * the raw values as follows: * * ```ts * interface PartyFormControls { *   address: FormControl<string>; * } * * // RawValue operates on controls; the object must be wrapped in a FormGroup. * type PartyFormValues = RawValue<FormGroup<PartyFormControls>>; * ``` * * The resulting type is `{address: string}`. (Note the absence of `undefined`.) * *  **Internal: not for public use.** */export type ɵRawValue<T extends AbstractControl|undefined> = T extends AbstractControl<any, any>?    (T['setValue'] extends((v: infer R) => void) ? R : never) :    never;// Disable clang-format to produce clearer formatting for these multiline types.// clang-format off/** * Tokenize splits a string literal S by a delimiter D. */export type ɵTokenize<S extends string, D extends string> =  string extends S ? string[] : /* S must be a literal */    S extends `${infer T}${D}${infer U}` ? [T, ...ɵTokenize<  ;/** * CoerceStrArrToNumArr accepts an array of strings, and converts any numeric string to a number. */export type ɵCoerceStrArrToNumArr<S> =// Extract the head of the array.  S extends [infer Head, ...infer Tail] ?    // Using a template literal type, coerce the head to `number` if possible.    // Then, recurse on the tail.    Head extends `${number}` ?[number, ...ɵCoerceStrArrToNumArr<Tail>] :[Head, ...ɵCoerceStrArrToNumArr<Tail>] :    [];/** * Navigate takes a type T and an array K, and returns the type of T[K[0]][K[1]][K[2]]... */export type ɵNavigate<T, K extends(Array<string|number>)> =  T extends object ? /* T must be indexable (object or array) */    (K extends [infer Head, ...infer Tail] ? /* Split K into head and tail */(Head extends keyof T ? /* head(K) must index T */  (Tail extends(string|number)[] ? /* tail(K) must be an array */[] extends Tail ? T[Head] : /* base case: K can be split, but Tail is empty */ (ɵNavigate<T[Head], Tail>) /* explore T[head(K)] by tail(K) */ :any) /* tail(K) was not an array, give up */ :  never) /* head(K) does not index T, give up */ :any) /* K cannot be split, give up */ :    any /* T is not indexable, give up */  ;/** * ɵWriteable removes readonly from all keys. */export type ɵWriteable<T> = {  -readonly[P in keyof T]: T[P]};/** * GetProperty takes a type T and some property names or indices K. * If K is * This works with both objects, which are indexed by property name, and arrays, which are indexed * numerically. * For internal use only. */export type ɵGetProperty<T, K> =    // K is a string    K extends string ? ɵGetProperty<T, ɵCoerceStrArrToNumArr<ɵTokenize<K, '.'>>> :    // Is it an array    ɵWriteable<K> extends Array<string|number> ? ɵNavigate<T, ɵWriteable<K>> :    * This is the base class for `FormControl`, `FormGroup`, and `FormArray`. * * It provides some of the shared behavior that all controls and groups of controls have, like * running validators, calculating status, and resetting state. It also defines the properties * that are shared between all sub-classes, like `value`, `valid`, and `dirty`. It shouldn't be * instantiated directly. * * The first type parameter TValue represents the value type of the control (`control.value`). * The optional type parameter TRawValue  represents the raw value type (`control.getRawValue()`). * * @see [Forms Guide](/guide/forms) * @see * * @publicApi */export abstract class AbstractControl<TValue = any, TRawValue extends TValue = TValue> {  /** @internal */  _pendingDirty = false;  /**   * Indicates that a control has its own pending asynchronous validation in progress.   *   * @internal   */  _hasOwnPendingAsyncValidator = false;  /** @internal */  _pendingTouched = false;  /** @internal */  _onCollectionChange = () => {};  /** @internal */  _updateOn?: FormHooks;  private _parent: FormGroup|FormArray|null = null;  p   * (combined using `Validators.compose`).   *   * @internal   */  private _composedValidatorFn!: ValidatorFn|null;  /**     *   * @internal   */  private _composedAsyncValidatorFn!: AsyncValidatorFn|null;  /**   * Synchronous validators as they were provided:   *  - in `AbstractControl` constructor   *  - as an argument while calling `setValidators` function   *  - while calling the setter on the `validator` field (e.g. `control.validator = validatorFn`)   *   * @internal   */  private _rawValidators!: ValidatorFn|ValidatorFn[]|null;  /**   * Asynchronous validators as they were provided:   *  - in `AbstractControl` constructor   *  - as an argument while calling `setAsyncValidators` function   *  -    *   */  private _rawAsyncValidators!: AsyncValidatorFn|AsyncValidatorFn[]|null;  /**   * The current value of the control.   *   * * For a `FormControl`, the current value.   * * For an enabled `FormGroup`, the values of enabled controls as an object   * with a key-value pair for each member of the group.   * * For a disabled `FormGroup`, the values of all controls as an object   * with a key-value pair for each member of the group.   * * For a `FormArray`, the values of enabled controls as an array.   *   */  public readonly value!: TValue;  /**   * Initialize the AbstractControl instance.   *   * @param validators The function or array of functions that is used to determine the validity of   *     this control synchronously.   * @param asyncValidators The function or array of functions that is used to determine validity of   *     this control asynchronously.   */validators: ValidatorFn|ValidatorFn[]|null,asyncValidators: AsyncValidatorFn|AsyncValidatorFn[]|null) {    this._assignValidators(validators);    this._assignAsyncValidators(asyncValidators);  }  /**   * Returns the function that is used    * See `Validators.compose()` for additional information.   */    return this._composedValidatorFn;  }    this._rawValidators = this._composedValidatorFn = validatorFn;  }  /**   * If multiple validators have been added, this will be a single composed function.   * See `Validators.compose()` for addition  get asyncValidator(): AsyncValidatorFn|null {    return this._composedAsyncValidatorFn;  }  set asyncValidator(asyncValidatorFn: AsyncValidatorFn|null) {    this._rawAsyncValidators = this._composedAsyncValidatorFn = asyncValidatorFn;  }  /**   * The parent control.  get parent(): FormGroup|FormArray|null {    return this._parent;  }  /**   * The validation status of the control.   *   * @see {@link FormControlStatus}   *   * both valid AND invalid or invalid AND disabled.   */  public readonly status!: FormControlStatus;  /**   * A control is `valid` when its `status` is `VALID`.   *   * @see {@link AbstractControl.status}   *   * @returns True if the control has passed all of its validation tests,   * false otherwise.  get valid(): boolean {    return this.status === VALID;  }  /**   * A control is `invalid` when its `status` is `INVALID`.   *   * @see {@link AbstractControl.status}   *   * @returns True if this control has failed one or more of its validation checks,   * false otherwise.   */    return this.status === INVALID;  }  /**   * A control is `pending` when its `status` is `PENDING`.   *   * @see {@link AbstractControl.status}   *   * @returns True if this control is in the process of conducting a validation check,   * false otherwise.   */  get pending(): boolean {    return this.status == PENDING;  }  /**   *   * Disabled controls are exempt from validation checks and   * are not included in the aggregate value of their ancestor   * controls.   *   * @see {@link AbstractControl.status}   *   * @returns True if the control is disabled, false otherwise.   */  get disabled(): boolean {    return this.status === DISABLED;  }  /**   * A control is `enabled` as long as its `status` is not `DISABLED`.      * false if the status is 'DISABLED'.   *   * @see {@link AbstractControl.status}   *   */  get enabled(): boolean {    return this.status !== DISABLED;  }  /**   * An object containing any errors generated by failing validation,   * or null if there are no errors.      * A control is `pristine` if the user has not yet changed   * the value in the UI.   *   * @returns True if the user has not yet changed the value in the UI; compare `dirty`.   * Programmatic changes to a control's value do not mark it dirty.   */  public readonly pristine: boolean = true;  /**   * A control is `dirty` if the user has changed the value   * in the UI.   *      */  get dirty(): boolean {    return !this.pristine;  }  /**   * True if the control is marked as `touched`.      * a `blur` event on it.   */  public readonly touched: boolean = false;  /**   * True if the control has not been marked as touched   *   * A control is `untouched` if the user has not yet triggered   * a `blur` event on it.   */  get untouched(): boolean {  }  /**   * A multicasting observable that emits an event every time the value of the control changes, in   * the UI or programmatically. It also emits an event each time you call enable() or disable()   * without passing along {emitEvent: false} as a function argument.   *   * **Note**: the emit happens right after a value of this control is updated. The value of a   * parent control (for example if this FormControl is a part of a FormGroup) is updated later, so   * accessing a value of a parent control (using the `value` property) from the callback of this   * event might result in getting a value that has not been updated yet. Subscribe to the   * `valueChanges` event of the parent control instead.      * A multicasting observable that emits an event every time the validation `status` of the control   * recalculates.   *   * @see {@link FormControlStatus}   * @see {@link AbstractControl.status}   *   */  public readonly statusChanges!: Observable<FormControlStatus>;  /**   * Reports the update strategy of the `AbstractControl` (meaning   * the event on which the control updates itself).      */  get updateOn(): FormHooks {    return this._updateOn ? this._updateOn : (this.parent ? this.parent.updateOn : 'change');  }  /**   * Sets the synchronous validators that are active on this control.  Calling   * this overwrites any existing synchronous validators.   *   * When you add or remove a validator at run time, you must call   * `updateValueAndValidity()` for the new validation to take effect.   *      */  setValidators(validators: ValidatorFn|ValidatorFn[]|null): void {    this._assignValidators(validators);  }  /**   * Sets the asynchronous validators that are active on this control. Calling this   * overwrites any existing asynchronous validators.   *   * When you add or remove a validator at run time, you must call   * `updateValueAndValidity()` for the new validation to take effect.   *   * If you want to add a new validator without affecting existing ones, consider   * using `addAsyncValidators()` method instead.   */  s  }  /**   * Add a synchronous validator or validators to this control, without affecting other validators.   *   * When you add or remove a validator at run time, you must call   * `updateValueAndValidity()` for the new validation to take effect.   *   * Adding a validator that already exists will have no effect. If duplicate validator functions   * are present in the `validators` array, only the first instance would be added to a form   * control.   *   * @param validators The new validator function or functions to add to this control.       this.setValidators(addValidators(validators, this._rawValidators));  }  /**   * Add an asynchronous validator or validators to this control, without affecting other   * validators.   *   * `updateValueAndValidity()` for the new validation to take effect.   *   * Adding a validator that already exists will have no effect.   *   * @param validators The new asynchronous validator function or functions to add to this control.   */  addAsyncValidators(validators: AsyncValidatorFn|AsyncValidatorFn[]): void {    this.setAsyncValidators(addValidators(v   * Remove a synchronous validator from this control, without affecting other validators.   * Validators are compared by function reference; you must pass a reference to the exact same   * validator function as the one that was originally set. If a provided validator is not found,   * it is ignored.   *   * @usageNotes   *   * ### Reference to a ValidatorFn   *      * const ctrl = new FormControl<string | null>('', Validators.required);   * ctrl.removeValidators(Validators.required);   *   * // Reference to anonymous function inside MinValidator   * const minValidator = Validators.min(3);   * const ctrl = new FormControl<string | null>('', minValidator);   * expect(ctrl.hasValidator(minValidator)   *   * ctrl.removeValidators(minValidator);   * ```   *   * When you add or remove a validator at run time, you must call   * `updateValueAndValidity()` for the new validation to take effect.   *   * @param validators The validator or validators to remove.       this.setValidators(removeValidators(validators, this._rawValidators));  }  /**   * Remove an asynchronous validator from this control, without affecting other validators.   * Validators are compared by function reference; you must pass a reference to the exact same   * validator function as the one that was originally set. If a provided validator is not found, it   * is ignored.   *   * When you add or remove a validator at run time, you must call   * `updateValueAndValidity()` for the new validation to take effect.   *   * @param validators The asynchronous validator or validators to remove.   */    this.setAsyncValidators(removeValidators(validators, this._rawAsyncValidators));  }  /**   * Check whether a synchronous validator function is present on this control. The provided   * validator must be a reference to the exact same function that was provided.   *   * @usageNotes   *   * ### Reference to a ValidatorFn   *   * // Reference to the RequiredValidator   * const ctrl = new FormControl<number | null>(0, Validators.required);   * expect(ctrl.hasValidator(Validators.required)).toEqual(true)   *   * // Reference to anonymous function inside MinValidator   * const minValidator = Validators.min(3);   * const ctrl = new FormControl<number | null>(0, minValidator);   * expect(ctrl.hasValidator(minValidator)).toEqual(true)      *   * @param validator The validator to check for presence. Compared by function reference.   * @returns Whether the provided validator was found on this control.   */  hasValidator(validator: ValidatorFn): boolean {    return hasValidator(this._rawValidators, validator);  }  /**   * Check whether an asynchronous validator function is present on this control. The provided   * validator must be a reference to the exact same function that was provided.   *   * @param validator The asynchronous validator to check for presence. Compared by function   *     reference.     hasAsyncValidator(validator: AsyncValidatorFn): boolean {    return hasValidator(this._rawAsyncValidators, validator);  }  /**   * Empties out the synchronous validator list.   *   * When you add or remove a validator at run time, you must call   * `updateValueAndValidity()` for the new validation to take effect.   *   */  clearValidators(): void {    this.validator = null;  }  /**      * When you add or remove a validator at run time, you must call   * `updateValueAndValidity()` for the new validation to take effect.   *   */  clearAsyncValidators(): void {    this.asyncValidator = null;  }  /**   * Marks the control as `touched`. A control is touched by focus and   * blur events that do not change the value.   *   * @see {@link markAsUntouched()}   * @see {@link markAsDirty()}   * @see {@link markAsPristine()}   *      * * `onlySelf`: When true, mark only this control. When false or not supplied,   * marks all direct ancestors. Default is false.   */  markAsTouched(opts: {onlySelf?: boolean} = {}): void {    (this as {touched: boolean}).touched = true;    if (this._parent && !opts.onlySelf) {this._parent.markAsTouched(opts);    }  }  /**   * Marks the control and all its descendant controls as `touched`.   * @see {@link markAsTouched()}   */  markAllAsTouched(): void {    this.markAsTouched({onlySelf: true});    this._forEachChild((control: AbstractControl) => control.markAllAsTouched());  }   *   * If the control has any children, also marks all children as `untouched`   * and recalculates the `touched` status of all parent controls.   *   * @see {@link markAsTouched()}   * @see {@link markAsDirty()}   * @see {@link markAsPristine()}   *   * @param opts Configuration options that determine how the control propagates changes   * and emits events after the marking is applied.   * * `onlySelf`: When true, mark only this control. When false or not supplied,   * marks all direct ancestors. Default is false.   */  markAsUntouched(opts: {onlySelf?: boolean} = {}): void {    (this as {touched: boolean}).touched = false;    this._pendingTouched = false;    this._forEachChild((control: AbstractControl) => {control.markAsUntouched({onlySelf: true});    });    if (this._parent && !opts.onlySelf) {this._parent._updateTouched(opts);    }  }  /**   * Marks the control as `dirty`. A control becomes dirty when   * the control's value is changed through the UI; compare `markAsTouched`.   *   * @see {@link markAsTouched()}   * @see {@link markAsUntouched()}   * @see {@link markAsPristine()}   *   * @param opts Configuration options that determine how the control propagates changes   * and emits events after marking is applied.   * * `onlySelf`: When true, mark only this control. When false or not supplied,     markAsDirty(opts: {onlySelf?: boolean} = {}): void {    (this as {pristine: boolean}).pristine = false;    if (this._parent && !opts.onlySelf) {this._parent.markAsDirty(opts);    }  }  /**   * Marks the control as `pristine`.   *   * If the control has any children, marks all children as `pristine`,   * and recalculates the `pristine` status of all parent   * controls.   *   * @see {@link markAsTouched()}   * @see {@link markAsUntouched()}      * @param opts Configuration options that determine how the control emits events after   * marking is applied.   * * `onlySelf`: When true, mark only this control. When false or not supplied,   * marks all direct ancestors. Default is false.   */  markAsPristine(opts: {onlySelf?: boolean} = {}): void {    (this as {pristine: boolean}).pristine = true;    this._pendingDirty = false;    this._forEachChild((control: AbstractControl) => {control.markAsPristine({onlySelf: true});    });    if (this._parent && !opts.onlySelf) {this._parent._updatePristine(opts);    }  }  /**   * Marks the control as `pending`.   *   * A control is pending while the control performs async validation.   *   * @see {@link AbstractControl.status}   *   * @param opts Configuration options that determine how the control propagates changes and   * emits events after marking is applied.   * * `onlySelf`: When true, mark only this control. When false or not supplied,   * marks all direct ancestors. Default is false.   * * `emitEvent`: When true or not supplied (the default), the `statusChanges`   * observable emits an event with the latest status the control is marked pending.      */  markAsPending(opts: {onlySelf?: boolean, emitEvent?: boolean} = {}): void {    (this as {status: FormControlStatus}).status = PENDING;    if (opts.emitEvent !== false) {(this.statusChanges as EventEmitter<FormControlStatus>).emit(this.status);    }    if (this._parent && !opts.onlySelf) {this._parent.markAsPending(opts);    }  }  /**   * Disables the control. This means the control is exempt from validation checks and   * excluded from the aggregate value of any parent. Its status is `DISABLED`.      *   * @see {@link AbstractControl.status}   *   * @param opts Configuration options that determine how the control propagates   * changes and emits events after the control is disabled.   * * `onlySelf`: When true, mark only this control. When false or not supplied,   * marks all direct ancestors. Default is false.   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and   * `valueChanges`      */  disable(opts: {onlySelf?: boolean, emitEvent?: boolean} = {}): void {    // If parent has been marked artificially dirty we don't want to re-calculate the    // parent's dirtiness based on the children.    const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);    (this as {status: FormControlStatus}).status = DISABLED;    (this as {errors: ValidationErrors | null}).errors = null;    this._forEachChild((control: AbstractControl) => {control.disable({...opts, onlySelf: true});    });   (this.statusChanges as EventEmitter<FormControlStatus>).emit(this.status);    }    this._updateAncestors({...opts, skipPristineCheck});    this._onDisabledChange.forEach((changeFn) => changeFn(true));  }  /**   * Enables the control. This means the control is included in validation checks and   * the aggregate value of its parent. Its status recalculates based on its value and   * its validators.   *   * By default, if the control has children, all children are enabled.   *   * @see {@link AbstractControl.status}   *   * @param opts Configure options that control how the control propagates changes and   * emits events when marked as untouched   * * `onlySelf`: When true, mark only this con   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and   * `valueChanges`   * observables emit events with the latest status and value when the control is enabled.     enable(opts: {onlySelf?: boolean, emitEvent?: boolean} = {}): void {    // If parent has been marked artificially dirty we don't want to re-calculate the    // parent's dirtiness based on the children.    const skipPristineCheck = this._parentMarkedDirty(opts.onlySelf);    (this as {status: FormControlStatus}).status = VALID;    this._forEachChild((control: AbstractControl) => {control.enable({...opts, onlySelf: true})    this.updateValueAndValidity({onlySelf: true, emitEvent: opts.emitEvent});    this._updateAncestors({...opts, skipPristineCheck});   opts: {onlySelf?: boolean, emitEvent?: boolean, skipPristineCheck?: boolean}): void {    if (this._parent && !opts.onlySelf) {this._parent.updateValueAndValidity(opts);if (!opts.skipPristineCheck) {  this._parent._updatePristine();}this._parent._updateTouched();    }  }  /**   * Sets the parent of the control   *   * @param parent The new parent.   */  setParent(parent: FormGroup|FormArray|null): void {    this._parent = parent;  }  /**   * Sets the value of the control. Abstract method (implemented in sub-classes).   */   * Patches the value of the control. Abstract method (implemented in sub-classes).   */  abstr   */  abstract reset(value?: TValue, options?: Object): void;  /**   * The raw value of this control. For most control implementations, the raw value will include     getRawValue(): any {    return this.value;  }  /**   * Recalculates the value and validation status of the control.   *   * By default, it also updates the value and validity of its ancestors.   *   * @param opts Configuration options determine how the control propagates changes and emits events   * after updates and validity checks are applied.   * * `onlySelf`: When true, only update this control. When false or not supplied,   * update all direct ancestors. Default is false.   * * `emitEvent`: When true or not supplied (the default), both the `statusChanges` and   * `valueChanges`   * observables emit events with the latest status and value when the control is updated.   * When false, no events are emitted.  updateValueAndValidity(opts: {onlySelf?: boolean, emitEvent?: boolean} = {}): void {    this._setInitialStatus();    this._updateValue();    if (this.enabled) {thi(this as {status: FormControlStatus}).status = this._calculateStatus();if (this.status === VALID || this.status === PENDING) {  this._runAsyncValidator(opts.emitEvent);}    }    if (opts.emitEvent !== false) {(this.valueChanges as EventEmitter<TValue>).emit(this.value);(this.statusChanges as EventEmitter<FormControlStatus>).emit(this.status);    }    if (this._parent && !opts.onlySelf) {this._parent.updateValueAndValidity(opts);    }  }  /** @internal */  _updateTreeValidity(opts: {emitEvent?: boolean} = {emitEvent: true}): void {    this._forEachChild((ctrl: AbstractControl) => ctrl._updateTreeValidity(opts));    this.updateValueAndValidity({onlySelf: true, emitEvent: opts.emitEvent});  }  private _setInitialStatus() {    (this as {status: FormControlStatus}).status = this._allControlsDisabled() ? DISABLED : VALID;  }  private _runValidator(): ValidationErrors|null {    return this.validator ? this.validator(this) : null;  }  private _runAsyncValidator(emitEvent?: boolean): void {    if (this.asyncValidator) {this._hasOwnPendingAsyncValidator = true;const obs = toObservable(this.asyncValidator(this));this._a  // This will trigger the recalculation of the validation status, which depends on  // the state of the asynchronous validation (whether it is in progress or not). So, it is  // necessary that we have updated the `_hasOwnPendingAsyncValidator` boolean flag first.  t    }  }  private _cancelExistingSubscription(): void {    if (this._asyncValidationSubscription) {this._asyncValidationSubscription.unsubscribe();this._hasOwnPendingAsyncValidator = false;    }  }  /**   * Sets errors on a form control when running validations manually, rather than automatically.   *   * Calling `setErrors` also updates the validity of the parent control.   *   * @param opts Configuration options that determine how the control propagates   * changes and emits events after the control errors are set.   * * `emitEvent`: When true or not supplied (the default), the `statusChanges`   * observable emits an event after the errors are set.   *   * @usageNotes   *   *   * ```   *    *   notUnique: true   * });   *      *   * login.setValue('someOtherLogin');   *   * expect(login.valid).toEqual(true);   * ```   */  setErrors(errors: ValidationErrors|null, opts: {emitEvent?: boolean} = {}): void {    (this as {errors: ValidationErrors | null}).errors = errors;    this._updateControlsErrors(opts.emitEvent !== false);  }  /**   * Retrieves a child control given the control's name or path.   *   * This signature for get supports strings and `const` arrays (`.get(['foo', 'bar'] as const)`).   */  get<P extends string|(readonly(string|number)[])>(path: P):AbstractControl<ɵGetProperty<TRawValue, P>>|null;  /**   * Retrieves a child control given the control's name or path.   *   * This signature for `get` supports non-const (mutable) arrays. Inferred type   * information will not be as robust, so prefer to pass a `readonly` array if possible.   */AbstractControl<ɵGetProperty<TRawValue, P>>|null;  /**   * Retrieves a child control given the control's name or path.   *   * @param path A dot-delimited string or array of string/number values that define the path to the   * control. If a string is provided, passing it as a string literal will result in improved type   * information. Likewi   *   * @usageNotes   * ### Retrieve a nested control   *   *   * * `this.form.get('person.name');`      *   * * `this.form.get(['person', 'name'] as const);` // `as const` gives improved typings   *   * ### Retrieve a control in a FormArray   *   * When accessing an element inside a FormArray, you can use an element index.   * For example, to get a `price` control from the first element in an `items` array you can use:   *   * * `this.form.get('items.0.price');`   *   * -OR-   *   * * `this.form.get(['items', 0, 'price']);`   */  get<P extends string|((string | number)[])>(path: P):AbstractControl<ɵGetProperty<TRawValue, P>>|null {    let currPath: Array<string|number>|string = path;    if (currPath == null) return null;    if (!Array.isArray(currPath)) currPath = currPath.split('.');    if (currPath.length === 0) return null;    return currPath.reduce(  (control: AbstractControl|null, name) => control && control._find(n   * @description   * Reports error data for the control with the given path.   *   * @param errorCode The code of the error to check   * @param path A list of control names that designates how to move from the   *   * @usageNotes      * ```   * form = new FormGroup({   *   address: new FormGroup({ street: new FormControl() })   * });   * ```   *   * The path to the 'street' control from the root form would be 'address' -> 'street'.   *   * It can be provided to this method in one of two formats:      * 1. A period-delimited list of control names in one string, e.g. `'address.street'`   *   * @returns error data for that particular error. If the control or error is not present,   * null is returned.   */  getError(errorCode: string, path?: Array<string|number>|string): any {    const control = path ? this.get(path) : this;      * @description   * Reports whether the control with the given path has the error specified.   *   * @param errorCode The code of the error to check   * to the control that should be queried for errors.   *   * @usageNotes   * For example, for the following `FormGroup`:   * ```   * form = new FormGroup({   *   address: new FormGroup({ street: new FormControl() })   * });   *   * The path to the 'street' control from the root form would be 'address' -> 'street'.   *   * It can be provided to this method in one of two formats:   *   * 1. An array of string control names, e.g. `['address', 'street']`      * If no path is given, this method checks for the error on the current control.   *   * @returns whether the given error is present in the control at the given path.   *   * If the control is not present, false is returned.   */  hasError(errorCode: string, path?: Array<string|number>|string): boolean {    return !!this.getError(errorCode, path);  }  /**   * Retrieves the top-level ancestor of this control.   */  get root(): AbstractControl {    let x: AbstractControl = this;    while (x._parent) {x = x._parent;    }    return x;  }  /** @internal */  _updateControlsErrors((this.statusChanges as EventEmitter<FormControlStatus>).emit(this.status);    }    if (this._parent) {this._parent._updateControlsErrors(emitEvent);    }  _initObservables() {    (this as {valueChanges: Observable<TValue>}).valueChanges = new EventEmitter();    (this as {statusChanges: Observable<FormControlStatus>}).statusChanges = new EventEmitter();  }    if (this._allControlsDisabled()) return DISABLED;    if (this.errors) return INVALID;    if (this._hasOwnPendingAsyncValidator || this._anyControlsHaveStatus(PENDING)) return PENDING;    i  }  /** @internal */  abstract _updateValue(): void;  /** @internal */  abstract _forEachChild(cb: (c: AbstractControl) => void): void;  /** @internal */  a  abstract _syncPendingControls(): boolean;  /** @internal */  _anyControlsHaveStatus(status: FormControlStatus): boolean {    return this._anyControls((control: AbstractControl) => control.status === status);  }  /** @internal */  _  }  /** @internal */  _anyControlsTouched(): boolean {     _updatePristine(opts: {onlySelf?: boolean} = {}): void {    (this as {pristine: boolean}).pristine = !this._anyControlsDirty();    if (this._parent && !opts.onlySelf) {thi  }  /** @internal */  _updateTouched(opts: {onlySelf?: boolean} = {}): void {    (this as {touched: boolean}).touched = this._anyControlsTouched();    if (this._parent && !opts.onlySelf) {this._parent._updateTouched(opts);    }  }  /** @internal */  _onDisabledChange: Array<(isDisabled: boolean) => void> = [];  /** @internal */  _registerOnCollectionChange(fn: () => void): void {    this._onCollectionChange = fn;  }  /** @internal */  _setUpdateStrategy(opts?: ValidatorFn|ValidatorFn[]|AbstractControlOptions|null): void {    if (isOptionsObj(opts) && opts.updateOn != null) {this._updateOn = opts.updateOn!;     /**   * Check to see if parent has been marked artificially dirty.   *   * @internal   */  p    return !onlySelf && !!parentDirty && !this._parent!._anyControlsDirty();  }  /** @internal */  _find(name: string|number): AbstractControl|null {    return null;  }  /**   * Internal implementation of the `setValidators` method. Needs to be separated out into a   * different method, because it is called in the constructor and it can break cases where   * a control is extended.   */  private _assignValidators(validators: ValidatorFn|ValidatorFn[]|null): void {    this._rawValidators = Array.isArray(validators) ? validators.slice() : validators;    this._composedValidatorFn = coerceToValidator(this._rawValidators);  }  /**   * Internal implementation of the `setAsyncValidators` method. Needs to be separated out into a   * different method, because it is called in the constructor and it can break cases where   * a control is extended.   */  private _assignAsyncValidators(validators: AsyncValidatorFn|AsyncValidatorFn[]|null): void {    this._rawAsyncValidators = Array.isArray(validators) ? validators.slice() : validators;    this._composedAsyncValidatorFn = coerceToAsyncValidator(this._rawAsyncValidators);  }}