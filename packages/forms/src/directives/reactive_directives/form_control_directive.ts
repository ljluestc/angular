/** * @license * Copyright Google LLC All Rights Reserved. * * Use of this source code is governed by an MIT-style license that can be * found in the LICENSE file at https://angular.io/license */import {ControlValueAccessor, NG_VALUE_ACCESSOR} from '../control_value_accessor';import {disabledAttrWarning} from '../reactive_errors';import {_ngModelWarning, CALL_SET_DISABLED_STATE, cleanUpControl, isPropertyUpdated, selectValueAccessor, SetDisabledStateOption, setUpControl} from '../shared';import {AsyncValidator, AsyncValidatorFn, Validator, ValidatorFn} from '../validators';/** * Token to provide to turn off the ngModel warning on formControl and formControlName. */export const NG_MODEL_WITH_FORM_CONTROL_WARNING =  provide: NgControl,  useExisting: forwardRef(() => FormControlDirective)};/** * @description * Synchronizes a standalone `FormControl` instance to a form control element. * * form directives was deprecated in Angular v6 and is scheduled for removal in * a future version of Angular. * For details, see [Deprecated features](guide/deprecations#ngmodel-with-reactive-forms). * * @see {@link FormControl} * @see {@link AbstractControl} * * @usageNotes * * The following example shows how to register a standalone control and set its value. * * {@example forms/ts/simpleFormControl/simple_form_control_example.ts region='Component'} * * @ngModule ReactiveFormsModule * @publicApi */@Directive({selector: '[formControl]', providers: [formControlBinding], exportAs: 'ngForm'})export class FormControlDirective extends NgControl implements OnChanges, OnDestroy {  /**   * Internal reference to the view model value.   * @nodoc   */  viewModel: any;  /**   * @description   * Tracks the `FormControl` instance bound to the directive.   */  // TODO(issue/24571): remove '!'.  @Input('formControl') form!: FormControl;  /**   * @description   * Triggers a warning in dev mode that this input should not be used with reactive forms.   */  @Input('disabled')  set isDisabled(console.warn(disabledAttrWarning);    }  }  // TODO(kara): remove next 4 properties once deprecation period is over  /** @deprecated as of v6 */  @Input('ngModel') model: any;  /** @deprecated as of v6 */  @Output('ngModelChange') update = new EventEmitter();  /**   * @description   * all instances of FormControlDirective. Used to support warning config of "once".   *   * @internal   */  static _ngModelWarningSentOnce = false;  /**   * @description   * Instance property used to track whether an ngModel warning has been sent out for this   * particular `FormControlDirective` instance. Used to support warning config of "always".   *     _ngModelWarningSent = false;  constructor(@Optional() @Self() @Inject(NG_ASYNC_VALIDATORS) asyncValidators:(AsyncValidator|AsyncValidatorF@Optional() @Inject(NG_MODEL_WITH_FORM_CONTROL_WARNING) private _ngModelWarningConfig: string|null,SetDisabledStateOption) {    super();    this._setValidators(validators);    this._setAsyncValidators(asyncValidators);    this.valueAccessor = selectValueAccessor(this, valueAccessors);  }  /** @nodoc */  ngOnChanges(changes: SimpleChanges): void {    if (this._isControlChanged(changes)) if (previousForm) {  cleanUpControl(previousForm, this, /* validateControlPresenceOnChange */ false);}setUpControl(this.form, this, this.callSetDisabledState);this.form.updateValueAndValidity({emitEvent: false});    }    if (isPropertyUpdated(changes, this.viewModel)) {if (typeof ngDevMode === 'unde}this.form.setValue(this.model);this.viewModel = this.model;    }  }  /** @nodoc */  ngOnDestroy() {    if (this.form) {cleanUpControl(this.form, this, /* validateControlPresenceOnChange */ false);    }  }  /**   * @description   * Returns an array that represents the path from the top-level form to this control.   * Each index is the string name of the control on that level.       return [];  }  /**   * @description   * The `FormControl` bound to this directive.   */  override get control(): FormControl {    return this.form;  }  /**   * @description   * Sets the new value for the view model and emits an `ngModelChange` event.   *   * @param newValue The new value for the view model.   */  override viewToModelUpdate(newValue: any): void {    this.viewModel = newValue;    this.update.emit(newValue);  }  private _isControlChanged(changes: {[key: string]: any}): boolean {   }