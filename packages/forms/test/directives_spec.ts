/** * @license * Copyright Google LLC All Rights Reserved. * * Use of this source code is governed by an MIT-style license that can be * found in the LICENSE file at https://angular.io/license */import {AbstractControl, CheckboxControlValueAccessor, ControlValueAccessor, DefaultValueAccessor, FormArray, FormArrayName, FormControl, FormControlDirective, FormControlName, FormGroup, FormGroupDirective, FormGroupName, NgControl, NgForm, NgModel, NgModelGroup, SelectControlValueAccessor, SelectMultipleControlValueAccessor, ValidationErrors, Validator, Validators} from '@angular/forms';import {selectValueAccessor} from '@angular/forms/src/directives/shared';import {composeValidators} from '@angular/forms/src/validators';import {asyncValidator} from './util';class DummyControlValueAccessor implements ControlValueAccessor {  writtenValue: any;  registerOnChange(fn: any) {}  registerOnTouched(fn: any) {}  writeValue(obj: any): void {  }  validate(c: FormControl): ValidationErrors {return {'custom': tr}{  describe('Form Directives', (  defaultAccessor = new DefaultValueAccessor(null!, null!, null!);});describe('shared', () => {  describe('selectValueAccessor', () => {l});it('should throw when given an empty array', () => {  expect(() => selectValueAccessor(dir, [])).toThrowError();});it('should throw when accessor is not provided as array', () => {  expect(() => selectValueAccessor(dir, {} as any[])) });it('should return the default value accessor when no other provided', () => {  expect(selectValueAccessor(dir, [defaultAccessor])).toEqual(defaultAccessor);});it('should return checkbox accessor whe  expect(selectValueAccessor(dir, [defaultAccessor, checkboxAccessor  ]  const selectAccessor = new SelectControlValueAccessor(null!, null!);  expect(selectValueAccessor(dir, [defaultAccessor, se});it('should return select multiple accessor when provided', () => {  const selectMultipleAccessor = new SelectMultipleControlValueAccessor(null!, null!);  e  ])).toEqual(selectMultipleAccessor);});it('should throw when more than one build-in accessor is provided', () => {  c  expect(() => selectValueAccessor(dir, [checkboxAccessor, selectAccessor])).toThrowError();});it('should return custom accessor when provided', () => {  const customAccessor: ControlValueAccessor = {} as any;  const checkboxAccessor = new CheckboxControlValueAccessor(null!, null!);  e  ])).toEqual(customAccessor);});it('should return custom accessor when provided with select multiple', () => {  c  expect(selectValueAccessor(dir, <any>[defaultAccessor, customAccessor, selectMultipleAccessor  ])).toEqual(customAccessor);});it('should throw when more than one custom accessor is provided', () => {  const customAccessor: ControlValueAccessor = {} as any;  e  });  describe('composeValidators', () => {it('should compose functions', () => {  const dummy1 = () => ({'dummy1': true});  const dummy2 = () => ({'dummy2': true});  const v = composeValidators([dummy1, dummy2])!;  e  const dummy1 = () => ({'dummy1': true});  const v = composeValidators([dummy1, new CustomValidatorDirective()])!;  expect(v(new FormControl(''))).toEqual({'dummy1': true, 'custom': true});});  });});  let formModel: FormGroup;  let loginControlDir: FormControlName;  beforeEach(() => {form = new FormGroupDirective([], []);formModel = new FormGroup({  '  new FormGroup({'password': new FormControl(), 'passwordConfirm': new FormControl()})});form.form = formModel;loginControlDir = new FormControlName(form, [Validators.required], [asyncValidator('expected')], [defaultAccessor], null);loginControlDir.name = 'login';loginControlDir.valueAccessor = new DummyControlValueAccessor();  }expect(form.value).toBe(formModel.value);expect(form.valid).toBe(formModel.valid);expect(form.invalid).toBe(formModel.invalid);expect(form.pending).toBe(formModel.pending);expect(form.errors).toBe(formModel.errors);expect(form.pristine).toBe(formModel.pristine);expexpect(form.untouched).toBe(formModel.untouched);expect(form.statusChanges).toBe(formModel.statusChanges);expect(form.valueChanges).toBe(formModel.valueChanges);  });  it('should reexport control methods', () => {expecexpect(form.hasError('required')).toBe(formModel.hasError('required'));expect(form.getError('required')).toBe(formModel.getError('required'));  });  describe('addControl', () => {it('should throw when no control found', () => {  const dir = new FormControlName(form, null!, null!, [defaultAccessor], null);  dir.name = 'invalidName';  expect(() => form.addControl(dir))  .  const dir = new FormControlName(form, null!, null!, null!, null);  dir.name = 'login';  expect(() => form.addControl(dir))  .toThrowError(new RegExp(  `NG01203: No value accessor for form control name: 'login'. Find more at https://angular.io/errors/NG01203`));});it('should throw when no value accessor with path', () => {  const group = new FormGroupName(form, null!, null!);  c  dir.name = 'password';  expect(() => form.addControl(dir))  .toThrowError(new RegExp(  `NG01203: No value accessor for form control path: 'passwords -> password'. Find more at https://angular.io/errors/NG01203`));});it('should set up validators', fakeA expect(formModel.hasError('required', ['login'])).toBe(true); expect(formModel.hasError('async', ['login'])).toBe(false); (<FormControl>formModel.get('login')).setValue('invalid value'); // sync validator passes, running async validators expect(formModel.pending).toBe(true); tick(); expect(formModel.hasError('required', ['login'])).toBe(false); expect(formModel.hasError('async', ['login'])).toBe(true);   }));it('should write value to the DOM', () => {  (<FormControl>formModel.get(['login'])).setValue('initValue');  form.addControl(loginControlDir);  expect((<any>loginControlDir.valueAccessor).writtenValue).toEqual('initValue');});it('should add the directive to the list of directives included in the form', () => {  form.addControl(logi});  });  describe('addFormGroup', () => {const matchingPasswordsValidator = (g: AbstractControl) => {  const controls = (g as FormGroup).controls;  if   } else {return null;  }};it('should set up validator', fakeAsync(() => { const group = new FormGroupName( form, [matchingPasswordsValidator], [asyncValidator('expected')]); group.name = 'passwords'; form.addFormGroup(group); (<FormControl>formModel.get(['passwords', 'password'])).setValue('somePassword'); (<FormControl>formModel.get([   'passwords', 'passwordConfirm' ])).setValue('someOtherPassword'); // sync validators are set expect(formModel.hasError('differentPasswords', ['passwords'])).toEqual(true); (<FormControl>formModel.get([   'passwords', 'passwordConfirm' ])).   }));  });  describe('removeControl', () => {it('should remove the directive to the list of directives included in t  form.removeControl(loginControlDir);  expect(form.directives).toEqual([]);});  });  form.addControl(loginControlDir);  (<FormControl>formModel.get(['login'])).setValue('new value');  form.ngOnChanges({});  expect((<any>loginControlDir.valueAccessor).writtenValue).toEqual('new value');});it('should set up a sync validator', () => {  const formValidator = (c: AbstractControl) => ({'custom': true});  const f = new FormGroupDi  f.ngOnChanges({'form': new SimpleChange(null, null, false)});  expect(formModel.errors).toEqual({'custom': true});});it('should set up an async validator', fakeAsync(() => { co f.ngOnChanges({'form': new SimpleChange(null, null, false)}); tick(); expect(formModel.errors).toEqual({'async': true});   }));  });  let form: NgForm;  let formModel: FormGroup;  let loginControlDir: NgModel;  lformModel = form.form;personControlGroupDir = new NgModelGroup(form, [], []);personControlGroupDir.name = 'person';loginControlDir = new NgModel(personControlGroupDir, null!, null!, [defaultAccessor]);loginControlDir.name = 'login';loginControlDir.valueAccessor = new DummyControlValueAccessor();  });  it('should reexpoexpect(form.value).toBe(formModel.value);expect(form.valid).toBe(formModel.valid);expect(form.invalid).toBe(formModel.invalid);expexpect(form.pristine).toBe(formModel.pristine);expect(form.dirty).toBe(formModel.expect(form.untouched).toBe(formModel.untouched);expect(form.statusChanges).toBe(formModel.statusChanges);expect(form.status).toBe(formModel.status);expect(form.disabled).toBe(formModel.disabled);  });  it('should reexport control methods', () => {expect(form.hasError('required')).toBeexpect(f  });  describe('addControl & addFormGroup', () => {it('should create a control with the given name', fakeAsync(() => { form.a   }));// should update the form's value and validity  });  describe('removeControl & removeFormGroup', () => { form.addFormGroup(personControlGro form.removeControl(loginControlDir); flushMicrotasks(); expect(formModel.get(['person'])).toBeNull(); ex  });  it('should set up sync validator', fakeAsync(() => {   const formValidator = () => ({'custom': true});   const f = new NgForm([formValidator], []);   tick();   expect(f.form.errors).toEqual({'custom': true}); }));  it('should set up async validator', fakeAsync(() => {   co});describe('FormGroupName', () => {  let formModel: FormGroup;  let controlGroupDir: FormGroupName;  beforeEach(() => {formModel = new FormGroup({'login': new FormControl(null)});const parent = new FormGroupDirective([], []);parent.form = new FormGroup({'group': formModel});controlGroupDir = new FormGroupName(parent, [], []);controlGroupDir.name = 'group';  });  it('should reexport control properties', () => {exexpect(controlGroupDir.valid).toBe(formModel.valid);expect(controlGroupDir.invalid).toBe(formModel.invalid);expect(controlGroupDir.pending).toBe(formModel.pending);expect(controlGroupDir.errors).toBe(formModel.errors);expect(controlGroupDir.priexpect(controlGroupDir.touched).toBe(formModel.touched);expect(controlGroupDir.untouched).toBe(formModel.untouched);expect(controlGroupDir.statusChanges).toBe(formModel.statusChanges);expect(controlGroupDir.status).toBeexpect(controlGroupDir.disabled).toBe(formModel.disabled);expect(controlGroupDir.enabled).toBe(formModel.enabled);expect(controlGroupDir.hasError('required')).toBe(formModel.hasError('required'));expect(controlGroupDir.getError('required')).toBe(formModel.getError('required'));formModel.setErrors({required: true});expect(controlGroupDir.hasErro  });});describe('FormArrayName', () => {  let foformModel = new FormArray([new FormControl('')]);parent.form = new FormGroup({'array': formModel});formA  });  it('should reexport control properties', () => {expect(formArrayDir.control).toBe(formModel);expect(formArrayDir.value).toBe(formModel.value);expect(formArrayDir.valid).toBe(formModel.valid);expect(formArrayDir.invalid).toBe(formModel.invalid);expect(formArrayDir.pending).toBe(formModel.pending);expecexpect(formArrayDir.dirty).toBe(formModel.dirty);expect(formArrayDir.touched).toBe(formModel.touched);expect(formArrayDir.status).toBe(foexpect(formArrayDir.disabled).toBe(formModel.disabled);  });  it('should reexpexpect(formArrayDir.getError('required')).toBe(formModel.getError('required'));formModel.setErrors({required: true});exp  });});describe('FormControlDirective', () => {  let controlDir: FormControlDirective;  let control: FormControl;  const checkProperties = function(control: FormControl) {expect(controlDir.value).toBe(control.value);expexpect(controlDir.pending).toBe(control.pending);expect(controlDir.errors).toBe(control.errors);expect(controlDir.pristine).toBe(control.pristine);expect(controlDir.dirty).toBe(control.dirty);expect(cexpect(controlDir.status).toBe(control.status);expect(controlDir.valueChanges).toBe(control.valueChanges);expect(controlDir.disabled).toBe(control.disabled);expcontrolDir = new FormControlDirective([Validators.required], [], [defaultAccessor], null);controlDir.valueAccessor = new DummyControlValueAccessor();control = new FormControl(null);controlDir.form = control;  });  it('should reexport control properties', () => {checkProperties(control);expect(controlDir.hasError('required')).toBe(control.hasError('required'));expect(controlDir.getError('required')).toBe(control.getError('required'));control.setErrors({required: true});expect(controlDir.hasE  });  it('should reexport new control properties', () => {const newControl = new FormControl(nulcontrolDir.ngOnChanges({'form': new SimpleChange(control, newControl, false)});checkProperties(newControl);  });  it('should set up validator', () => {expect(control.valid).toBe(true);// this will add the required validator and recalculate the validitycontr});describe('NgModel', () => {  let ngModel: NgModel;  let control: FormControl;  beforeEach(() => {ngModel = new NgModel(null!, [Validators.required], [asyncValidator('expected')], [defaultAccessor]);ngModel.valueAccessor = new DummyControlValueAccessor();control = ngModel.control;  });  it('should reexport control properties', () => {expect(ngModel.control).toBe(control);expect(ngModel.value).toBe(control.value);expect(ngModel.valid).toBe(control.valid);expect(ngModel.invalid).toBe(control.invalid);expect(ngModel.pending).toBe(control.pending);expect(ngModel.errors).toBe(control.errors);expect(ngModel.pristine).toBe(control.pristine);expect(ngModel.dirty).toBe(control.dirty);expecexpect(ngModel.statusChanges).toBe(control.statusChanges);expect(ngModel.status).toBe(control.status);expect(ngModel.valueChanges).toBe(control.valueChanges);expect(ngModel.enabled).toBe(control.enabled);  });  it('should reexport control methods', () => {expect(ngModel.hasError('required')).toBe(control.hasError('required'));expecexpect(ngModel.getError('required')).toBe(control.getError('required'));  });  it('should throw when no value accessor with named control', () => {const namedDir = new NgModel(null!, null!, null!, null!);namedDir.name = 'one';expect(() =>`NG01203: No value const unnamedDir = new NgModel(null!, null!, null!, null!);expect(() => unnamedDir.ngOnChanges({})).toThro  });  it('should set up validator', fakeAsync(() => {   //   tick();   expect(ngModel.control.errors).toEqual({'required': true});   ngModel.control.setValue('someValue');   tick();   expect(ngModel.control.errors).toEqual({'async': true}); }));  it('should mark as disabled properly', fakeAsync(() => {   ngModel.ngOnChanges({isDisabled   expect(ngModel.control.disabled).toEqual(false);   ngModel.ngOnChanges({isDisabled: new SimpleChange('', null, false)});   tick();   tick();   tick();   expect(ngModel.control.disabled).toEqual(false);   ngModel.ngOnChanges({isDisabled: new SimpleChange('', 0, false)});   tick   tick();   ex   expect(ngModel.control.disabled).toEqual(true);   ngModel.ngOnChanges({isDisabled: new SimpleChange(null, true, false)});   tick();   expect(ngModel.control.disabled).toEqual(t   expect(});describe('FormControlName', () => {  letformModel = new FormControl('name');const parent = new FormGroupDirective([], []);parent.form = new FormGroup({'name': formModel});controlNam  });  it('should reexport control properties', () => {expect(controlNameDir.control).toBe(formModel);expexpect(controlNameDir.invalid).toBe(formModel.invalid);expect(controlNameDir.pending).toBe(formModel.pending);expect(controlNameDir.errors).toBe(foexpect(controlNameDir.dirty).toBe(formModel.dirty);expect(controlNameDir.touched).toBe(formModel.touched);expect(controlNameDir.statusChanges).toBe(formModel.statusChanges);expect(controlNameDir.status).toBe(formModel.status);expect(controlNameDir.valueChanges).toBe(formModel.valueChanges);expect(controlNameDir.disabled).toBe(formModel.disabled);expecexpect(controlNameDir.hasError('required')).toBe(formModel.hasError('required'));expect(controlNameDir.getError('required')).toBe(formModel.getError('required'));formModel.setErrors({required: true});expect(controlNameDir.hasError('required')).toBe(formModel.hasError('required'));expect(controlNameDir.getError('required')).toBe(formModel.getError('required'));  });});  });}