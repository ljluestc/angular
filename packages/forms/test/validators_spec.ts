/** * @license * Copyright Google LLC All Rights Reserved. * * Use of this source code is governed by an MIT-style license that can be * found in the LICENSE file at https://angular.io/license */import {Observable, of, timer} from 'rxjs';import {first, map} from 'rxjs/operators';import {normalizeValidators} from '../src/validators';(function() {function validator(key: string, error: any): ValidatorFn {  return (c: AbstractControl) => {r[key] = error;  };}class AsyncValidatorDirective implements AsyncValidator {  constructor(private expected: string, private error: any) {}  validate(c: any): Observable<ValidationErrors> {return new Observable((obs: any) => {  const error = this.expected !== c.value ? this.error : null;  obs.next(error);  obs.complete();}}describe('Validators', () => {  describe('min', () => {  expect(Validators.min(2)(new FormControl(''))).toBeNull();});it('should not error on null', () => {  expect(Validators.min(2)(new FormControl(null))).toBeNull();});it('should not error on undefined', () => {  expect(Validators.min(2)(new FormControl(undefined))).toBeNull();});it('should return null if NaN after parsing', () => {  expect(Validators.min(2)(new FormControl('a'))).toBeNull();}});it('should return a validation error on small values converted from strings', () => {  expect(Validators.min(2)(new FormControl('1'))).toEqual({'min': {'min': 2, 'actual': '1'}});});it('should not error on small float number validation', () => {  expect(Validators.min(1.20)(new FormControl(1.25))).toBeNull();});});it('should return a validation error on big values', () => {  expect(Validators.min(1.25)(new FormControl(1.20))).toEqual({'mi});it('should not error on big values', () => {  expect(Validators.min(2)(new FormControl(3))).toBeNull();});});it('should not error on equal values when value is string', () => {  expect(Validators.min(2)(new FormControl('2'))).toBeNull();});'min': {'min': '2', 'actual': 1}  });});});it('should return null if min value is null', () => {  expect(Validators.min(null as any)(new FormControl(3))).toBeNull();});it('should not error on an empty string', () => {  expect(Validators.max(2)(new FormControl(''))).toBeNull();});});it('should not error on undefined', () => {  expect(Validators.max(2)(new FormControl(undefined))).toBeNull();});});it('should not error on small float number validation', () => {  expect(Validators.max(1.20)(new FormControl(1.15))).toBeNull();});it('should not error on equal float values', () => {  expect(Validators.max(1.25)(new FormControl(1.25))).toBeNull();});'max': {'max': 1.25, 'actual': 1.30}  });});});it('should return a validation error on big values converted from strings', () => {  expect(Validators.max(2)(new FormControl('3'))).toEqual({'max': {'max': 2, 'actual': '3'}});});});it('should not error on equal values', () => {  expect(Validators.max(2)(new FormControl(2))).toBeNull();});});it('should validate as expected when max value is a string', () => {  expect(Validators.max('2' as any)(new FormControl(3))).toEqual({'max': {'max': '2', 'actual': 3}  });});});it('should return null if max value is null', () => {  expect(Validators.max(null as any)(new FormControl(3))).toBeNull();});  describe('required', () => {it('should error on an empty string', () => {  expect(Validators.required(new FormControl(''))).toEqual({'required': true});});it});it('should not error on undefined', () => {  expect(Validators.required(new FormControl(undefined))).toEqual({'required': true});});it('should not error on a non-empty string', () => {  e  expect(Validators.required(new FormControl(0))).toBeNull();});it('should error on an empty array',     expect(Validators.required(new FormControl({id: 1, length: 0, width: 0}))).toBeNull();});  }   () => expect(Validators.requiredTrue(new FormControl(false))).toEqual({'required': true}));it('should not error on true',   () => expect(Validators.requiredTrue(new FormControl(true))).toBeNull());  }   () => expect(Validators.email(new FormControl(''))).toBeNull());it('should not error on null',   () => expect(Validators.email(new FormControl(null))).toBeNull());it('should error on invalid email',     });  describe('minLength', () => {it('should not error on an empty string', () => {  e  expect(Validators.minLength(2)(new FormControl(null))).toBeNull();});it('should not error on undefined', () => {  expect(Validators.minLength(2)(new FormControl(undefined))).toBeNull();});it('should not error on valid strings', () => {  e  expect(Validators.minLength(2)(new FormControl('a'))).toEqual({'minlength': {'requiredLength': 2, 'actualLength': 1}  }  const fa = new FormArray([new FormControl(''), new FormControl('')]);  expect(Validators.minLength(2)(fa)).toBeNull();});  expect(Validators.minLength(2)(fa)).toEqual({'minlength': {'requiredLength': 2, 'actualLength': 1}  }  expect(Validators.minLength(1)(new FormControl(0))).toBeNull();  expect(Validators.minLength(1)(new FormControl(1))).toBeNull();  e});it('should trigger validation for an object that contains numeric length property', () => {  const value = {length: 5, someValue: [1, 2, 3, 4, 5]};  e'minlength': {'requiredLength': 10, 'actualLength': 5}  });});it('should return null when passing a boolean', () => {  expect(Validators.minLength(1)(new FormControl(true))).toBeNull();  e  });  describe('maxLength', () => {it('should not error on an empty string', () => {  e  expect(Validators.maxLength(2)(new FormControl(null))).toBeNull();});it('should not error on undefined', () => {  expect(Validators.maxLength(2)(new FormControl(undefined))).toBeNull();});it});it('should error on long strings', () => {  expect(Validators.maxLength(2)(new FormControl('aaa'))).toEqual({'maxlength': {'requiredLength': 2, 'actualLength': 3}  });});  expect(Validators.maxLength(2)(fa)).toBeNull();});it('should error when FormArray has invalid length', () => {  c'maxlength': {'requiredLength': 1, 'actualLength': 2}  });});  expect(Validators.maxLength(1)(new FormControl(1))).toBeNull();  expect(Validators.maxLength(1)(new FormControl(-1))).toBeNull();  e  const value = {length: 5, someValue: [1, 2, 3, 4, 5]};  expect(Validators.maxLength(10)(new FormControl(value))).toBeNull();  e  });});it('should return null when passing a boolean', () => {  expect(Validators.maxLength(1)(new FormControl(false))).toBeNull();});it('should not error on an empty string', () => {  expect(Validators.pattern('[a-zA-Z ]+')(new FormControl(''))).toBeNull();});it('should not error on null', () => {  exp  expect(Validators.pattern('[a-zA-Z ]+')(new FormControl(undefined))).toBeNull();});it('should not error on null value and "null" pattern', () => {  expect(Validators.pattern('null')(new FormControl(null))).toBeNull();   () => expect(Validators.pattern('[a-zA-Z ]*')(new FormControl('aaAA'))).toBeNull());it('should error on failure to match string', () => {  expect(Validators.pattern('[a-zA-Z ]*')(new FormControl('aaa0'))).toEqual({'patt});it('should accept RegExp object', () => {  const pattern: RegExp = new RegExp('[a-zA-Z ]+');  expect(Validators.pattern(pattern)(new FormControl('aaAA'))).toBe  const pattern: RegExp = new RegExp('^[a-zA-Z ]*$');  expect(Validators.pattern(pattern)(new FormControl('aaa0'))).toEqua  });});it('should not error on "null" pattern',   () => expect(Validators.pattern(undefined!)(new FormControl('aaAA'))).toBeNull());it('should work with pattern string containing both boundary symbols',   () => expect(Validators.pattern('^[aA]*$')(new FormControl('aaAA'))).toBeNull());it('should work with pattern string containing only start boundary symbols',   ()   () => expect(Validators.pattern('[aA]*')(new FormControl('aaAA'))).toBeNull());  });  describe('compose', () => {it('should return null when given null', () => {  e  const c = Validators.compose([validator('a', true), validator('b', true)])!;  expect(c(new FormControl(''))).toEqual({'a': true, 'b': true});});  expect(c(new FormControl(''))).toEqual({'a': 2});});it('should return null when no errors', () => {  c});it('should ignore nulls', () => {  const c = Validators.compose([null!, Validators.required])!;  e  });  describe('composeAsync', () => {describe('promises', () => {  function promiseValidator(response: {[key: string]: any}): AsyncValidatorFn {return (c: AbstractControl) => {  c};  }  it('should return null when given null', () => {expect(Validators.composeAsync(null!)).toBeNull();  }   [promiseValidator({'one': true}), promiseValidator({'two': true})])!;   let errorMap: {[key: string]: any}|null = null;   (v(new FormControl('invalid')) as Observable<ValidationErrors|null>)   .pipe(first())   .subscribe((errors: {[key: string]: any}|null) => errorMap = errors);   tick();   expect(errorMap!).toEqual({'one': true, 'two': true}); })   [new AsyncValidatorDirective('expected', {'one': true})]);   const validatorFn = Validators.composeAsync(normalizedValidators)!;   let errorMap: {[key: string]: any}|null = null;   (validatorFn(new FormControl('invalid')) as Observable<ValidationErrors|null>)   .pipe(first())   .subscribe((errors: {[key: string]: any}|null) => errorMap = errors);      const v = Validators.composeAsync([promiseValidator({'one': true})])!;   let errorMap: {[key: string]: any}|null = undefined!;   (v(new FormControl('expected')) as Observable<ValidationErrors|null>)   .pipe(first())   .subscribe((errors: {[key: string]: any}|null) => errorMap = errors);   tick();   expect(errorMap).toBeNull(); }));  it('should ignore nulls', fakeAsync(() => {      .pipe(first())   .subscribe((errors: {[key: string]: any}|null) => errorMap = errors);   tick();   expect(errorMap!).toEqual({'one': true}); }));});dereturn (c: AbstractControl) => {  const res = c.value != 'expected' ? response : null;  return of(res);};expect(Validators.composeAsync(null!)).toBeNull();  });  it('should collect errors from all the validators', () => {con(v(new FormControl('invalid')) as Observable<ValidationErrors|null>).pipe(first()).suconst normalizedValidators = normalizeValidators<AsyncValidatorFn>([new AsyncValidatorDirective('expected', {'one': true})]);con.pipe(first()).subscribe((errors: {[key: string]: any}|null) => errorMap = errors)!;expect(errorMap!).toEqual({'one': true});  });  it('should return null when no errors', () => {const v = Validators.composeAsync([observableValidator({'one': true})])!;let errorMap: {[key: string]: any}|null = undefined!;(v(.subscribe((errors: {[key: string]: any}|null) => errorMap = errors);expect(errorMap).toBeNull();  });  it('should ignore nulls', () => {const v = Validators.composeAsync([observableValidator({'one': true}), null!])!;let errorMap: {[key: string]: any}|null = null;(v(.subscribe((errors: {[key: string]: any}|null) => errorMap = errors);expect(errorMap!).toEqual({'one': true});  });  it('should wait for all validators before setting errors', fakeAsync(() => {   function getTimerObs(time: number, errorMap: {[key: string]: any}): AsyncValidatorFn { return (c: AbstractControl) => {   return timer(time).pipe(map(() => errorMap)); };   [getTimerObs(100, {one: true}), getTimerObs(200, {two: true})])!;   let errorMap: {[key: string]: any}|null|undefined = undefined;   (v(new FormControl('invalid')) as Observable<ValidationErrors|null>)   .pipe(first())   .subscribe((errors: {[key: string]: any}|null) => errorMap = errors);   tick(100);   expect(errorMap).not.toBeDefined(      .withContext(`Expected errors to merge once all validators resolved.`)   .toEqual({one: true, two: true}); }));});  });});})(