/** * @license * Copyright Google LLC All Rights Reserved. * * Use of this source code is governed by an MIT-style license that can be * found in the LICENSE file at https://angular.io/license */function otherAsyncValidator() {  return Promise.resolve({'other': true});  return null;  it('should default the value to null', () => {const c = new FormControl();expect(c.value).toBe(null);   const control = new FormControl('');  expect(control.touched).toBe(false); });  });  describe('boxed values', () => {it('should support valid boxed values on creation', () => {  const c = new FormControl({value: 'some val', disabled: true}, null!, null!);  exp  expect(c.status).toBe('DISABLED');});it('should not treat objects as boxed values when `disabled` field is present, but `value` is missing',   () => { const c = new FormControl({disabled: true}); expect(c.value).toEqual({disabled: true}); expect(c.disabled).toBe(false);   });it('should honor boxed value with disabled control when validating', () => {  con  expect(c.valid).toBe(false);  expect(c.status).toBe('DISABLED');});it('should not treat objects as boxed values if they have more than two props', () => {  const c: FormControl =  new FormControl({value: '', disabled: true, test: 'test'} as any, null!, null!);  expect(c.value).toEqual({value: '', disabled: true, test: 'test'});  e  const c = new FormControl({value: '', test: 'test'}, null!, null!);  expect(c.value).toEqual({value: '', test: 'test'});  expect(c.disabled).toBe(false);});  });  describe('updateOn', () => {it('sh  expect(c.updateOn).toEqual('change');});it('should default to on change with an options obj', () => {  const c = new FormControl('', {validators: Validators.required});  expect(c.updateOn).toEqual('change');});it('should set updateOn when updating on blur', () => {  c});describe('in groups and arrays', () => {  it('should default to group updateOn when not set in control', () => {const g =new FormGroup({one: new FormControl(), two: new FormControl()}, {updateOn: 'blur'});expect(g.get('one')!.updateOn).toEqual('blur');expect(g.get('two')!.updateOn).toEqual('blur');  }expect(a.get([1])!.updateOn).toEqual('blur');  });  it('should set updateOn with nested groups', () => {const g = new FormGroup({  group: new FormGroup({one: new FormControl(), two: new FormControl()}),},expect(g.get('group.two')!.updateOn).toEqual('blur');expect(g.get('group')!.updateOn).toEqual('blur');  });  it('should set updateOn with nested arrays', () => {const g = new FormGroup({},{updateOn: 'blur'});expect(g.get(['arr', 0])!.updateOn).toEqual('blur');expect(g.get(['arr', 1])!.updateOn).toEqual('blur');expconst g = new FormGroup({one: new FormControl('', {updateOn: 'change'}), two: new FormControl()},{updateOn: 'blur'});expect(g.get('one')!.updateOn).toEqual('change');expconst g = new FormGroup({  group: new FormGroup(  {one: new FormControl('', {updateOn: 'change'}), two: new FormControl()},  {updateOn: 'blur'}),  three: new FormControl()});expect(g.get('group.one')!.updateOn).toEqual('change');expecexpect(g.get('three')!.updateOn).toEqual('change');  });  });  describe('validator', () => {it('should run validator with the initial value', () => {  con});it('should rerun the validator when the value changes', () => {  const c = new FormControl('value', Validators.required);  c.setValue(null);  expect(c.valid).toEqual(false);});it('should support arrays of validator functions if passed', () => {  const c = new Form  expect(c.valid).toEqual(false);  c.setValue('aaa');  expect(c.valid).toEqual(true);});it('should support single validator from options obj', () => {  con  expect(c.errors).toEqual({required: true});  c.setValue('value');  expect(c.valid).toEqual(true);});it('should support multiple validators from options obj', () => {  const c: FormControl =  new FormControl(null, {validators: [Validators.required, Validators.minLength(3)]});  expect(c.valid).to  expect(c.valid).toEqual(false);  expect(c.errors).toEqual({minlength: {requiredLength: 3, actualLength: 2}});  c.setValue('aaa');  expect(c.valid).toEqual(true);});it  expect(c.valid).toEqual(true);});it('should support an empty options obj', () => {  const c = new FormControl(null, {});  expect(c.valid).to  const c = new FormControl(null, Validators.required);  expect(c.errors).toEqual({'required': true});});it  expect(c.valid).toEqual(true);  c.setValidators(Validators.required);  c.setValue(null);  expect(c.valid).toEqual(false);  c.setValue('abc');  expect(c.valid).toEqual(true);});it('should set multiple validators from array', () => {  const c = new FormControl('');  expect(c.valid).toEqual(true);  c.setValidators([Validators.minLength(5), Validators.required]);  c.setValue('');  expect(c.valid).toEqual(false);  c.setValue('abc');  e});it('should override validators using `setValidators` function', () => {  const c = new FormControl('');  expect(c.valid).toEqual(true);  c.setValidators([Validators.minLength(5), Validators.required]);  c.setValue('');  expect(c.valid).toEqual(false);  c.setValue('abc');  expect(c.valid).toEqual(false);  c.setValue('abcde');  expect(c.valid).toEqual(true);  // Define new set of validators, overriding previously applied ones.  c.s  expect(c.valid).toEqual(true);});it('should not mutate the validators array when overriding using setValidators', () => {  const control = new FormControl('');  const originalValidators = [Validators.required];  control.setValidators(originalValidators);  c  const c = new FormControl('');  expect(c.valid).toEqual(true);  // Define new set of validators, overriding previously applied ones.  c.validator = Validators.compose([Validators.minLength(5), Validators.required]);  c.setValue('');  expect(c.valid).toEqual(false);  c.setValue('abc');  e  c.validator = Validators.compose([Validators.maxLength(2)]);  c.setValue('abcdef');  expect(c.valid).toEqual(false);  c.setValue('a');  expect(c.valid).toEqual(true);});it('should clear validators',   expect(c.valid).toEqual(false);  c.clearValidators();  expect(c.validator).toEqual(null);  c.setValue('');  e  const c = new FormControl('', Validators.required);  expect(c.valid).toEqual(false);  c.clearValidators();  expect(c.validator).toEqual(null);  c.setValidators([Validators.required]);  expect(c.validator).not.toBe(null);  const c = new FormControl('', Validators.required);  expect(c.hasValidator(Validators.required)).toEqual(true);  c.removeValidators(Validators.required);  e});it('should check presence of and remove a validator set with addValidators', () => {  const c = new FormControl('');  expect(c.hasValidator(Validators.required)).toEqual(false);  c.addValidators(Validators.required);  expect(c.hasValidator(Validators.required))});it('should check presence of and remove multiple validators set at the same time', () => {  const c = new FormControl('3');  const minValidator = Validators.min(4);  expect(c.hasValidator(Validators.required)).toEqual(true);  expect(c.hasValidator(minValidator)).toEqual(true);  c.removeValidators([Validators.required, minValidator]);  e});it('should be able to remove a validator added multiple times', () => {  const c = new FormControl('', Validators.required);  c.addValidators(Validators.required);  c  expect(c.hasValidator(Validators.required)).toEqual(false);});it('should not mutate the validators array when adding/removing sync validators', () => {  const originalValidators = [Validators.required];  c  expect(originalValidators.length).toBe(1);});it('should not mutate the validators array when adding/removing async validators', () => {  const firstValidator = asyncValidator('one');  c  const control = new FormControl('', null, originalValidators);  control.addAsyncValidators(secondValidator);  expect(originalValidators.length).toBe(1);  control.removeAsyncValidators(firstValidator);  expect(originalValidators.leng   () => { const c = new FormControl('1', minValidator); expect(c.hasValidator(minValidat   });  });  describe('asyncValidator', () => {it( tick(); expect(c.valid).toEqual(false); expect(c.errors).toEqual({'async': true});   }));it('should support valida tick(); expect(c.valid).toEqual(false);   }));it('should rerun the validator when the value changes', fakeAsync(() => { const c = new FormControl('value   }));it('should run the async validator only when the sync validator passes', fakeAsync(() => { const c = new FormControl('', Va tick(); expect(c.errors).toEqual({'async': true});   }));it('should mark the control as pending while running the async validation', fakeAsync(() => { co const c = new FormControl('', null!, asyncValidator('expected', {'long': 200, 'expected': 100})); c.setValue('long'); c.setValue('expected'); tick(30 const c = tick(); expect(c.errors).toEqual({'async': true, 'other': true});   })); const c = new FormControl('value', {asyncValidators: asyncValidator('expected')}); expect(c.pending).toEqual(true); expect(c.errors).toEqual({'async': true});   }));it('should support multip 'value', {asyncValidators: [asyncValidator('expected'), otherAsyncValidator]}); expect(c.pending).toEqual(true); expect(c.errors).toEqual({'async': true, 'other': true});   }));it('should support a mix o '', {validators: Validators.required, asyncValidators: asyncValidator('expected')}); tick(); ex expect(c.valid).toEqual(false); expect(c.errors).toEqual({'async': true});   }));it('should add single async validator', fake expect(c.asyncValidator).not.toEqual(null); c.setValue('expected'); tick(); expect(c.valid).toEqual(true); const c = new FormControl('value', null!); c.setAsyncValidators([asyncValidator('expected')]); ex   }));it('should override validators using `setAsyncValidators` function', fakeAsync(() => { const c = new FormControl(''); expect(c.valid).toEqual(true);  expect(c.valid).toEqual(false); c.setValue('expected'); tick(); c.setAsyncValidators([asyncValidator('new expected')]); c.setValue('expected'); tick(); tick(); expect(c.valid).toEqual(true);  const control = new FormControl('');  const originalValidators = [as});it('should override validators by setting `control.asyncValidator` field value',   fakeAsync(() => { expect(c.valid).toEqual(true); c.asyncValidator = Validators.composeAsync([asyncValidator('expected')]); c.setValue(''); tick(); tick(); expect(c.valid).toEqual(true); // Define new set of validators, overriding previously applied ones. c. expect(c.valid).toEqual(false); c.setValue('new expected'); tick(); expect(c.valid).toEqual(true); const c = new FormControl('value', [asyncValidator('expected'), otherAsyncValidator]); c.clearValidators(); expect(c.asyncValidator).toEqual(null);   }));it('should not change validit const c = new FormControl('value', [asyncValidator('expected')]); c.disable(); ti   }));it('should check presence of and remove a validator set in the control constructor', () => {  const asyncVal = asyncValidator('expected');  const c = new FormControl('', n  expect(c.hasAsyncValidator(asyncVal)).toEqual(false);  c.addAsyncValidators(asyncVal);  expect(c.hasAsyncValidator(asyncVa  const c = new FormControl('');  const asyncVal = asyncValidator('expected');  c  expect(c.hasAsyncValidator(asyncVal)).toEqual(false);});it('should check presence of and remove multiple validators set at the same time', () => {  const c = new FormControl('3');  const asyncVal2 = asyncValidator('expected2');  c.addAsyncValidators([asyncVal1, asyncVal2]);  expect(c.hasAsyncValidator(asyncVal2)).toEqual(true);  c.removeAsyncValidators([asyncVal1, asyncVal2]);  expect(c.hasAsyncValidator(asyncVal1)).toEqual(false);  e  const asyncVal = asyncValidator('expected');  const c = new FormControl('', null, asyncVal);  c.addAsyncValidators(asyncVal);  c.addAsyncValidators(asyncVal);  expect(c.hasAsyncValidator(asyncVal)).toEqual(true);  c.re});it('should return false when checking presence of a validator not identical by reference',   () => { co const c = new FormControl('1', null, asyncVal); expect(c.hasAsyncValidator(asyncVal)).toEqual(true); expect(c.hasAsyncValidator(asyncValDifferentFn)).toEqual(false);   });  });  describe('dirty', () => {it('should be false after creating a control', () =>   expect(c.dirty).toEqual(false);});it('should be true after changing the value of the control', () => {  const c = new FormControl('value');  c});  });  describe('touched', () => {it('should be false after creating a control', () => {  const c = new FormControl('value');  expect(c.touched).toEqual(false);  const c = new FormControl('value');  c.markAsTouched();  e  });  describe('setValue', () => {let g: FormGroup, c: FormControl;beforeEach(() => {  g = new FormGroup({'one': c});});it('should set the value of the control',  expect(c.value).toEqual('newValue');});it('should invoke ngOnChanges if it is present', () => {  l});it('should not invoke on change when explicitly specified', () => {  let onChange: any = null;  c.registerOnChange((v: any) => onChange = ['invoked', v]);  c.setValue('newValue', {emitModelToViewChange: false});  expect(onChange).toBeNull();});it('should set the parent', () => {  c.setValue('newValue');});it('should not set the parent when explicitly specified', () => {  c.setValue('newValue', {onlySelf: true});});it('should fire an event', fakeAsync(() => { c.valueChanges.subscribe((value) => {    tick();   }));it('should not fire an event when explicitly specified', fakeAsync(() => { c.valueChanges.subscribe((value) => {   throw 'Should not happen'; }); c.setValue('newValue', {emitEvent: false}); tick();   }));it('should work on a disabled control', () => {  g.a  c.setValue('new value');  expect(c.value).toEqual('new value');  expect(g.value).toEqual({'two': 'two'});});let g: FormGroup, c: FormControl;beforeEach(() => {  c = n});it('should set the value of the control', () => {  c.patchValue('newValue');  expect  let ngOnChanges: any;  c.registerOnChange((v: any) => ngOnChanges = ['invoked', v]);  c.patchValue('newValue');  expect(ngOnChanges).toEqual(['invoked', 'newValue']);});it('  c.registerOnChange((v: any) => onChange = ['invoked', v]);  c.patchValue('newValue', {emitModelToViewChange: false});  expect(onChange).toBeNull();});it('should set the parent', () => {  expect(g.value).toEqual({'one': 'newValue'});});it('s  expect(g.value).toEqual({'one': 'oldValue'});});it('   expect(value).toEqual('newValue'); }); c.patchValue('newValue'); tick(); c.valueChanges.subscribe((value) => { }); c.patchValue('newValue', {emitEvent: false}); tick();   }));i  c.disable();  c.patchValue('new value');  expec});  });  describe('reset()', () => {  c = new FormControl('initial va  c.setV  expect(c.value).toBe('initial value');});it('  c.patchValue('newValue', {onlySelf: true});  expect(g.value).toEqual({'one': 'initial value'});});it('should reset to a specific value if passed with boxed value', () => {  expect(c.value).toBe('new value');  c.reset({value: 'initial value', disabled: false});  expect(c.value).toBe('  c.setValu  expect(c.value).toBe(null);});it('  expect(c2.value).toBe('foo');  expect(c2.defaultValue).toBe('foo');  c2.setValue('bar');  expect(c2.value).toBe('bar');  expect  expect(c2.defaultValue).toBe('foo');  const c3 = new FormControl('foo', {nonNullable: false});  expec  expect(c3.value).toBe('bar');  expect(c3.defaultValue).toBe(null);  c3.reset();  expect(c3.value).toBe(null);  expect(c3.defaultValue).toBe(null);});it('s  expect(c2.value).toBe('foo');  expect(c2.defaultValue).toBe('foo');  c2.setValue('bar');  expec  expect(c2.value).toBe('foo');  expect(c2.defaultValue).toBe('foo');});it('should not alter the disabled state when resetting, even if a default value is provided',   () => { const c expect(c2.defaultValue).toBe('foo'); expect(c2.disabled).toBe(true); c2.setValue('bar'); c2.ena expect(c2.defaultValue).toBe('foo'); expect(c2.disabled).toBe(false);   });it('should update the value of any parent controls with passed value', () => {  const g = new FormGroup({'one': c});  c.setValue('new value');  expect(g.value).toEqual({'one': 'initial value'});});it('should update the value  c.setValue('new value');  expect(g.value).toEqual({'one': 'new value'});  c.reset();  expect(g.value).toEqual({'one': null});});it('  expect(c.pristine).toBe(false);  c.reset();  expect(c.pristine).toBe(true);  const g = new FormGroup({'one': c});  c.markAsDirty();  expect(g.pristine).toBe(true);});it('s  const g = new FormGroup({'one': c, 'two': c2});  c.mar  expect(g.pristine).toBe(false);});it('should mark the control as untouched  expect(c.untouched).toBe(false);  c.reset();  expect(c.untouched).toBe(true);  const g = new FormGroup({'one': c});  c.mark  expect(g.untouched).toBe(true);});it('  const g = new FormGroup({'one': c, 'two': c2});  c.markAsTouched();  c2.markAsTouched();  c.reset(});it('should retain the disabled state of the contr  c.reset();  expect(c.disabled).toBe(true);});it('should set disabled state based on boxed value if passed', () => {  c.disable();});describe('reset() events', () => {  let g: FormGroup, c2: FormControl, logger: any[];  beforeEach(() => {c2 = new FormControl('two');logger = [];  });  it('should emit one valueChange event per reset cc.valueChanges.subscribe(() => logger.push('control1'));c2.valueChanges.subscribe(() => logger.push('control2'));c.reset();expect(logger).toEqual(['control   g.valueChanges.subscribe((value) => { throw 'Should not happen';   });   c.va   });   c2.valueChanges.subscribe((value) => { throw 'Should not happen'; }));  it('should emit one statusChange event per reset control', () => {g.statusChanges.subscribe(() => logger.push('group')c2.statusChanges.subscribe(() => logger.push('control2'));c.reset();expg.statusChanges.subscribe(() => logger.push('group'));c.statusChanges.subscribe(() => logger.push('control1'));c2.statusChanges.subscribe(() => logger.push('control2'));c.reset({value: null, disabled: true});expect(logger).toEqual(['contro});let c: FormControl;beforeEach(() => {  c = new FormControl('old', Validators.required);});it('should fire an event aftenext: (value: any) => {  expect(c.value).toEqual('new');  expect(value).toEqual('new');}  });});it('should fire an event after the status has been updated to invalid', fakeAsync(() => { c.statusChanges.subscribe({   next: (status: any) => { expect(status).toEqual('INVALID');   } }); c.setValue(''); tick()   fakeAsync(() => { // The behavior can be tested for each of the model types. const asc = new Form tick(); expect const c = new FormControl('old', Validators.required, asyncValidator('expected')); const log: string[] = []; c.valueChanges.subscribe({next: (value: any) => log.push(`value: '${value}'`)}); c.statusChanges.subscribe({next: (status: any) => log.push(`status: '${status}'`)}); c.setValue(''); tick(); c.setValue('nonEmpty'); tick(); c.setValue('expected'); tick(); expect(log).toEqual([   'value: \'\'',   'sta   'status: \'PENDING\'',   'status: \'INVALID\'',   'value: \'expected\'',   'status: \'PENDING\'', ]);   }));it('should update set errors and status before e expect(c.valid).toEqual(false); expect(c.errors).toEqual({'required': true});    c.setValue('will be ignored'); c.valueChanges.subscribe((v) => value = v); c.setValue('new'); tick(); // @ts-expect-error see microsoft/TypeScript#9998 expect(value).toEqual('new');  });  describe('setErrors', () => {it('should set errors on a control', () => {  c});it('should reset the errors and validity when the value changes', () => {  const c = new FormControl('someValue', Validators.required);  c.setErrors({'someError': true});  c.setValue('');  expect(c.errors).toEqual({'required': true});});it('should update the parent group\'s validity', () => {  const c = new FormControl('someValue');  const g = new FormGroup({'one': c});  expect(g.valid).toEqual(true);  c.setErrors({'someError': true});  expect(g.valid).toEqual(false);});it('should not reset parent\'s errors', () => {  const g = new FormGroup({'one': c});  g.setErrors({'someGroupError': true});  c.setErrors({'someError': true});  expect(g.errors).toEqual({'someGroupError': true});});it('should reset errors when updating a value', () => {  c  c.setErrors({'someError': true});  c.setValue('newValue');  expect(c.errors).toEqual(null);  expect(g.errors).toEqual(null);});  });  describe('disable() & enable()', () => {it('should mark the control as disabled', () => {  const c = new FormControl(null);  expect(c.valid).toBe(true);  c.disable();  expect(c.disabled).toBe(true);  e  expect(c.valid).toBe(true);});it('should set the control status as disabled', () => {  const c = new FormControl(null);  expect(c.status).toEqual('VALID');  c.disable();  expect(c.status).toEqual('DISABLED');  c.enable();  expect(c.status).toEqual('VALID');});it('should retain the original value when disabled', () => {  const c = new FormControl('some value');  exp  expect(c.value).toEqual('some value');});it('should keep the disabled control in the group, but return false for contains()', () => {  const c = new FormControl('');  const g = new FormGroup({'one': c});  expect(g.get('one')).toBeDefined();  e  expect(g.contains('one')).toBe(false);});it('should mark the parent group disabled if all controls are disabled', () => {  const c = new FormControl();  const c2 = new FormControl();  const g = new FormGroup({'one': c, 'two': c2});  exp  expect(g.enabled).toBe(false);  c.enable();  expect(g.enabled).toBe(true);});it('should update the parent group value when child control status changes', () => {  const c = new FormControl('one');  c  expect(g.value).toEqual({'one': 'one', 'two': 'two'});  c.disable();  expect(g.value).toEqual({'two': 'two'});  c2.disable();  expect(g.value).toEqual({'one': 'one', 'two': 'two'});  c.enable();  expect(g.value).toEqual({'one': 'one'});});it('should mark the parent array disabled if all controls are disabled', () => {  con  const a = new FormArray([c, c2]);  expect(a.enabled).toBe(true);  c.disable();  expect(a.enabled).toBe(true);  c2.disable();  expect(a.enabled).toBe(false);  c.enable();  expect(a.enabled).toBe(true);});  const c2 = new FormControl('two');  const a = new FormArray([c, c2]);  expect(a.value).toEqual(['one', 'two']);  c.disable();  e  expect(a.value).toEqual(['one']);});it('should ignore disabled array controls when determining dirtiness', () => {  const c = new FormControl('one');  const a = new FormArray  expect(a.dirty).toBe(true);  c.disable();  e  expect(a.dirty).toBe(true);});it('should not make a dirty array not dirty when disabling controls', () => {  const c = new FormControl('one');  const a = new FormArray([c, c2]);  a.markAsDirty();  expect(c.dirty).toBe(false);  c.disable();  e});it('should ignore disabled controls in validation', () => {  const c = new FormControl(null, Validators.required);  const c2 = new FormControl(null);  c  expect(g.valid).toBe(true);  c.enable();  expect(g.valid).toBe(false);});it('should ignore disabled controls when serializing value in a group', () => {  c  const g = new FormGroup({one: c, two: c2});  expect(g.value).toEqual({one: 'one', two: 'two'});  c.disable();  expect(g.value).toEqual({two: 'two'});  c.enable();  ex  const c = new FormControl('one');  const c2 = new FormControl('two');  const  expect(a.value).toEqual(['two']);  c.enable();  expect(a.value).toEqual(['one', 'two']);});it('should ignore disabled controls when determining dirtiness', () => {  co  const g = new FormGroup({one: c, two: c2});  c.markAsDirty();  expec  expect(g.dirty).toBe(false);  c.enable();  expect(g.dirty).toBe(true);});it('should not make a dirty group not dirty when disabling controls', () => {  const c = new FormControl('one');  const c2 = new FormControl('two');  const g = new FormGroup({one: c, two: c2});  g.markAsDirty();  expect(g.dirty).toBe(true);  exp  expect(g.dirty).toBe(true);});it('should ignore disabled controls when determining touched state', () => {  const c = new FormControl('one');  const c2 = new FormControl('two');  const g = new FormGroup({one: c, two: c2});  c  expect(c.touched).toBe(true);  expect(g.touched).toBe(false);  c.enable();  expect(g.touched).toBe(true);});  const c = new FormControl('', validator);  expect(validator.calls.count()).toEqual(1);  c.disable();  expect(validator.calls.count()).toEqual(1);  c.setValue('valu  expect(validator.calls.co  it('should clear out the errors when disabled', () => {conexpect(c.errors).toEqual(null);c.enable();expect(c.errors).toEqual({required: true});  });  it('should clear out async errors when disabled', fak   tick();   expect(c.errors).toEqual(null);   c.enable();    }));});describe('disabled events', () => {  let logger: string[];  llogger = [];c = new FormControl('', Validators.required);g = new FormGroup({one: c});  }expect(logger).toEqual(['DISABLED']);c.enable();expect(logger).toEqual(['DISABLED', 'INVALID']);  });  it('should emit status change events in correct order', () => {c.stexpect(logger).toEqual(['control', 'group']);  });  it('should throw when sync validator passed into async validator param', () => {const f// test for the specific error since without the error check it would still throw an error// but// not a meaningful oneexpe'Are you using a synchronous validator where a  });  it('should not emit value change events when emitEvent = false', () => {c.valueexpect(logger).toEqual([]);c.enable({emitEvent: false});expect(logger)c.statusChanges.subscribe(() => logger.push('control'));g.statusChanges.subscribe(() => logger.push('form'));c.disable({emitEvent: false});expect(logger).toEqual([]);c.enable({emitEvent: false});expec});  });let c: FormControl;beforeEach(() => {  c = new FormControl('value');});});it('should be true after changing the value of the control', () => {  c.markAsPending();  expect(c.pending).toEqual(true);  let logger: string[];  beforeEach(() => {logger = [];c.sc.markAsPending();expect(logger).toEqual(['PENDING']);  });  it('should not emit event when emitEvent = false', () => {c.markAsPending({emitEvent: false});exp});  });  describe('can be extended', () => {// We don't technically support exte  constructor(formState?: any|{value?: any;dissuper(formState, ...args);  }}it('should perform basic FormContro  nc.setValue('bar');  // There is no need to assert because, if this test compiles, then it is possible to correctly  /  });  describe('inspecting the prototype still provides FormControl type', () => {// The constructor should be a function with a prototype property of T.// (This is the assumption we don't want to break.)type Constructor<T> = Function&{protot  return true;}// This is a nullable FormControl, and we want isInstanceOf to narrow the type.const fcOrNull: FormControl|null = new// If the guard does not work, then this code will not compile due to null being in the// type.fcOrNull.setValue(7);});  });  describe('Function.name', () => {it('returns FormControl', () => {  // FormControl's exported constructor.  expect(FormControl.name).toBe('FormControl');});});})();