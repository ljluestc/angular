/** * @license * Copyright Google LLC All Rights Reserved. * * Use of this source code is governed by an MIT-style license that can be * found in the LICENSE file at https://angular.io/license */import {Validators} from '@angular/forms/src/validators';import {of} from 'rxjs';import {asyncValidator} from './util';(function() {describe('FormArray', () => {  describe('adding/removlet c1: FormControl, c2: FormControl,   a = new FormArray<any>([]);  c1 = new FormControl(1);  c2 = new FormControl(2);  c3 = new FormControl(3);  logger = [];});it('should support  expect(a.length).toEqual(1);  expect(a.controls).toEqual([c1]);});it('should support removing', () => {  a.push(c1);  a.push(c2);  a.push(c3);  a.removeAt(1);  expect(a.controls).toEqual([c1, c3]);});  a.push(c2);  a.push(c3);  a.clear();  expect(a.controls).toEqual([]);  a.clear();  expect(a.controls).toEqual([]);});it('should support inserting', () => {  a.push(c1);  a  a.valueChanges.subscribe(() => logger.push('value change'));  a.statusChanges.subscribe(() => logger.push('status change'));  a.push(c1, {emitEvent: false});  expect(a.length).toEqual(1);  expect(a.controls).toEqual([c1]);  expect(logg  a.push(c1);  a.push(c3);  a.valueChanges.subscribe(() => logger.push('value change'));  a});it('should not emit events when calling `FormArray.clear` with `emitEvent: false`', () => {  a.push(c1);  a.push(c2);  a.push(c3);  expect(log  a.push(c1);  a.statusCh});it('should not emit events when calling `FormArray.setControl` with `emitEvent: false`', () => {  a  a.statusChanges.subscribe(() => logger.push('status change'));  a.setControl(1, c2, {emitEvent: false});  expect(a.controls).toEqual([c1, c2]);  expect(logger).toEqual([]);});it('should // Adding validat const validatorFn = (value: any) => value.controls.length > 0 ? {controls: true} : null; co expect(arr.valid).toBe(true); arr.statusChanges.subscribe(() => logger.push('status change')); arr.push(c1, {emitEvent: false}); expect(arr.valid).toBe(false); expect(logger).toEqual([]);   });it('should not emit events on the parent when called with   a.valueChanges.subscribe(() =>   a.statusChanges.subscribe(() => logger.push('array status change'));  a.push(new FormControl(5), {emitEvent: false});  expect(logger).toEqual([]);});  }  const a = new FormArray([new FormControl(1), new FormControl(2)]);  expect(a.value).toEqual([1, 2]);});it('should be an empty array when there are no child controls', () => {  const a = n});  });  describe('getRawValue()', () => {  a = new FormArray([{'c2': new FormControl('v2') as AbstractControl, 'c3': new FormControl('v3')}) as any,new FormArray([new FormControl('v4'), new FormControl('v5')])  ]  (a.at(1) as FormArray).at(1).disable();  expect(a.getRawValue()).toEqual([{'c2': 'v2', 'c3': 'v3'}, ['v4', 'v5']]);});  });  describe('markAllAsTouched', () => {it('should manew FormControl('v1') as AbstractControl, new FormControl('v2'),new FormGroup({'c1': new FormControl('v1')}),  ]);  expect(formArray.touche  });  describe('setValue', () => {let c: FormControl, c2: FormControl, a: FormArray;beforeEach(() => {  c  a = new FormArray([c, c2]);});it('should set its own value', () => {  a.setValue(});it('should set child values', () => {  a.setValue(['one', 'two']);  expect(c2.value).toEqual('two');  c2.disable();  a.setValue(['one', 'two']);  e  expect(a.getRawValue()).toEqual(['one', 'two']);});it('should set value for disabled arrays', () => {  a.disable()  expect(c.value).toEqual('one');  expect(c2.value).toEqual('two');});it('should set parent values', () => {  a.setValue(['one', 'two']);  expect(form.value).toEqual({'parent': ['one', 'two']});});  a.setValue(['one', 'two'], {onlySelf: true});  expect(form.value).toEqual({parent: ['', '']});});it('should throw if fields are missing from supplied value (subset)', () => {  expect(() => a.setValue([, 'two']))  .toThrowError(new RegExp(`NG01002: Must supply a value for form control at index: 0`));});it('should throw if a value is provided for a missing control (superset)', () => {  expect(() => a.setValue(['one', 'two', 'three'  ])).toThrowError(new RegExp(  c2.disable();  .toThrowError(new RegExp(`NG0100  const empty: FormArray = new FormArray<any>([]);  expect(() => empty.setValue(['one']))  .toT  let form: FormGroup;  let logger: any[];  beforeEach(() => {logger = [];  });  it('should emit one valueChange event per control', () => {form.valueChanges.subscribe(() => logger.push('form'));a.valueChanges.subscribe(() => logger.push('array'));c2.valueChanges.subscribe(() => logger.push('control2'));a.setValue(['one', 'two']);expect(logger).toEqual(['control1', 'control2', 'array', 'form']);  });  it('should not fire events when called with `emitEvent: false`', () => {form.c.valueChanges.subscribe(() => logger.push('control1'));c2.valueChanges.subscribe(() => logger.push('control2'));a.setValue(['one', 'two'], {emitEvent: false});expect(logger).toEqual([]);  });  it('should emit one statusChange event per control', () => {forc.statusChanges.subscribe(() => logger.push('control1'));c2.statusChanges.subscribe(() => logger.push('control2'));a.setValue(['one', 'two']);expect(logger).toEqual(['control1', 'control2', 'array', 'form']);  });});let c: FormControl, c2: FormControl, a: FormArray, a2: FormArray;beforeEach(() => {  c = new FormCon  a = new FormArray([c, c2]);  a2 = new FormArray([a]);});it('should set its own value', () => {  a.patchValue(['one', 'two']);  expect(a.value).toEqual(['one', 'two']);});it('should set child values', () => {  a.patchValue(['one', 'two']);  expect(c.value).toEqual('one');});it('should patch disabled control values', () => {  c2.disable();  a.p  expect(a.value).toEqual(['one']);  expect(a.getRawValue()).toEqual(['one', 'two']);});it('should patch disabled control arrays', () => {  a.disable();  a.patchValue(['one', 'two']);  expect(c.value).toEqual('one');  exp});it('should set parent values', () =>   a.patchValue(['one', 'two']);});it('should not update the parent exp  a.patchValue(['one', 'two'], {onlySelf: true  a.patchValue([, 'two']);});it('should not ignore fields that are null', () => {  expect(a.value).toEqual([null, '']);  a.patchValue([, , 'three']);});it('should ignore a array if `null` or `un  expect(a2.value).toEqual(INITIAL_STATE);  a2.patchValue([undef});describe('patchValue() events', () => {  let logger: any[];  beforeEach(() => {logger = [];form.valueChanges.subscribe(() c.valueChanges.subscribe(() => logger.pexpect(logger).toEqual(['control1', 'cform.valueChanges.subscribe(() => loc.valueChanges.subscribe(() => logger.push('expect(logger).toEqual(['control1', 'array', () => {   formArrayControl2.valueChanges.subscribe(logEvent);   a2.patchValue([null]);   a2.patchValue([undefined]);   // No events are expected in `valueChanges` since   // });  it('should not fire events when called with `emitEvent: false`', () => {form.valueChanges.subscribe(() => logger.push('forc.valueChanges.subscribe(() => logger.push('control1'));c2.valueChanges.subscribe(() => logger.push('control2'));a.patchValue(['one', 'two'], {emitEvent: false});expect(logger).toEqual([]);  });  it('should emit one statusChange event per control', () => {forc.statusChanges.subscribe(() => logger.push('control1'));c2.statusChanges.subscribe(() => logger.push('control2'));a.patchValue(['one', 'two']);expect(logger).toEqual(['control1', 'control2', 'array', 'form']);  }  });  describe('reset()', () => {let c: FormControl, c2: FormControl, a: FormArray;beforeEach(() => {  c = new FormControl('initial value');  c2 = new FormControl('');  a  a.setValue(['new value', 'new value']);  a.reset(['initial value', '']);  expect(a.value).toEqual(['initial value', '']);});it('should not update the parent when explicitly specified', () => {  const form = new FormGroup({'a': a});  a.reset(['one', 'two'], {onlySelf: true});  expect(form.value).toEqual({a: ['initial value', '']});});it('should set its own value if boxed value passed', () => {  a});it('should clear its own value if no value passed', () => {  a.setValue(['new value', 'new value']);  a.reset();  expect(a.value).toEqual([null, null]);});it('should set the value of each of its child controls if value passed', () => {  a.setValue(['new value', 'new value']);  a.reset(['initial value', '']);  expect(c.value).toBe('initial value');  e  a.setValue(['new value', 'new value']);  a.reset();  expect(c.value).toBe(null);  expect(c2.value).toBe(null);});it('should set the value of its parent if value passed', () => {  c  expect(form.value).toEqual({'a': ['initial value', '']});});it('should clear the value of its parent if no value passed', () => {  const form = new FormGroup({'a': a});  expect(form.value).toEqual({'a': [null, null]});});  expect(a.pristine).toBe(false);  a.reset();  expect(a.pristine).toBe(true);});it('should mark all child controls as pristine', () => {  c  expect(c.pristine).toBe(false);  expect(c2.pristine).toBe(false);  a.reset();  expect(c.pristine).toBe(true);  expect(c2.pristine).toBe(true);});  const form = new FormGroup({'a': a, 'c3': c3});  a.markAsDirty();  expect(form.pristine).toBe(false);  a.reset();  expect(form.pristine).toBe(true);});it('should not mark the parent pristine if any dirty siblings', () => {  c  c3.markAsDirty();  expect(form.pristine).toBe(false);  a.reset();  expect(form.pristine).toBe(false);});it('should mark itself as untouched', () => {  a  expect(a.untouched).toBe(true);});it('should mark all child controls as untouched', () => {  c.markAsTouched();  expect(c.untouched).toBe(false);  expect(c2.untouched).toBe(false);  a.reset();  expect(c.untouched).toBe(true);  exp  const c3 = new FormControl('');  const form = new FormGroup({'a': a, 'c3': c3});  a.markAsTouched();  expect(form.untouched).toBe(false);  a.reset();  expect(form.untouched).toBe(true);});it('should not mark the parent untouched if any touche  const form = new FormGroup({'a': a, 'c3': c3});  a.markAsTouched();  c3.markAsTouched();  exp});it('should retain previous disabled state', () => {  a.disable();  a.reset();  expect(a.disabled).toBe(true);});it('should set child disabled state if boxed value passed', () => {  a.disable();  expect(a.disabled).toBe(false);});descrc3 = new FormControl('');form = new FormGroup({'a': a, 'c3': c3});logger = [];  });  it('should emit one valueChange event per reset control', () => {form.valueChanges.subscribe(() => logger.push('form'));c.valueChanges.subscribe(() => logger.push('control1'));c2.valueChanges.subscribe(() => logger.push('control2'));c3.valueChanges.subscribe(() => logger.push('control3'));a.reset();expect(logger).toEqual(['control1', 'control2', 'array', 'form']);  });a.valueChanges.subscribe(() => logger.push('array'));c.valueChanges.subscribe(() => logger.push('control1'));c3.valueChanges.subscribe(() => logger.push('control3'));a.reset([], {emitEvent: false});expect(logger).toEqual([]);  });  it('should emit one statusChange event per reset control', () => {form.statusChanges.subscribe(() => logger.push('form'));a.statusChanges.subscribe(() => logger.push('array'));c.sc3.statusChanges.subscribe(() => logger.push('control3'));a.reset();expect(logger).toEqual(['control1', 'control2', 'array', 'form']);  });  it('should mark as pristine and not dirty before emitting valueChange and statusChange events when resetting', () expect(a.pristine).toBe(true); expect(a.dirty).toBe(false);   };   c2.markAsDirty();   expect(a.pristine).toBe(false);    });});  });  describe('errors', () => {it('should run the validator when the value changes', () => {  const simpleValidator = (c: FormArray) =>  c.controls[0].value != 'correct' ? {'broken': true} : null;  const c = new FormControl('');  c  expect(g.errors).toEqual({'broken': true});});  });  describe('dirty', () => {let c: FormControl;let a: FormArray;beforeEach(() => {  c});it('should be false after creating a control', () => {  expect(a.dirty).toEqual(false);});it('should be true after changing the value of the control', () => {  c.markAsDirty();  expect(a.dirty).toEqual(true);});let c: FormControl;let a: FormArray;beforeEach(() => {  c = new FormControl('value');});it('should be false after creating a control', () => {  e  c.markAsTouched();  expect(a.touched).toEqual(true);});  });  dlet a: FormArray;beforeEach(() => {  c = new FormControl('value');  a = new FormArray([c]);});  expect(a.pending).toEqual(false);});it('should be true after changing the value of the control', () => {  c.markAsPending();  expect(c.pending).toEqual(true);  e  c.markAsPending({onlySelf: true});  expect(c.pending).toEqual(true);  expect(a.pending).toEqual(false);  let logger: string[];  beforeEach(() => {logger = [];  });  it('should emit event after marking control as pending', () => {c.markAsPending();expc.markAsPending({onlySelf: true});expect(logger).toEqual([]);  });  it('should noexpect(logger).toEqual([]);  });  it('should emit event when parent is markedAsPending', () => {a.markAsPending();expec});  });  describe('valueChanges', () => {let a: FormArray;let c1: FormControl, c2: FormControl;beforeEach(() => {  c1 = new FormControl('old1');  a = new FormArray([c1, c2]);});it('should fire an event after the value has been updated', done => {  a.v  expect(a.value).toEqual(['new1', 'old2']);  expect(value).toEqual(['new1', 'old2']);  done();}  });});it('should fire an event after the control\'s observable fired an event', done => {  let controlCallbackIsCalled = false;  c1.  controlCallbackIsCalled = true;}  });  a.valueChanges.subscribe({  expect(controlCallbackIsCalled).toBe(true);}  });  c1.setValue('new1');  a.valueChanges.subscribe({next: (value: any) => {  done();}  });  a.removeAt(1);});inext: (value: any) => {  expect(value).toEqual(['old1', 'old2']);  done();}  });  a.push(c2);  });  describe('get', () => {it('should return null when path is null', () => {  con});it('should return null when path is empty', () => {  const g = new FormGroup({});  expect(g.get([])).toEqual(null);});it('should return null when path is invalid', () => {  const g = new FormGroup({});});it('should return a child of a control group', () => {  const g = new FormGroup({'one': new FormControl('111'),'nested': new FormGroup({'two': new FormControl('222')})  });  expect(g.get(['nested', 'two'])!.value).toEqual('222');  expect(g.get('nested.two')!.value).toEqual('222'  const g = new FormGroup({'array': new FormArray([new FormControl('111')])});  expect(g.get(['array', 0])!.value).toEqual('111');});  });  describe('validator', () => {function simpleValidator(c: AbstractControl): ValidationErrors|null {  r  return Validators.required(c.get([0]) as AbstractControl);}it('should set a single validator', () =  expect(a.valid).toBe(false);  expect(a.errors).toEqual({'broken': true});  a.setValue(['correct']);  e  const a = new FormArray([new FormControl()], {validators: simpleValidator});  expect(a.valid).toBe(false);  expect(a.errors).toEqual({'broken': true})});it('should set multiple validators from an array', () => {  c  expect(a.errors).toEqual({'required': true, 'broken': true});  a.setValue(['c']);  expect(a.valid).toBe(false);  expect(a.valid).toBe(true);});it('should set multiple validators from options obj', () => {  c  expect(a.valid).toBe(false);  expect(a.errors).toEqual({'required': t  expect(a.errors).toEqual({'broken': true});  a.setValue(['correct']);  expect(a.valid).toBe(true);});function otherObservableValidator() {  return of({'other': true}); const c = new FormControl('value'); const g = new FormArray([c], null!, asyncValidator('expected')); expect(g.pending).toEqual(true); tick(); expect(g.errors).toEqual({'async': true}); expect(g.pending).toEqual(false);    [new FormControl('value')], {asyncValidators: asyncValidator('expected')}); expect(g.pending).toEqual(true); tick(); expect(g.errors).toEqual({'async': true}); expect(g.pending).toEqual(false); const g = new FormArray( [new FormControl('value')], null!, [asyncValidator('expected'), otherObservableValidator]); expect(g.pending).toEqual(true); tick(); expect(g.errors).toEqual({'async': true, 'other': true}); ex const g = new FormArray( [new FormControl('value')], {asyncValidators: [asyncValidator('expec   }));it('should fire statusChanges events when async validators are added via options object',   fakeAsync(() => { // let statuses: string[] = []; // Create a form control with an async validator added via options object. const asc = new FormArray([], {asyncValidators: [() => Promise.resolve(null)]}); // Subscribe to status changes. asc.statusChanges.subscribe((status: any expect(statuses).toEqual(['VALID']);   }));  }let c: FormControl;let c2: FormControl;beforeEach(() => {  c = new FormControl(null);  a = new FormArray([c, c2]);});it('should mark the array as disabled', () => {  e  expect(a.disabled).toBe(true);  expect(a.valid).toBe(false);  a.enable();  expect(a.disabled).toBe(false);  expect(a.valid).toBe(true);});it('should set the array status  expect(a.status).toBe('DISABLED');  a.enable();  expect(a.status).toBe('VALID');});it('should mark children of the array as disabled', () => {  e  expect(c.disabled).toBe(true);  expect(c2.disabled).toBe(true);  a.enable();  expect(c.disabled).toBe(false);});it('should ignore disabled controls in validation', () => {  const g = new FormGroup({two: new FormControl('two')  });  e  expect(g.valid).toBe(false);});it('should ignore disabled controls when serializing value', () => {  const g = new FormGroup(  expect(g.value).toEqual({'nested': ['one'], 'two': 'two'});  g.get('nested')!.disable();  expect(g.value).toEqual({'two': 'two'});  g.get('nested')!.enable();  expect(g.value).toEqual({'nested':  const g = new FormGroup({nested: a, two: new FormControl('two')});  g.get(['nested', 0])!.markAsDirty();  e  expect(g.dirty).toEqual(false);  g.get('nested')!.enable();  expect(g.dirty).toEqual(true);});it('should ignore disabled cont  g.get(['nested', 0])!.markAsTouched();  expect(g.touched).toBe(true);  g.get('nested')!.disable();  e  expect(g.touched).toEqual(true);});it('should keep empty, disabled arrays disabled when updating validity', () => {  const arr: FormArray = new FormArray<any>([]);  expect(arr.status).toEqual('VALID');  arr.disable();  expect(arr.status).toEqual('DISAB  expect(arr.status).toEqual('DISABLED');  arr.push(new FormControl());  expect(arr.status).toEqual('VALID');});it('should re-enable empty, disabled arrays', () => {  c  expect(arr.status).toEqual('DISABLED');  arr.enable();  expect(arr.status).toEqual('VALID');});it('should not run validators on disabled cont  const arr = new FormArray([new FormControl()], validator);  expect(validator.calls.count()).toE  expect(validator.calls.count()).toEqual(1);  arr.enable();  expect(validator.calls.count()).toEqual(2);});const arr = new FormArray([new FormControl()], () => ({'expected': true}));expect(arr.errors).toEqual({'expected': true});arr.disable();expect(arr.errors).toEqual(null);arr.enable();  });  it('should re-populate array errors when enabled from a child', () => {const arr = new FormArray([new FormControl()], () => ({'expected': true}));arr.disable();expect(arr.errors).toEqual({'expected': true});  });  it('should clear out async array errors when disabled', fakeAsync(() => {      expect(arr.errors).toEqual({'async': true});   arr.disable();   expect(arr.errors).toEqual(null);   arr.enable();   tick(); }));  it('should re-populate async array errors when enabled from a child', fakeAsync(() => {      expect(arr.errors).toEqual({'async': true});   arr.disable();   expect(arr.errors).toEqual(null);   arr.push(new FormControl());   tick(); }));});describe('disabled events', () => {  l  let a: FormArray;  let form: FormGroup;  beforeEach(() => {logger = [];a = new FormArray([c]);form = new FormGroup({a: a});  });  it('should emit value change events in the right order', () => {c.valueChanges.subscribe(() => logger.push('control'));a.valexpect(logger).toEqual(['control', 'array', 'form']);  });  it('should emit status change events in the right order', () => {c.statusChanges.subscribe(() => logger.push('control'));a.statusChanges.subscribe(() => logger.push('array'));form.statusChanges.subscribe(() => logger.push('form'));a.disable();expect(logger).toEqual(['control', 'array', 'form']);c.valueChanges.subscribe(() => logger.push('control'));a.valueChanges.subscribe(() => logger.push('array'));form.a.enable({emitEvent: false});expect(logger).toEqual([]);  });  it('should not emit status change events when called with `emitEvent: false`', () => {c.statusChanges.subscribe(() => logger.push('control'));a.statusChanges.subscribe(() => logger.push('array'));form.statusChanges.subscribe(() => logger.push('form'));aa.enable({emitEvent: false});expect(logger).toEqual([]);  });  let c: FormControl;  let a: FormArray;  beforeEach(() => {c = new FormControl('one');a = new FormArray([c]);  });  it('should replace existing control with new control', () => {const c2 = new FormControl('new!', Validators.minLength(10expect(a.value).toEqual(['new!']);expect(a.valid).toBe(false);  });a.setControl(1, c2);expect(a.controls[1]).toEqual(c2);expect(a.value).toEqual(['one', 'new!']);expect(a.valid).toBe(false);  });  it('should remove control if new control is null', () => {a.setControl(0, null!);expec  });  it('should only emit value change event once', () => {const logger: string[] = [];const c2 = new FormControl('nea.setControl(0, c2);expect(logger).toEqual(['change!']);});  });  describe('out of bounds positive indices', () => {let c1: FormControl = new FormControl(1);let clet c4: FormControl = new FormControl(4);let c99: FormControl = new FormControl(99);let fa: FormArray;beforeEach(() => {  fa = new FormArray([c1, c2, c3, c4]);});// This spec checks the behavior is identical to `Array.pr  expect(fa.at(4)).toBeUndefined();});// This spec checks the behavior is identical to `Array.prot  fa.setControl(4, c99);});// This spec checks the behavior is identical to `Array.prototype.splice(index, 1)`it('should work with removeAt', (  expect(fa.value).toEqualit('should work with insert', () => {  fa.insert(4, c99);  expect(fa.value).toEqual([1, 2, 3, 4, 99]);});let c1: FormControl = new FormControl(1);let c2: FormControl = new FormControl(2);let c3: FormControl = new FormControl(3);let c4: FormContr  fa = new FormArray([c1, c2, c3, c4]);});// This spec checks the behavior is identical to `Array.prototype.at(index)`describe('should work with at', () => {  iexpect(fa.at(-2)).toBe(c3);expect(fa.at(-3)).toBe(c2);expexpect(fa.at(-5)).toBeUndefined();expect(fa.at(-10))});// This spec checks the behavior is identical to `Array.prototype.splice(index, 1, ...)`describe('should work with setControl', () => {  des  fa.setControl(-1, c99);  expect(fa.value).toEqual([1, 2, 3, 99]);});  fa.setControl(-2, c99);  expect(fa.value).toEqual([1, 2, 99, 4]);});it(  expect(fa.value).toEqual([1, 99, 3, 4]);});it(  expect(fa.value).toEqual([99, 2, 3, 4]);});it('at -5', () => {  fa.setControl(-5, c99);  expit('at -10', () => {  fa.setControl(-10, c99);  expect(fa.value).toEqual([99, 2, 3, 4]);});});// This spec checks the behavior is identical to `Array.prototype.splice(index, 1)`describe('should work with removeAt', () => {  describe('wrapping from the back between [-length, 0)', () => {it(  expect(fa.value).toEqual([1, 2, 3]);});it('at -2', () => {  f});it('at -3', () => {  expect(fa.value).toEqual([1, 3, 4]);});it(  expect(fa.value).toEqual([2, 3, 4]);});it('at -5', () => {  fa.removeAt(-5);  eit('at -10', () => {  fa.removeAt(-10);});  });});// This spec checks the behavior is identical to `Array.prototype.splice(index, 0, ...)`descrit('at -1', () => {  fa.insert(-1, c99);  expect(fa.value).toEqual([1, 2, 3, 99, 4]);});  fa.insert(-2, c99);  expect(fa.value).toEqual([1, 2, 99, 3, 4]);});it('a  expect(fa.value).toEqual([1, 99, 2, 3, 4]);});it('at -4', () => {  fa.});  });  describe('prepending when less than -length', () => {it('at -5', () => {  fa.insert(-5, c99);  expect(fa.value).toEqual([99, 1, 2, 3, 4]);});  fa.insert(-10, c99);  expect(fa.value).toEqual([99, 1, 2, 3, 4]);});it('by a simple strongly-typed array', () => {  abstract class StringFormArray extends FormArray {override value!: string[];  }});  TControls extends Array<AbstractControl<unknown>>> extends FormArray {override controls!: TControls;override value!: never[];  }});  });});  });});})(