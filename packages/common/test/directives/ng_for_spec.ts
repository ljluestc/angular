/** * @license * Copyright Google LLC All Rights Reserved. * * Use of this source code is governed by an MIT-style license that can be * found in the LICENSE file at https://angular.io/license */import {CommonModule, NgFor, NgForOf} from '@angular/common';import {Component} from '@angular/core';import {ComponentFixture, TestBed, waitForAsync} from '@angular/core/testing';import {By} from '@angular/platform-browser/src/dom/debug/by';import {expect} from '@angular/platform-browser/testing/src/matchers';let thisArg: any;{  describe('ngFor', () => {    let fixture: ComponentFixture<any>;    function getComponent(): TestComponent {return fixture.componentInstance;    }    function detectChangesAndExpectText(text: string): void {fixture.detectChanges();expect(fixture.nativeElement).toHaveText(text);    }    afterEach(() => {fixture = null as any;    });    beforeEach(() => {TestBed.configureTestingModule({  declarations: [TestComponent],  imports: [CommonModule],});    });    it('should reflect initial elements', waitForAsync(() => { createTestComponent();ngesAndExpectText('1;2;'); }));    it('should reflect added elements', waitForAsync(() => { createTestComponent();etectChanges();ent().items.push(3);ngesAndExpectText('1;2;3;'); }));    it('should reflect removed elements', waitForAsync(() => { createTestComponent();etectChanges();ent().items.splice(1, 1);ngesAndExpectText('1;'); }));    it('should reflect moved elements', waitForAsync(() => { createTestComponent();etectChanges();ent().items.splice(0, 1);ent().items.push(1);ngesAndExpectText('2;1;'); }));    it('should reflect a mix of all changes (additions/removals/moves)', waitForAsync(() => { createTestComponent();ent().items = [0, 1, 2, 3, 4, 5];etectChanges();ent().items = [6, 2, 7, 0, 4, 8];ngesAndExpectText('6;2;7;0;4;8;'); }));    it('should iterate over an array of objects', waitForAsync(() => {plate = '<ul><li *ngFor="let item of items">{{item["name"]}};</li></ul>'; createTestComponent(template);ent().items = [{'name': 'misko'}, {'name': 'shyam'}];ngesAndExpectText('misko;shyam;');ent().items.push({'name': 'adam'});ngesAndExpectText('misko;shyam;adam;');ent().items.splice(2, 1);ent().items.splice(0, 1);ngesAndExpectText('shyam;'); }));    it('should gracefully handle nulls', waitForAsync(() => {plate = '<ul><li *ngFor="let item of null">{{item}};</li></ul>'; createTestComponent(template);ngesAndExpectText(''); }));    it('should gracefully handle ref changing to null and back', waitForAsync(() => { createTestComponent();ngesAndExpectText('1;2;');ent().items = null!;ngesAndExpectText('');ent().items = [1, 2, 3];ngesAndExpectText('1;2;3;'); }));    it('should throw on non-iterable ref', waitForAsync(() => { createTestComponent();ent().items = <any>'whaaa'; => fixture.detectChanges())  .toThrowError(  `NG02200: Cannot find a differ supporting object 'whaaa' of type 'string'. NgFor only supports binding to Iterables, such as Arrays. Find more at https://angular.io/errors/NG02200`); }));    it('should throw on non-iterable ref and suggest using an array ', waitForAsync(() => { createTestComponent();ent().items = <any>{'stuff': 'whaaa'}; => fixture.detectChanges())  .toThrowError(  `NG02200: Cannot find a differ supporting object '\[object Object\]' of type 'object'. NgFor only supports binding to Iterables, such as Arrays. Did you mean to use the keyvalue pipe? Find more at https://angular.io/errors/NG02200`); }));    it('should throw on ref changing to string', waitForAsync(() => { createTestComponent();ngesAndExpectText('1;2;');ent().items = <any>'whaaa'; => fixture.detectChanges()).toThrowError(); }));    it('should works with duplicates', waitForAsync(() => { createTestComponent(); new Foo();ent().items = [a, a];ngesAndExpectText('foo;foo;'); }));    it('should repeat over nested arrays', waitForAsync(() => {plate = '<div *ngFor="let item of items">' +  '<div *ngFor="let subitem of item">{{subitem}}-{{item.length}};</div>|' +  '</div>'; createTestComponent(template);ent().items = [['a', 'b'], ['c']];ngesAndExpectText('a-2;b-2;|c-1;|');ent().items = [['e'], ['f', 'g']];ngesAndExpectText('e-1;|f-2;g-2;|'); }));    it('should repeat over nested arrays with no intermediate element', waitForAsync(() => {plate = '<div *ngFor="let item of items">' +  '<div *ngFor="let subitem of item">{{subitem}}-{{item.length}};</div>' +  '</div>'; createTestComponent(template);ent().items = [['a', 'b'], ['c']];ngesAndExpectText('a-2;b-2;c-1;');ent().items = [['e'], ['f', 'g']];ngesAndExpectText('e-1;f-2;g-2;'); }));    it('should repeat over nested ngIf that are the last node in the ngFor template', waitForAsync(() => {plate = `<div *ngFor="let item of items; let i=index">` +  `<div>{{i}}|</div>` +  `<div *ngIf="i % 2 == 0">even|</div>` +  `</div>`; createTestComponent(template);ms = [1];ent().items = items;ngesAndExpectText('0|even|');h(1);ngesAndExpectText('0|even|1|');h(1);ngesAndExpectText('0|even|1|2|even|'); }));    it('should allow of saving the collection', waitForAsync(() => {plate =  '<ul><li *ngFor="let item of items as collection; index as i">{{i}}/{{collection.length}} - {{item}};</li></ul>'; createTestComponent(template);ngesAndExpectText('0/2 - 1;1/2 - 2;');ent().items = [1, 2, 3];ngesAndExpectText('0/3 - 1;1/3 - 2;2/3 - 3;'); }));    it('should display indices correctly', waitForAsync(() => {plate = '<span *ngFor ="let item of items; let i=index">{{i.toString()}}</span>'; createTestComponent(template);ent().items = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9];ngesAndExpectText('0123456789');ent().items = [1, 2, 6, 7, 4, 3, 5, 8, 9, 0];ngesAndExpectText('0123456789'); }));    it('should display count correctly', waitForAsync(() => {plate = '<span *ngFor="let item of items; let len=count">{{len}}</span>'; createTestComponent(template);ent().items = [0, 1, 2];ngesAndExpectText('333');ent().items = [4, 3, 2, 1, 0, -1];ngesAndExpectText('666666'); }));    it('should display first item correctly', waitForAsync(() => {plate =  '<span *ngFor="let item of items; let isFirst=first">{{isFirst.toString()}}</span>'; createTestComponent(template);ent().items = [0, 1, 2];ngesAndExpectText('truefalsefalse');ent().items = [2, 1];ngesAndExpectText('truefalse'); }));    it('should display last item correctly', waitForAsync(() => {plate =  '<span *ngFor="let item of items; let isLast=last">{{isLast.toString()}}</span>'; createTestComponent(template);ent().items = [0, 1, 2];ngesAndExpectText('falsefalsetrue');ent().items = [2, 1];ngesAndExpectText('falsetrue'); }));    it('should display even items correctly', waitForAsync(() => {plate =  '<span *ngFor="let item of items; let isEven=even">{{isEven.toString()}}</span>'; createTestComponent(template);ent().items = [0, 1, 2];ngesAndExpectText('truefalsetrue');ent().items = [2, 1];ngesAndExpectText('truefalse'); }));    it('should display odd items correctly', waitForAsync(() => {plate =  '<span *ngFor="let item of items; let isOdd=odd">{{isOdd.toString()}}</span>'; createTestComponent(template);ent().items = [0, 1, 2, 3];ngesAndExpectText('falsetruefalsetrue');ent().items = [2, 1];ngesAndExpectText('falsetrue'); }));    it('should allow to use a custom template', waitForAsync(() => {plate =  '<ng-container *ngFor="let item of items; template: tpl"></ng-container>' +  '<ng-template let-item let-i="index" #tpl><p>{{i}}: {{item}};</p></ng-template>'; createTestComponent(template);ent().items = ['a', 'b', 'c'];etectChanges();ngesAndExpectText('0: a;1: b;2: c;'); }));    it('should use a default template if a custom one is null', waitForAsync(() => {plate =  `<ul><ng-container *ngFor="let item of items; template: null; let i=index">{{i}}: {{item}};</ng-container></ul>`; createTestComponent(template);ent().items = ['a', 'b', 'c'];etectChanges();ngesAndExpectText('0: a;1: b;2: c;'); }));    it('should use a custom template when both default and a custom one are present', waitForAsync(() => {plate =  '<ng-container *ngFor="let item of items; template: tpl">{{i}};</ng-container>' +  '<ng-template let-item let-i="index" #tpl>{{i}}: {{item}};</ng-template>'; createTestComponent(template);ent().items = ['a', 'b', 'c'];etectChanges();ngesAndExpectText('0: a;1: b;2: c;'); }));    describe('track by', () => {it('should console.warn if trackBy is not a function', waitForAsync(() => {// TODO(vicb): expect a warning message when we have a proper log serviceconst template = `<p *ngFor="let item of items; trackBy: value"></p>`;fixture = createTestComponent(template);fixture.componentInstance.value = 0;fixture.detectChanges();it('should track by identity when trackBy is to `null` or `undefined`', waitForAsync(() => {// TODO(vicb): expect no warning message when we have a proper log serviceconst template = `<p *ngFor="let item of items; trackBy: value">{{ item }}</p>`;fixture = createTestComponent(template);fixture.componentInstance.items = ['a', 'b', 'c'];fixture.componentInstance.value = null;detectChangesAndExpectText('abc');fixture.componentInstance.value = undefined;detectChangesAndExpectText('abc');it('should set the context to the component instance', waitForAsync(() => {const template =`<p *ngFor="let item of items; trackBy: trackByContext.bind(this)"></p>`;fixture = createTestComponent(template);thisArg = null;fixture.detectChanges();expect(thisArg).toBe(getComponent());it('should not replace tracked items', waitForAsync(() => {const template =`<p *ngFor="let item of items; trackBy: trackById; let i=index">{{items[i]}}</p>`;fixture = createTestComponent(template);const buildItemList = () => {  getComponent().items = [{'id': 'a'}];  fixture.detectChanges();  return fixture.debugElement.queryAll(By.css('p'))[0];};const firstP = buildItemList();const finalP = buildItemList();expect(finalP.nativeElement).toBe(firstP.nativeElement);it('should update implicit local variable on view', waitForAsync(() => {const template =`<div *ngFor="let item of items; trackBy: trackById">{{item['color']}}</div>`;fixture = createTestComponent(template);getComponent().items = [{'id': 'a', 'color': 'blue'}];detectChangesAndExpectText('blue');getComponent().items = [{'id': 'a', 'color': 'red'}];detectChangesAndExpectText('red');it('should move items around and keep them updated ', waitForAsync(() => {const template =`<div *ngFor="let item of items; trackBy: trackById">{{item['color']}}</div>`;fixture = createTestComponent(template);getComponent().items = [{'id': 'a', 'color': 'blue'}, {'id': 'b', 'color': 'yellow'}];detectChangesAndExpectText('blueyellow');getComponent().items = [{'id': 'b', 'color': 'orange'}, {'id': 'a', 'color': 'red'}];detectChangesAndExpectText('orangered');it('should handle added and removed items properly when tracking by index',ync(() => {const template = `<div *ngFor="let item of items; trackBy: trackByIndex">{{item}}</div>`;fixture = createTestComponent(template);getComponent().items = ['a', 'b', 'c', 'd'];fixture.detectChanges();getComponent().items = ['e', 'f', 'g', 'h'];fixture.detectChanges();getComponent().items = ['e', 'f', 'h'];detectChangesAndExpectText('efh');    });    it('should be available as a standalone directive', () => {@Component({  selector: 'test-component',  imports: [NgForOf],  template: `<ng-container *ngFor="let item of items">{{ item }}|</ng-container>  `,  standalone: true,})class TestComponent {  items = [1, 2, 3];}const fixture = TestBed.createComponent(TestComponent);fixture.detectChanges();expect(fixture.nativeElement.textContent).toBe('1|2|3|');    });    it('should be available as a standalone directive using an `NgFor` alias', () => {@Component({  selector: 'test-component',  imports: [NgFor],  template: `<ng-container *ngFor="let item of items">{{ item }}|</ng-container>  `,  standalone: true,})class TestComponent {  items = [1, 2, 3];}const fixture = TestBed.createComponent(TestComponent);fixture.detectChanges();expect(fixture.nativeElement.textContent).toBe('1|2|3|');    });  });}class Foo {  toString() {    return 'foo';  }}@Component({selector: 'test-cmp', template: ''})class TestComponent {  value: any;  items: any[] = [1, 2];  trackById(index: number, item: any): string {    return item['id'];  }  trackByIndex(index: number, item: any): number {    return index;  }  trackByContext(): void {    thisArg = this;  }}const TEMPLATE = '<div><span *ngFor="let item of items">{{item.toString()}};</span></div>';function createTestComponent(template: string = TEMPLATE): ComponentFixture<TestComponent> {  return TestBed.overrideComponent(TestComponent, {set: {template: template}}).createComponent(TestComponent);}