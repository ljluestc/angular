/** * @license * Copyright Google LLC All Rights Reserved. * * Use of this source code is governed by an MIT-style license that can be * found in the LICENSE file at https://angular.io/license */import {NgClass} from '@angular/common';import {Component} from '@angular/core';import {ComponentFixture, TestBed, waitForAsync} from '@angular/core/testing';describe('binding to CSS class list', () => {  let fixture: ComponentFixture<any>|null;  function normalizeClassNames(classes: string) {    return classes.trim().split(' ').sort().join(' ');  }  function detectChangesAndExpectClassName(classes: string): void {    fixture!.detectChanges();    let nonNormalizedClassName = fixture!.debugElement.children[0].nativeElement.className;    expect(normalizeClassNames(nonNormalizedClassName)).toEqual(normalizeClassNames(classes));  }  function getComponent(): TestComponent {    return fixture!.debugElement.componentInstance;  }  afterEach(() => {    fixture = null;  });  beforeEach(() => {    TestBed.configureTestingModule({declarations: [TestComponent],    });  });  it('should clean up when the directive is destroyed', waitForAsync(() => { fixture = createTestComponent('<div *ngFor="let item of items" [ngClass]="item"></div>'); getComponent().items = [['0']]; fixture.detectChanges(); getComponent().items = [['1']]; detectChangesAndExpectClassName('1');     }));  describe('expressions evaluating to objects', () => {    it('should add classes specified in an object literal', waitForAsync(() => { createTestComponent('<div [ngClass]="{foo: true, bar: false}"></div>');ngesAndExpectClassName('foo'); }));    it('should add classes specified in an object literal without change in class names', waitForAsync(() => { createTestComponent(`<div [ngClass]="{'foo-bar': true, 'fooBar': true}"></div>`);ngesAndExpectClassName('foo-bar fooBar'); }));    it('should add and remove classes based on changes in object literal values', waitForAsync(() => { createTestComponent('<div [ngClass]="{foo: condition, bar: !condition}"></div>');ngesAndExpectClassName('foo');ent().condition = false;ngesAndExpectClassName('bar'); }));    it('should add and remove classes based on changes to the expression object', waitForAsync(() => { createTestComponent('<div [ngClass]="objExpr"></div>');Expr = getComponent().objExpr;ngesAndExpectClassName('foo');'bar'] = true;ngesAndExpectClassName('foo bar');'baz'] = true;ngesAndExpectClassName('foo bar baz');bjExpr!['bar']);ngesAndExpectClassName('foo baz'); }));    it('should add and remove classes based on reference changes to the expression object', waitForAsync(() => { createTestComponent('<div [ngClass]="objExpr"></div>');ngesAndExpectClassName('foo');ent().objExpr = {foo: true, bar: true};ngesAndExpectClassName('foo bar');ent().objExpr = {baz: true};ngesAndExpectClassName('baz'); }));    it('should remove active classes when expression evaluates to null', waitForAsync(() => { createTestComponent('<div [ngClass]="objExpr"></div>');ngesAndExpectClassName('foo');ent().objExpr = null;ngesAndExpectClassName('');ent().objExpr = {'foo': false, 'bar': true};ngesAndExpectClassName('bar'); }));    it('should remove active classes when expression evaluates to undefined', waitForAsync(() => { createTestComponent('<div [ngClass]="objExpr"></div>');ngesAndExpectClassName('foo');ent().objExpr = undefined;ngesAndExpectClassName('');ent().objExpr = {'foo': false, 'bar': true};ngesAndExpectClassName('bar'); }));    it('should allow multiple classes per expression', waitForAsync(() => { createTestComponent('<div [ngClass]="objExpr"></div>');ent().objExpr = {'bar baz': true, 'bar1 baz1': true};ngesAndExpectClassName('bar baz bar1 baz1');ent().objExpr = {'bar baz': false, 'bar1 baz1': true};ngesAndExpectClassName('bar1 baz1'); }));    it('should split by one or more spaces between classes', waitForAsync(() => { createTestComponent('<div [ngClass]="objExpr"></div>');ent().objExpr = {'foo bar     baz': true};ngesAndExpectClassName('foo bar baz'); }));  });  describe('expressions evaluating to lists', () => {    it('should add classes specified in a list literal', waitForAsync(() => {  createTestComponent(`<div [ngClass]="['foo', 'bar', 'foo-bar', 'fooBar']"></div>`);ngesAndExpectClassName('foo bar foo-bar fooBar'); }));    it('should add and remove classes based on changes to the expression', waitForAsync(() => { createTestComponent('<div [ngClass]="arrExpr"></div>');Expr = getComponent().arrExpr;ngesAndExpectClassName('foo');ush('bar');ngesAndExpectClassName('foo bar');] = 'baz';ngesAndExpectClassName('foo baz');ent().arrExpr = arrExpr.filter((v: string) => v !== 'baz');ngesAndExpectClassName('foo'); }));    it('should add and remove classes when a reference changes', waitForAsync(() => { createTestComponent('<div [ngClass]="arrExpr"></div>');ngesAndExpectClassName('foo');ent().arrExpr = ['bar'];ngesAndExpectClassName('bar'); }));    it('should take initial classes into account when a reference changes', waitForAsync(() => { createTestComponent('<div class="foo" [ngClass]="arrExpr"></div>');ngesAndExpectClassName('foo');ent().arrExpr = ['bar'];ngesAndExpectClassName('foo bar'); }));    it('should ignore empty or blank class names', waitForAsync(() => { createTestComponent('<div class="foo" [ngClass]="arrExpr"></div>');ent().arrExpr = ['', '  '];ngesAndExpectClassName('foo'); }));    it('should trim blanks from class names', waitForAsync(() => { createTestComponent('<div class="foo" [ngClass]="arrExpr"></div>');ent().arrExpr = [' bar  '];ngesAndExpectClassName('foo bar'); }));    it('should allow multiple classes per item in arrays', waitForAsync(() => { createTestComponent('<div [ngClass]="arrExpr"></div>');ent().arrExpr = ['foo bar baz', 'foo1 bar1   baz1'];ngesAndExpectClassName('foo bar baz foo1 bar1 baz1');ent().arrExpr = ['foo bar   baz foobar'];ngesAndExpectClassName('foo bar baz foobar'); }));    it('should throw with descriptive error message when CSS class is not a string', () => {fixture = createTestComponent(`<div [ngClass]="['foo', {}]"></div>`);expect(() => fixture!.detectChanges()).toThrowError(   /NgClass can only toggle CSS classes expressed as strings, got \[object Object\]/);    });  });  describe('expressions evaluating to sets', () => {    it('should add and remove classes if the set instance changed', waitForAsync(() => { createTestComponent('<div [ngClass]="setExpr"></div>');pr = new Set<string>();dd('bar');ent().setExpr = setExpr;ngesAndExpectClassName('bar'); new Set<string>();dd('baz');ent().setExpr = setExpr;ngesAndExpectClassName('baz'); }));  });  describe('expressions evaluating to string', () => {    it('should add classes specified in a string literal', waitForAsync(() => { createTestComponent(`<div [ngClass]="'foo bar foo-bar fooBar'"></div>`);ngesAndExpectClassName('foo bar foo-bar fooBar'); }));    it('should add and remove classes based on changes to the expression', waitForAsync(() => { createTestComponent('<div [ngClass]="strExpr"></div>');ngesAndExpectClassName('foo');ent().strExpr = 'foo bar';ngesAndExpectClassName('foo bar');ent().strExpr = 'baz';ngesAndExpectClassName('baz'); }));    it('should remove active classes when switching from string to null', waitForAsync(() => { createTestComponent(`<div [ngClass]="strExpr"></div>`);ngesAndExpectClassName('foo');ent().strExpr = null;ngesAndExpectClassName(''); }));    it('should remove active classes when switching from string to undefined', waitForAsync(() => { createTestComponent(`<div [ngClass]="strExpr"></div>`);ngesAndExpectClassName('foo');ent().strExpr = undefined;ngesAndExpectClassName(''); }));    it('should take initial classes into account when switching from string to null', waitForAsync(() => { createTestComponent(`<div class="foo" [ngClass]="strExpr"></div>`);ngesAndExpectClassName('foo');ent().strExpr = null;ngesAndExpectClassName('foo'); }));    it('should take initial classes into account when switching from string to undefined', waitForAsync(() => { createTestComponent(`<div class="foo" [ngClass]="strExpr"></div>`);ngesAndExpectClassName('foo');ent().strExpr = undefined;ngesAndExpectClassName('foo'); }));    it('should ignore empty and blank strings', waitForAsync(() => { createTestComponent(`<div class="foo" [ngClass]="strExpr"></div>`);ent().strExpr = '';ngesAndExpectClassName('foo'); }));  });  describe('cooperation with other class-changing constructs', () => {    it('should co-operate with the class attribute', waitForAsync(() => { createTestComponent('<div [ngClass]="objExpr" class="init foo"></div>');Expr = getComponent().objExpr;'bar'] = true;ngesAndExpectClassName('init foo bar');'foo'] = false;ngesAndExpectClassName('init bar');ent().objExpr = null;ngesAndExpectClassName('init foo');ent().objExpr = undefined;ngesAndExpectClassName('init foo'); }));    it('should co-operate with the interpolated class attribute', waitForAsync(() => { createTestComponent(`<div [ngClass]="objExpr" class="{{'init foo'}}"></div>`);Expr = getComponent().objExpr;'bar'] = true;ngesAndExpectClassName(`init foo bar`);'foo'] = false;ngesAndExpectClassName(`init bar`);ent().objExpr = null;ngesAndExpectClassName(`init foo`);ent().objExpr = undefined;ngesAndExpectClassName(`init foo`); }));    it('should co-operate with the interpolated class attribute when interpolation changes', waitForAsync(() => { createTestComponent(  `<div [ngClass]="{large: false, small: true}" class="{{strExpr}}"></div>`);ngesAndExpectClassName(`foo small`);ent().strExpr = 'bar';ngesAndExpectClassName(`bar small`);ent().strExpr = undefined;ngesAndExpectClassName(`small`); }));    it('should co-operate with the class attribute and binding to it', waitForAsync(() => {  createTestComponent(`<div [ngClass]="objExpr" class="init" [class]="'foo'"></div>`);Expr = getComponent().objExpr;'bar'] = true;ngesAndExpectClassName(`init foo bar`);'foo'] = false;ngesAndExpectClassName(`init bar`);ent().objExpr = null;ngesAndExpectClassName(`init foo`);ent().objExpr = undefined;ngesAndExpectClassName(`init foo`); }));    it('should co-operate with the class attribute and class.name binding', waitForAsync(() => {plate =  '<div class="init foo" [ngClass]="objExpr" [class.baz]="condition"></div>'; createTestComponent(template);Expr = getComponent().objExpr;ngesAndExpectClassName('init foo baz');'bar'] = true;ngesAndExpectClassName('init foo baz bar');'foo'] = false;ngesAndExpectClassName('init baz bar');ent().condition = false;ngesAndExpectClassName('init bar'); }));    it('should co-operate with initial class and class attribute binding when binding changes', waitForAsync(() => {plate = '<div class="init" [ngClass]="objExpr" [class]="strExpr"></div>'; createTestComponent(template); = getComponent();ngesAndExpectClassName('init foo');pr!['bar'] = true;ngesAndExpectClassName('init foo bar');pr = 'baz';ngesAndExpectClassName('init bar baz foo');pr = null;ngesAndExpectClassName('init baz');pr = undefined;ngesAndExpectClassName('init baz'); }));  });  describe('prevent regressions', () => {    // https://github.com/angular/angular/issues/34336    it('should not write to the native node unless the bound expression has changed', () => {fixture = createTestComponent(`<div [ngClass]="{'color-red': condition}"></div>`);detectChangesAndExpectClassName('color-red');// Overwrite CSS classes so that we can check if ngClass performed DOM manipulation to// update itfixture.debugElement.children[0].nativeElement.className = '';// Assert that the DOM node still has the same value after change detectiondetectChangesAndExpectClassName('');fixture.componentInstance.condition = false;fixture.detectChanges();fixture.componentInstance.condition = true;detectChangesAndExpectClassName('color-red');    });    it('should not write to the native node when values are the same (obj reference change)', () => { createTestComponent(`<div [ngClass]="objExpr"></div>`);ngesAndExpectClassName('foo');ite CSS classes so that we can check if ngClass performed DOM manipulation to itebugElement.children[0].nativeElement.className = ''; that the DOM node still has the same value after change detectionngesAndExpectClassName(''); the object reference (without changing values)omponentInstance.objExp = {...fixture.componentInstance.objExp};ngesAndExpectClassName(''); });    it('should not write to the native node when values are the same (array reference change)', () => { createTestComponent(`<div [ngClass]="arrExpr"></div>`);ngesAndExpectClassName('foo');ite CSS classes so that we can check if ngClass performed DOM manipulation to itebugElement.children[0].nativeElement.className = ''; that the DOM node still has the same value after change detectionngesAndExpectClassName(''); the object reference (without changing values)omponentInstance.arrExpr = [...fixture.componentInstance.arrExpr];ngesAndExpectClassName(''); });    it('should not add css class when bound initial class is removed by ngClass binding', () => {fixture = createTestComponent(`<div [class]="'bar'" [ngClass]="objExpr"></div>`);detectChangesAndExpectClassName('foo');    });    it('should not add css class when static initial class is removed by ngClass binding', () => {fixture = createTestComponent(`<div class="bar" [ngClass]="objExpr"></div>`);detectChangesAndExpectClassName('foo');    });    it('should allow classes with trailing and leading spaces in [ngClass]', () => {@Component({  template: ` <div leading-space [ngClass]="{' foo': applyClasses}"></div> <div trailing-space [ngClass]="{'foo ': applyClasses}"></div>`})class Cmp {  applyClasses = true;}TestBed.configureTestingModule({declarations: [Cmp]});const fixture = TestBed.createComponent(Cmp);fixture.detectChanges();const leading = fixture.nativeElement.querySelector('[leading-space]');const trailing = fixture.nativeElement.querySelector('[trailing-space]');expect(leading.className).toBe('foo');expect(trailing.className).toBe('foo');    });    it('should mix class and ngClass bindings with the same value', () => {@Component({  selector: 'test-component',  imports: [NgClass],  template: `<div class="{{'option-' + level}}" [ngClass]="'option-' + level"></div>`,  standalone: true,})class TestComponent {  level = 1;}const fixture = TestBed.createComponent(TestComponent);fixture.detectChanges();expect(fixture.nativeElement.firstChild.className).toBe('option-1');fixture.componentInstance.level = 5;fixture.detectChanges();expect(fixture.nativeElement.firstChild.className).toBe('option-5');    });    it('should be available as a standalone directive', () => {@Component({  selector: 'test-component',  imports: [NgClass],  template: `<div trailing-space [ngClass]="{foo: applyClasses}"></div>`,  standalone: true,})class TestComponent {  applyClasses = true;}const fixture = TestBed.createComponent(TestComponent);fixture.detectChanges();expect(fixture.nativeElement.firstChild.className).toBe('foo');    });  });});@Component({selector: 'test-cmp', template: ''})class TestComponent {  condition: boolean = true;  items: any[]|undefined;  arrExpr: string[] = ['foo'];  setExpr: Set<string> = new Set<string>();  objExpr: {[klass: string]: any}|null|undefined = {'foo': true, 'bar': false};  strExpr: string|null|undefined = 'foo';  constructor() {    this.setExpr.add('foo');  }}function createTestComponent(template: string): ComponentFixture<TestComponent> {  return TestBed.overrideComponent(TestComponent, {set: {template: template}}).createComponent(TestComponent);}