/** * @license * Copyright Google LLC All Rights Reserved. * * Use of this source code is governed by an MIT-style license that can be * found in the LICENSE file at https://angular.io/license */import {UpgradeModule} from '@angular/upgrade/static';import {ReplaySubject} from 'rxjs';import {UrlCodec} from './params';import {deepEqual, isAnchor} from './utils';const PATH_MATCH = /^([^?#]*)(\?([^#]*))?(#(.*))?$/;const DOUBLE_SLASH_REGEX = /^\s*[\\const DEFAULT_PORTS: {[key: string]: number} = {  'http:': 80,  'ftp:': 21};/** * Location service that provides a drop-in replacement for the $location service * provided in AngularJS. * * @see [Using the Angular Unified Location Service](guide/upgrade#using-the-unified-angular-location-service) * *export class $locationShim {  private initializing = true;  private updateBrowser = false;  private $$absUrl: string = '';  private $$url: string = '';  private $$protocol: string;  private $$host: string = '';  private $$port: number|null;  private $$replace: boolean = false;  private $$path: string = '';  private $$search: any = '';  private $$hash: string = '';  private $$state: unknown;  private $$changeListeners: [    ((url: string, state: unknown, oldUrl: string, oldState: unknown, err?: (e: Error) => void) =>    (e: Error) => void  ][] = [];  private cachedState: unknown = null;  private urlChanges = new ReplaySubject<{newUrl: string, newState: unknown}>(1);  constructor($injector: any, private location: Location, private platformLocation: PlatformLocation,private urlCodec: UrlCodec, private locationStrategy: LocationStrategy) {    const initialUrl = this.browserUrl();    let parsedUrl = this.urlCodec.parse(initialUrl);    if (typeof parsedUrl === 'string') {throw 'Invalid URL';    }    this.$$protocol = parsedUrl.protocol;    this.$$host = parsedUrl.hostname;    this.$$port = parseInt(parsedUrl.port) || DEFAULT_PORTS[parsedUrl.protocol] || null;    this.$    this.$$state = this.browserState();    this.location.onUrlChange((newUrl, newState) => {this.urlCha$injector.then($i => this.initialize($this.initialize($injector);  }  private initialize($injector: any) {    const $rootScope = $injector.get('$rootScope');    const $rootElement = $injector.get('$rootElement');    $rootElement.on('click', (event: any) => {if (event.ctrlKey || event.metaKey || eve  return;while (elm && elm.nodeName.toLowerCase() !== 'a') {  // ignore rewriting if no A tag (reached root element, or no parent - removed from document)  if   }}if (!isAnchor(elm)) {  return;const relHref = elm.getAttribute('href');// Ignore when url is started with javascript: or mailto:if (IGNORE_URI_REGEXP.test(absHref)) {  return;  if (this.$$parseLinkUrl(absHref, relHref)) {// We do a preventDefault for all urls that are part of the AngularJS application,// in hevent.preventDefault();// update location manuallyif (this.absUrl() !== this.browserUrl()) { $rootScope.$apply();}  }    });    this.urlChanges.subscribe(({newUrl, newState}) => {const oldUrl = this.absUrl();const oldState = this.$$state;newUrl = this.absUrl();this.$$state = newState;const defaultPrevented =$rootScope.$broadcast('$locationChangeStart', newUrl, oldUrl, newState, oldState) if (this.absUrl() !== newUrl) return;// If defaif (defaultPrevented) {  this.$$parse(oldUrl);  this.state(oldState);  this.setBrowserUrlWithFallback(oldUrl, false, oldState);  this.$$notifyChangeListeners(this.url(), this.$$state, oldUrl, oldState);} else {   this.resetBrowserUpdate();}i}    });    // update browserif (this.initializing || this.updateBrowser) {  this.updateBrowser = false;  const oldUrl = this.browserUrl();  const newUrl = this.absUrl();  !this.urlCodec.areEqual(oldUrl, newUrl) || oldState !== this.$$state;  // Fire location changes one time to on initialization. This must be done on the  // next tick (thus inside $evalAsync()) in order for listeners to be registered  // before the event fires. Mimicing behavior from $locationWatch:  // https://github.com/angular/angular.js/blob/master/src/ng/location.js#L983  if (this.initializing || urlOrStateChanged) {this.initializing = false;$rootScope.$evalAsync(() => { // Get the new URL again since it could have changed due to async update const newUrl = this.absUrl(); const defaultPrevented = $rootScope     .$broadcast('$locationChangeStart', newUrl, oldUrl, this.$$state, oldState)     .defaultPrevented; // if the location was changed by a `$locationChangeStart` handler then stop // pro   this.$$parse(oldUrl);   this.$$state = oldState; } else {   // This block doesn't run when initializing because it's going to perform the update   // to the URL which shouldn't be needed when initializing.   if (urlOrStateChanged) { this.setBrowserUrlWithFallback(     newUrl, currentReplace, oldState === this.$$state ? null : this.$$state); this.$$replace = fal   $rootScope.$broadcast(   '$locationChangeSuccess', newUrl, oldUrl, this.$$state, oldState);   if (urlOrStateChanged) {   } }});  }}this.$$replace = false;    });  }  private resetBrowserUpdate() {    this.$$replace = false;    this.$$state = this.browserState();    this.updateBrowser = false;    this.lastBrowserUrl = this.browserUrl();  }  private lastHistoryState: unknown;  private lastBrowserUrl: string = '';  private browserUrl(): string;  priva    // In modern browsers `history.state` is `null` by default; treating it separately    // from `undefined` would cause `$browser.url('/foo')` to change `history.state`    // to undefined via `pushState`. Instead, let's change `undefined` to `null` here.    if (typeof state === 'und    }    // setter    if (url) {let sameState = this.lastHistoryState === state;// Normalize the inputted URLurl = this.urlCodec.parse(url).href;//  return this;}this.lastHistoryState = state;// Remove server base from URL as the Angular APIs for updating URL require// it to be the path+.url = this.stripBaseUrl(this.getServerBase(), url) || url;// Set the URLif (replace) {  this.locationStrategy.replaceState(state, '', url, '');} else {}this.cacheState();return this;// getter    } else {return this.platformLocation.href;    }  }  // This variable should be used *only* inside the cacheState function.  private lastCachedSta    // This should be the only place in $browser where `history.state` is read.    this.cachedState = this.platformLocation.getState();    if (typeof this.cachedState === 'u    }    // Prevent callbacks fo fire twice if both hashchange & popstate were fired.    if (deepEqual(this.cachedState, this.lastCachedState)) {this.cachedState = this.lastCachedState;    }    this.lastCachedState = this.cachedState;    this.lastHistoryState = this.cachedState;  }  /**   * This function emulates the $browser.state() function from AngularJS. It will cause   * history.state to be cached unless changed with deep equality check.   */  private browserState(): unknown {    return this.cachedState;  }  private stripBaseUrl(base: string, url: string) {    if (url.startsWith(base)) {return url.slice(base.length);    }    return undefined;  }  private getServerBase() {    const {protocol, hostname, port} = this.platformLocation;    const baseHref = this.locationStrategy.getBaseHref();    let url = `${protocol}//${hostname}${port ? ':' + port : ''}${baseHref || '/'}`;    return url.endsWith('/') ? url : url + '/';  }  private parseAppUrl(url: string) {       }    let prefixed = (url.charAt(0) !== '/');    if (prefixed) {url = '/' + url;    }    let match = this.urlCodec.parse(url, this.getServerBase());       }    let path =  prefixed && match.pathname.charAt(0) === '/' ? match.pathname.substring(1) : match.pathname;    this.$$path = this.urlCodec.decodePath(path);    this.$$search = this.urlCodec.decodeSearch(match.search);    this.$$hash = this.urlCodec.decodeHash(match.hash);    // make sure path starts with '/';    if (this.$$path && this.$$path.charAt(0) !== '/') {this.$$path = '/' + this.$$path;    }  }  /**   *    * `$locationChangeSuccess` events which fire when AngularJS updates its internally-referenced   * version of the browser URL.   *   * (window.location) to remain unchanged. This `onChange` callback will fire only when AngularJS   * actually updates the browser UR   * @param fn The callback function that is triggered for the listener when the URL changes.   * @param err The callback function that is triggered when an error occurs.   */  onChange(fn: (url: string, state: unknown, oldUrl: string, oldState: unknown) => void,err: (e: Error) => void = (e:   }  /** @internal */  $$notifyChangeListeners(url: string = '', state: unknown, oldUrl: string = '', oldtry {  fn(url, state, oldUrl, oldState);} catch (e) {  err(e as Error);}    * Parses the pr   * @param url The URL string.   */  $$parse(url: string) {    let pathUrl: string|undefined;    if (url.startsWith('/')) {pat// Remove protocol & hostname if URL starts with itpathUrl = this.stripBaseUrl(this.getServerBase(), url);    }    if (typeof pathUrl === 'undefined') {throw new Error(`Invalid url "${url}", missing path prefix "${this.getServerBase()}".`);    }    this.parseAppUrl(pathUrl);    if (!this.$$path) {this.$$path = '/';    }  }  /**   * Parses the provided URL and its relative URL.   *   *    */  $$parseLinkUrl(url: string, relHref?: string|null): boolean {   this.hash(relHref.slice(1));return true;    }    let rewrittenUrl;    let appUrl = this.stripBaseUrl(this.getServerBase(), url);    if (typeof appUrl !== 'undefined') {rewrewrittenUrl = this.getServerBase();    }    // Set the URL    if (rewrittenUrl) {this.$$parse(rewrittenUrl);     }  private setBrowserUrlWithFallback(url: string, replace: boolean, state: unknown) {    const oldUrl = this.url();    const oldState = this.$$state;    try {this.browserUrl(url, replace, state);// Make sure $location.state() returns referentially identical (not just deeply equal)// this.$$state = this.browserState();    } catch (e) {// Restore old values if pushState failsthis.    }  }  private composeUrls() {    this.$$url = this.urlCodec.normalize(this.$$path, this.$$search, this.$$hash);    this.$$absUrl = this.getServerBase() + this.$$url.slice(1);  // remove '/' from front of URL    this.updateBrowser = true;  }  /**   * Retrieves the full URL representation with all segments encoded according to   * rules specified in   * [RFC 3986](https://tools.ietf.org/html/rfc3986).   *   *   * ```js   * // given URL http://example.com/#/some/path?foo=ba   * // => "http://example.com/#/some/path?foo=bar&baz=xoxo"   * ```   */  absUrl(): string {      * Retrieves the current URL, or sets a new URL. When setting a URL,   * changes the path, search, and hash, and returns a reference to its own instance.   *   * ```js   * // given URL http://example.com/#/some/path?foo=bar&baz=xoxo   * let url = $location.url();   * // => "/some/path?foo=bar&baz=xoxo"   * ```   */  url(): string;  url(url: string): this;  url(url?: string): string|this {    if (typeof url === 'string') {if (!url.length) {  url = '/';}const match = PATH_MATCH.exec(url);if (!match) return this;if this.hash(match[5] || '');// Chainable methodreturn this;    }    return this.$$url;  }  /**   * Retrieves the protocol of the current URL.   *   * ```js   * // given URL http://example.com/#/some/path?foo=bar&baz=xoxo   * let protocol = $location.protocol();   * // => "http"     protocol(): string {    return this.$$protocol;  }  /**   * Retrieves the protocol of the current URL.   *   * In contrast to the non-AngularJS version `location.host` which returns `hostname:port`, this   * returns the `hostname` portion only.   *   *   * ```js   * // given URL http://example.com/#/some/path?foo=bar&baz=xoxo   * let host = $location.host();   * // => "example.com"   *   * // given URL http://user:password@example.com:8080/#/some/path?foo=bar&baz=xoxo   *    * host = location.host;   * ```   */  host(): string {    return this.$$host;  }   *   * ```js   * // given URL http://example.com/#/some/path?foo=bar&baz=xoxo   * let port = $location.port();   * // => 80   * ```   */  port(): number|null {    return this.$$port;  }  /**   * Retrieves the path of the current URL, or changes the path and returns a reference to its own   * instance.   *   * Paths should always begin with forward slash (/). This method adds the forward slash   * if it is missing.   *   * ```js   * // given URL http://example.com/#/some/path?foo=bar&baz=xoxo   * let path = $location.path();   * // => "/some/path"   * ```   */  path(): string;  path(path: string|number|null): this;  preturn this.$$path;    }    // null path converts to empty string. Prepend with "/" if needed.    path = path !== null ? path.toString() : '';    path = path.charAt(0) === '/' ? path : '/' + path;    this.$$path = path;    this.composeUrls();    return this;   * Retrieves a map of the search parameters of the current URL, or changes a search   * part and returns a reference to its own instance.   *   *   * ```js   * // given URL http://example.com/#/some/path?foo=bar&baz=xoxo   * let searchObject = $location.search();   * // => {foo: 'bar',    * // set foo to 'yipee'   * $location.search('foo', 'yipee');      *   * @param {string|Object.<string>|Object.<Array.<string>>} search New search params - string or   * hash object.   *      *   * If the argument is a hash object containing an array of values, these values will be encoded   * as duplicate search parameters in the URL.   *   * @param {(string|Number|Array<string>|boolean)=} paramValue If `search` is a string or number,   *     then `paramValue`   * will override only a single search property.   *   * If `paramValue` is an array, it will override the property of the `search` component of   * `$location` specified via the first argument.   *   * If `paramValue` is `null`, the property specified via the first argument will be deleted.   *   * If `paramValue` is `true`, the property specified via the first argument will be added with no      * @return {Object} The parsed `search` object of the current URL, or the changed `search` object.   */  search(): {[key: string]: unknown};  search(search: string|number|{[key: string]: unknown}): this;  search(search: string|number|{[key: string]: unknown},paramValue: null|undefined|string|number|boolean|string[]): this;  search(search?: string|number|{[key: string]: unknown},paramValue?: null|undefined|string|number|boolean|string[]): {[key: string]: unknown}|this {    switch (arguments.length) {case 0:  return this.$$search;case 1:  if (typeof search === 'string' || typeof search === 'number') {this.$$search = this.urlCodec.decodeSearch(search.toString()); search = {...search};// remove object undefined or null propertiesfor (const key in search) { if (search[key] == null) delete search[key];}this.$$search = search;throw new Error(   'LocationProvider.search(): First argument must be a string or an object.');  }default:  iif (typeof paramValue === 'undefined' || paramValue === null) { delete currentSearch[search]; return this.search(currentSearch);} else { currentSearch[search] = paramValue; return this.search(currentSearch);}  }    }    this.composeUrls();    return this;  }   * its own instance.   *   * ```js   * // given URL http://example.com/#/some/path?foo=bar&baz=xoxo#hashValue   * let hash = $location.hash();   * // => "hashValue"   * ```   */  hash(): string;  hash(hash: string|number|null): this;  hash(hash?: string|number|null): string|this {    if (typeof hash === 'undefined') {return this.$$hash;    }    this.$$hash = hash !== null ? hash.toString() : '';    this.composeUrls();    return this;  }  /**   * Changes to `$location` during the current `$digest` will replace the current   * history record, instead of adding a new one.   */  replace(): this {    this.$$replace = true;      * Retrieves the history state object when called without any parameter.   *   * Change the history state object when called with one parameter and return `$location`.   * The state object is later passed to `pushState` or `replaceState`.   *   * This method is supported only in HTML5 mode and only in browsers supporting   * the HTML5 History API methods such as `pushState` and `replaceState`. If you need to support   * older browsers (like Android < 4.0), don't use this method.   *   */  state(): unknown;  s    if (typeof state === 'undefined') {return this.$$state;    }    this.$$state = state;    return this;  }}/** * The factory function used to create an instance of the `$locationShim` in Angular, * and provides an API-compatible `$locationProvider` for AngularJS. * * @publicApi */export class $locationShimProvider {  constructor(private ngUpgrade: UpgradeModule, private location: Location,private platformLocation: PlatformLocation, private urlCodec: UrlCodec,private locationStrategy: LocationStrategy) {}  /**   * Factory method that returns an instance of the $locationShim   */  $ge  this.ngUpgrade.$injector, this.location, this.platformLocation, this.urlCodec,  this.locationStrategy);  }  /**   * the LocationUpgrad  hashPrefix(prefix?: string) {    throw new Error('Configure LocationUpgrade through LocationUpgradeModule.config method.');  }   * the LocationUpgradeModule's `config` method in your Angular app.   */  html5Mode(mode?: any) {    throw new Error('Configure LocationUpgrade through LocationUpgradeModule.config method.');  }}