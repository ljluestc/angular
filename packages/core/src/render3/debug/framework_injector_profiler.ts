/** * @license * Copyright Google LLC All Rights Reserved. * * Use of this source code is governed by an MIT-style license that can be * found in the LICENSE file at https://angular.io/license */import {Type} from '../../interface/type';import {throwError} from '../../util/assert';import {getComponentDef} from '../definition';import {getNodeInjectorLView, NodeInjector} from '../di';import {LView} from '../interfaces/view';import {InjectedService, InjectorCreatedInstance, InjectorProfilerContext, InjectorProfilerEvent, InjectorProfilerEventType, ProviderRecord, setInjectorProfiler} from './injector_profiler';/** * These are the data structures that our framework injector profiler will fill with data in order * to support DI debugging APIs. * resolverToTokenToDependencies: Maps an injector to a Map of tokens to an Array of * getDependenciesFromInjectable API, which takes in an injector and a token and returns it's * dependencies. * * resolverToProviders: Maps a DI resolver (an Injector or an LView) to the providers configured * within it This is used to support the getInjectorProviders API, which takes in an injector and * returns the providers that it was configured with. * * standaloneInjectorToComponent: Maps the injector of a standalone component to the standalone * component that it is associated with. Used in the getInjectorProviders API, specificially in the * discovery of import paths for each provider. This is necessary because the imports array of a * standalone component is processed and configured in its standalone injector, but exists within * the component's definition. Because getInjectorProviders takes in an injector, if that injector * is the injector of a standalone component, we need to be able to discover the place where the * imports array is located (the component) in order to flatten the imports array within it to * discover all of it's providers. * * * All of these data structures are instantiated with WeakMaps. This will ensure that the presence * of any object in the keys of these maps does not prevent the garbage collector from collecting * those objects. Because of this property of WeakMaps, these data structures will never be the * source of a memory leak. * * An example of this advantage: When components are destroyed, we don't need to do * any additional work to remove that component from our mappings. * */class DIDebugData {  resolverToTokenToDependencies =new WeakMap<Injector|LView, WeakMap<Type<unknown>, InjectedService[]>>();  resolverToProviders = new WeakMap<Injector|LView, ProviderRecord[]>();  standaloneInjectorToComponent = new WeakMap<Injector, Type<unknown>>();  reset() {    this.resolverToTokenToDependencies =  new WeakMap<Injector|LView, WeakMap<Type<unknown>, InjectedService[]>>();    this.resolverToProviders = new WeakMap<Injector|LView, ProviderRecord[]>();    this.standaloneInjectorToComponent = new WeakMap<Injector, Type<unknown>>();  }}let frameworkDIDebugData = new DIDebugData();export function getFramewor}/** * Initalize default handling of injector events. This handling parses events * as they are emitted and constructs the data structures necessary to support * some of debug APIs. * * See handleInjectEvent, handleCreateEvent and handleProviderConfiguredEvent  * Supported APIs: *- getInjectorProviders */e  setInjectorProfiler((injectorProfilerEvent) => handleInjectorProfilerEvent(injectorProfilerEvent));}function handleInjectorProfilerEvent(injectorProfilerEvent: InjectorProfilerEvent): void {  const {context, type} = injectorProfilerEvent;  if (type === InjectorProfilerEventType.Inject) {    handleInjectEvent(context, injectorProfilerEvent.service);  } else if (type === InjectorProfilerEventType.InstanceCreatedByInjector) {    handleInstanceCreatedByInjectorEvent(context, injectorProfilerEvent.instance);  } else if (type === InjectorProfilerEventType.ProviderConfigured) {    handleProviderConfiguredEvent(context, injectorProfilerEvent.providerRecord);  }}/** * * Stores the injected service in frameworkDIDebugData.resolverToTokenToDependencies * based on it's injector and token. * * @param context InjectorProfilerContext the injection context that this event occurred in.  */function handleInjectEvent(context: InjectorProf  if (diResolver === null) {    throwError('An Inject event must be run within an injection context.');  }  const diResolverToInstantiatedToken = frameworkDIDebugData.resolverToTokenToDependencies;  if (!diResolverToInstantiatedToken.has(diResolver)) {    diResolverToInstantiatedToken.set(diResolver, new WeakMap<Type<unknown>, InjectedService[]>());  }  // if token is a primitive type, ignore this event. We do this because we cannot keep track of  // non-primitive tokens in WeakMaps since they are not garbage collectable.  if (!canBeHeldWeakly(context.token)) {   if (!instantiatedTokenToDependencies.has(context.token!)) {    instantiatedTokenToDependencies.set(context.token!, []);  }  const {token, value, flags} = data;  instantiatedTokenToDependencies.get(context.token!)!.push({token, value, flags});}/** * * If the created instance is an instance of a standalone component, maps the injector to that * standalone component in frameworkDIDebugData.standaloneInjectorToComponent * * @param context InjectorProfilerContext the injection context that this event occurred in. * @param data InjectorCreatedInstance an object containing the instance that was just created * */fun  const {value} = data;  if (getDIResolver(context.injector) === null) {  }  // if our value is an instance of a standalone component, map the injector of that standalone  // component to the component class. Otherwise, this event is a noop.  l    standaloneComponent = value?.constructor as Type<unknown>;  }  if (standaloneComponent === undefined || !isStandaloneComponent(standaloneComponent)) {    return;  }  // Standalone components should have an environment injector. If one cannot be  // found we may be in a test case for low level functionality that did not explictly  // setup this injector. In those cases, we simply ignore this event.  i  }  const {standaloneInjectorToComponent} = frameworkDIDebugData;  // If our injector has already been mapped, as is the case  // when a standalone component imports another standalone component,   if (standaloneInjectorToComponent.has(environmentInjector)) {    return;  }  // If our injector hasn't been mapped, then we map it to the standalone component  standaloneInjectorToComponent.set(environmentInjector, standaloneComponent);}function isStandaloneComponent(value: Type<unknown>): boolean {  const def = getComponentDef(value);  return !!def?.standalone;}/** * * Stores the emitted ProviderRecords from the InjectorProfilerEventType.ProviderConfigured * event in frameworkDI * @param context InjectorProfilerContext the injection context that this event occurred in. * @param data ProviderRecord an object containing the instance that was just created *function handleProviderConfiguredEvent(    context: InjectorProfilerContext, data: ProviderRecord): void {  const {resolverToProviders} = frameworkDIDebugData;  const diResolver = getDIResolver(context?.injector);  if (diResolver === null) {    throwError('A ProviderConfigured event must be run within an injection context.');  }  if (!resolverToProviders.has(diResolver)) {    resolverToProviders.set(diResolver, []);  }  resolverToProviders.get(diResolver)!.push(data);}fu    return diResolver;  }  // We use the LView as the diResolver for NodeInjectors because they  // do not persist anywhere in the framework. They are simply wrappers around an LView and a TNode  // that do persist. Because of this, we rely on the LView of the NodeInjector in order to use  // as a concrete key to represent this injector. If we get the same LView back later, we know  // we're looking at the same injector.  if (injector instanceof NodeInjector) {     // Other injectors can be used a keys for a map because their  else {    diResolver = injector;  }  return diResolver;}// inspired by// https://tc39.es/ecma262/multipage/executable-code-and-execution-contexts.html#sec-canbeheldweaklyfunction canBeHeldWeakly(value: any): boolean {  // we check for value !== null here because typeof null === 'object  return value !== null &&(typeof value === 'object' || typeof value === 'function' || typeof value === 'symbol');}