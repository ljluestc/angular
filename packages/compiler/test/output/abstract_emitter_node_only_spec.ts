/** * @license * Copyright Google LLC All Rights Reserved. * * Use of this source code is governed by an MIT-style license that can be * found in the LICENSE file at https://angular.io/license */import {ParseLocation, ParseSourceFile, ParseSourceSpan} from '@angular/compiler';import {EmitterVisitorContext} from '@angular/compiler/src/output/abstract_emitter';import {originalPositionFor} from './source_map_util';{  describe('AbstractEmitter', () => {    describe('EmitterVisitorContext', () => {fileA = new ParseSourceFile('a0a1a2a3a4a5a6a7a8a9', 'a.js');fileB = new ParseSourceFile('b0b1b2b3b4b5b6b7b8b9', 'b.js');x: EmitterVisitorContext;Each(() => {= EmitterVisitorContext.createRoot();ould add source files to the source map', () => {print(createSourceSpan(fileA, 0), 'o0');print(createSourceSpan(fileA, 1), 'o1');print(createSourceSpan(fileB, 0), 'o2');print(createSourceSpan(fileB, 1), 'o3');t sm = ctx.toSourceMapGenerator('o.ts').toJSON()!;ct(sm.sources).toEqual([fileA.url, fileB.url]);ct(sm.sourcesContent).toEqual([fileA.content, fileB.content]);ould generate a valid mapping', () => {print(createSourceSpan(fileA, 0), 'fileA-0');println(createSourceSpan(fileB, 1), 'fileB-1');print(createSourceSpan(fileA, 2), 'fileA-2');ctMap(ctx, 0, 0, 'a.js', 0, 0);ctMap(ctx, 0, 7, 'b.js', 0, 2);ctMap(ctx, 1, 0, 'a.js', 0, 4);ould be able to shift the content', async () => {print(createSourceSpan(fileA, 0), 'fileA-0');t sm = ctx.toSourceMapGenerator('o.ts', 10).toJSON()!;ct(await originalPositionFor(sm, {line: 11, column: 0})).toEqual({line: 1,column: 0,source: 'a.js',ould use the default source file for the first character', () => {print(null, 'fileA-0');ctMap(ctx, 0, 0, 'o.ts', 0, 0);ould use an explicit mapping for the first character', () => {print(createSourceSpan(fileA, 0), 'fileA-0');ctMap(ctx, 0, 0, 'a.js', 0, 0);ould map leading segment without span', () => {print(null, '....');print(createSourceSpan(fileA, 0), 'fileA-0');ctMap(ctx, 0, 0, 'o.ts', 0, 0);ctMap(ctx, 0, 4, 'a.js', 0, 0);ct(nbSegmentsPerLine(ctx)).toEqual([2]);ould handle indent', () => {incIndent();println(createSourceSpan(fileA, 0), 'fileA-0');incIndent();println(createSourceSpan(fileA, 1), 'fileA-1');decIndent();println(createSourceSpan(fileA, 2), 'fileA-2');ctMap(ctx, 0, 0, 'o.ts', 0, 0);ctMap(ctx, 0, 2, 'a.js', 0, 0);ctMap(ctx, 1, 0);ctMap(ctx, 1, 2);ctMap(ctx, 1, 4, 'a.js', 0, 2);ctMap(ctx, 2, 0);ctMap(ctx, 2, 2, 'a.js', 0, 4);ct(nbSegmentsPerLine(ctx)).toEqual([2, 1, 1]);ould coalesce identical span', () => {t span = createSourceSpan(fileA, 0);print(span, 'fileA-0');print(null, '...');print(span, 'fileA-0');print(createSourceSpan(fileB, 0), 'fileB-0');ctMap(ctx, 0, 0, 'a.js', 0, 0);ctMap(ctx, 0, 7, 'a.js', 0, 0);ctMap(ctx, 0, 10, 'a.js', 0, 0);ctMap(ctx, 0, 17, 'b.js', 0, 0);ct(nbSegmentsPerLine(ctx)).toEqual([2]);    });  });}// All lines / columns indexes are 0-based// Note: source-map line indexes are 1-based, column 0-basedasync function expectMap(    ctx: EmitterVisitorContext, genLine: number, genCol: number, source: string|null = null,    srcLine: number|null = null, srcCol: number|null = null) {  const sm = ctx.toSourceMapGenerator('o.ts').toJSON()!;  const genPosition = {line: genLine + 1, column: genCol};  const origPosition = await originalPositionFor(sm, genPosition);  expect(origPosition.source).toEqual(source);  expect(origPosition.line).toEqual(srcLine === null ? null : srcLine + 1);  expect(origPosition.column).toEqual(srcCol);}// returns the number of segments per linefunction nbSegmentsPerLine(ctx: EmitterVisitorContext) {  const sm = ctx.toSourceMapGenerator('o.ts').toJSON()!;  const lines = sm.mappings.split(';');  return lines.map(l => {    const m = l.match(/,/g);    return m === null ? 1 : m.length + 1;  });}function createSourceSpan(file: ParseSourceFile, idx: number) {  const col = 2 * idx;  const start = new ParseLocation(file, col, 0, col);  const end = new ParseLocation(file, col + 2, 0, col + 2);  const sourceSpan = new ParseSourceSpan(start, end);  return {sourceSpan};}