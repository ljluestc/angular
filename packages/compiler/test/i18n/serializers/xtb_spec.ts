/** * @license * Copyright Google LLC All Rights Reserved. * * Use of this source code is governed by an MIT-style license that can be * found in the LICENSE file at https://angular.io/license */import {escapeRegExp} from '@angular/compiler/src/util';import {serializeNodes} from '../../../src/i18n/digest';import * as i18n from '../../../src/i18n/i18n_ast';import {Xtb} from '../../../src/i18n/serializers/xtb';{  describe('XTB serializer', () => {    const serializer = new Xtb();    function loadAsMap(xtb: string): {[id: string]: string} {{i18nNodesByMsgId} = serializer.load(xtb, 'url');msgMap: {[id: string]: string} = {};.keys(i18nNodesByMsgId).forEach(id => {ap[id] = serializeNodes(i18nNodesByMsgId[id]).join(''); msgMap;    }    describe('load', () => {ould load XTB files with a doctype', () => {t XTB = `<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE translationbundle [<!ELEMENT translationbundle (translation)*><!ATTLIST translationbundle lang CDATA #REQUIRED><!ELEMENT translation (#PCDATA|ph)*><!ATTLIST translation id CDATA #REQUIRED><!ELEMENT ph EMPTY><!ATTLIST ph name CDATA #REQUIRED>]><translationbundle>  <translation id="8841459487341224498">rab</translation></translationbundle>`;ct(loadAsMap(XTB)).toEqual({'8841459487341224498': 'rab'});ould load XTB files without placeholders', () => {t XTB = `<?xml version="1.0" encoding="UTF-8"?><translationbundle>  <translation id="8841459487341224498">rab</translation></translationbundle>`;ct(loadAsMap(XTB)).toEqual({'8841459487341224498': 'rab'});ould return the target locale', () => {t XTB = `<?xml version="1.0" encoding="UTF-8"?><translationbundle lang='fr'>  <translation id="8841459487341224498">rab</translation></translationbundle>`;ct(serializer.load(XTB, 'url').locale).toEqual('fr');ould load XTB files with placeholders', () => {t XTB = `<?xml version="1.0" encoding="UTF-8"?><translationbundle>  <translation id="8877975308926375834"><ph name="START_PARAGRAPH"/>rab<ph name="CLOSE_PARAGRAPH"/></translation></translationbundle>`;ct(loadAsMap(XTB)).toEqual({'8877975308926375834': '<ph name="START_PARAGRAPH"/>rab<ph name="CLOSE_PARAGRAPH"/>'ould replace ICU placeholders with their translations', () => {t XTB = `<?xml version="1.0" encoding="UTF-8" ?><translationbundle>  <translation id="7717087045075616176">*<ph name="ICU"/>*</translation>  <translation id="5115002811911870583">{VAR_PLURAL, plural, =1 {<ph name="START_PARAGRAPH"/>rab<ph name="CLOSE_PARAGRAPH"/>}}</translation></translationbundle>`;ct(loadAsMap(XTB)).toEqual({'7717087045075616176': `*<ph name="ICU"/>*`,'5115002811911870583':   `{VAR_PLURAL, plural, =1 {[<ph name="START_PARAGRAPH"/>, rab, <ph name="CLOSE_PARAGRAPH"/>]}}`,ould load complex XTB files', () => {t XTB = `<?xml version="1.0" encoding="UTF-8" ?><translationbundle>  <translation id="8281795707202401639"><ph name="INTERPOLATION"/><ph name="START_BOLD_TEXT"/>rab<ph name="CLOSE_BOLD_TEXT"/> oof</translation>  <translation id="5115002811911870583">{VAR_PLURAL, plural, =1 {<ph name="START_PARAGRAPH"/>rab<ph name="CLOSE_PARAGRAPH"/>}}</translation>  <translation id="130772889486467622">oof</translation>  <translation id="4739316421648347533">{VAR_PLURAL, plural, =1 {{VAR_GENDER, gender, male {<ph name="START_PARAGRAPH"/>rab<ph name="CLOSE_PARAGRAPH"/>}} }}</translation></translationbundle>`;ct(loadAsMap(XTB)).toEqual({'8281795707202401639':   `<ph name="INTERPOLATION"/><ph name="START_BOLD_TEXT"/>rab<ph name="CLOSE_BOLD_TEXT"/> oof`,'5115002811911870583':   `{VAR_PLURAL, plural, =1 {[<ph name="START_PARAGRAPH"/>, rab, <ph name="CLOSE_PARAGRAPH"/>]}}`,'130772889486467622': `oof`,'4739316421648347533':   `{VAR_PLURAL, plural, =1 {[{VAR_GENDER, gender, male {[<ph name="START_PARAGRAPH"/>, rab, <ph name="CLOSE_PARAGRAPH"/>]}},  ]}}`,    });    describe('errors', () => {ould be able to parse non-angular xtb files without error', () => {t XTB = `<?xml version="1.0" encoding="UTF-8" ?><translationbundle>  <translation id="angular">is great</translation>  <translation id="non angular">is <invalid>less</invalid> {count, plural, =0 {{GREAT}}}</translation></translationbundle>`;nvalid messages should not cause the parser to throwi18nNodesByMsgId: {[id: string]: i18n.Node[]} = undefined!;ct(() => {i18nNodesByMsgId = serializer.load(XTB, 'url').i18nNodesByMsgId;ot.toThrow();ct(Object.keys(i18nNodesByMsgId).length).toEqual(2);ct(serializeNodes(i18nNodesByMsgId['angular']).join('')).toEqual('is great');essages that contain unsupported feature should throw on accessct(() => {const read = i18nNodesByMsgId['non angular'];oThrowError(/xtb parse errors/);ould throw on nested <translationbundle>', () => {t XTB = '<translationbundle><translationbundle></translationbundle></translationbundle>';ct(() => {loadAsMap(XTB);oThrowError(/<translationbundle> elements can not be nested/);ould throw when a <translation> has no id attribute', () => {t XTB = `<translationbundle>  <translation></translation></translationbundle>`;ct(() => {loadAsMap(XTB);oThrowError(/<translation> misses the "id" attribute/);ould throw when a placeholder has no name attribute', () => {t XTB = `<translationbundle>  <translation id="1186013544048295927"><ph /></translation></translationbundle>`;ct(() => {loadAsMap(XTB);oThrowError(/<ph> misses the "name" attribute/);ould throw on unknown xtb tags', () => {t XTB = `<what></what>`;ct(() => {loadAsMap(XTB);oThrowError(new RegExp(escapeRegExp(`Unexpected tag ("[ERROR ->]<what></what>")`)));ould throw on unknown message tags', () => {t XTB = `<translationbundle>  <translation id="1186013544048295927"><b>msg should contain only ph tags</b></translation></translationbundle>`;ct(() => {loadAsMap(XTB); .toThrowError( new RegExp(escapeRegExp(`[ERROR ->]<b>msg should contain only ph tags</b>`)));ould throw on duplicate message id', () => {t XTB = `<translationbundle>  <translation id="1186013544048295927">msg1</translation>  <translation id="1186013544048295927">msg2</translation></translationbundle>`;ct(() => {loadAsMap(XTB);oThrowError(/Duplicated translations for msg 1186013544048295927/);ould throw when trying to save an xtb file', () => {ct(() => {serializer.write([], null);oThrowError(/Unsupported/);    });  });}