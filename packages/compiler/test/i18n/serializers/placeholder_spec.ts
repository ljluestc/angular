/** * @license * Copyright Google LLC All Rights Reserved. * * Use of this source code is governed by an MIT-style license that can be * found in the LICENSE file at https://angular.io/license */import {PlaceholderRegistry} from '../../../src/i18n/serializers/placeholder';{  describe('PlaceholderRegistry', () => {    let reg: PlaceholderRegistry;    beforeEach(() => {new PlaceholderRegistry();    });    describe('tag placeholder', () => {ould generate names for well known tags', () => {ct(reg.getStartTagPlaceholderName('p', {}, false)).toEqual('START_PARAGRAPH');ct(reg.getCloseTagPlaceholderName('p')).toEqual('CLOSE_PARAGRAPH');ould generate names for custom tags', () => {ct(reg.getStartTagPlaceholderName('my-cmp', {}, false)).toEqual('START_TAG_MY-CMP');ct(reg.getCloseTagPlaceholderName('my-cmp')).toEqual('CLOSE_TAG_MY-CMP');ould generate the same name for the same tag', () => {ct(reg.getStartTagPlaceholderName('p', {}, false)).toEqual('START_PARAGRAPH');ct(reg.getStartTagPlaceholderName('p', {}, false)).toEqual('START_PARAGRAPH');ould be case sensitive for tag name', () => {ct(reg.getStartTagPlaceholderName('p', {}, false)).toEqual('START_PARAGRAPH');ct(reg.getStartTagPlaceholderName('P', {}, false)).toEqual('START_PARAGRAPH_1');ct(reg.getCloseTagPlaceholderName('p')).toEqual('CLOSE_PARAGRAPH');ct(reg.getCloseTagPlaceholderName('P')).toEqual('CLOSE_PARAGRAPH_1');ould generate the same name for the same tag with the same attributes', () => {ct(reg.getStartTagPlaceholderName('p', {foo: 'a', bar: 'b'}, false)) .toEqual('START_PARAGRAPH');ct(reg.getStartTagPlaceholderName('p', {foo: 'a', bar: 'b'}, false)) .toEqual('START_PARAGRAPH');ct(reg.getStartTagPlaceholderName('p', {bar: 'b', foo: 'a'}, false)) .toEqual('START_PARAGRAPH');ould generate different names for the same tag with different attributes', () => {ct(reg.getStartTagPlaceholderName('p', {foo: 'a', bar: 'b'}, false)) .toEqual('START_PARAGRAPH');ct(reg.getStartTagPlaceholderName('p', {foo: 'a'}, false)).toEqual('START_PARAGRAPH_1');ould be case sensitive for attributes', () => {ct(reg.getStartTagPlaceholderName('p', {foo: 'a', bar: 'b'}, false)) .toEqual('START_PARAGRAPH');ct(reg.getStartTagPlaceholderName('p', {fOo: 'a', bar: 'b'}, false)) .toEqual('START_PARAGRAPH_1');ct(reg.getStartTagPlaceholderName('p', {fOo: 'a', bAr: 'b'}, false)) .toEqual('START_PARAGRAPH_2');ould support void tags', () => {ct(reg.getStartTagPlaceholderName('p', {}, true)).toEqual('PARAGRAPH');ct(reg.getStartTagPlaceholderName('p', {}, true)).toEqual('PARAGRAPH');ct(reg.getStartTagPlaceholderName('p', {other: 'true'}, true)).toEqual('PARAGRAPH_1');    });    describe('arbitrary placeholders', () => {ould generate the same name given the same name and content', () => {ct(reg.getPlaceholderName('name', 'content')).toEqual('NAME');ct(reg.getPlaceholderName('name', 'content')).toEqual('NAME');ould generate a different name given different content', () => {ct(reg.getPlaceholderName('name', 'content1')).toEqual('NAME');ct(reg.getPlaceholderName('name', 'content2')).toEqual('NAME_1');ct(reg.getPlaceholderName('name', 'content3')).toEqual('NAME_2');ould generate a different name given different names', () => {ct(reg.getPlaceholderName('name1', 'content')).toEqual('NAME1');ct(reg.getPlaceholderName('name2', 'content')).toEqual('NAME2');    });  });}