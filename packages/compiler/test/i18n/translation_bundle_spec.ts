/** * @license * Copyright Google LLC All Rights Reserved. * * Use of this source code is governed by an MIT-style license that can be * found in the LICENSE file at https://angular.io/license */import {MissingTranslationStrategy} from '@angular/core';import * as i18n from '../../src/i18n/i18n_ast';import {TranslationBundle} from '../../src/i18n/translation_bundle';import * as html from '../../src/ml_parser/ast';import {ParseLocation, ParseSourceFile, ParseSourceSpan} from '../../src/parse_util';import {serializeNodes} from '../ml_parser/util/util';import {_extractMessages} from './i18n_parser_spec';{  describe('TranslationBundle', () => {    const file = new ParseSourceFile('content', 'url');    const startLocation = new ParseLocation(file, 0, 0, 0);    const endLocation = new ParseLocation(file, 0, 0, 7);    const span = new ParseSourceSpan(startLocation, endLocation);    const srcNode = new i18n.Text('src', span);    it('should translate a plain text', () => {msgMap = {foo: [new i18n.Text('bar', null!)]};tb = new TranslationBundle(msgMap, null, (_) => 'foo');msg = new i18n.Message([srcNode], {}, {}, 'm', 'd', 'i');(serializeNodes(tb.get(msg))).toEqual(['bar']);    });    it('should translate html-like plain text', () => {msgMap = {foo: [new i18n.Text('<p>bar</p>', null!)]};tb = new TranslationBundle(msgMap, null, (_) => 'foo');msg = new i18n.Message([srcNode], {}, {}, 'm', 'd', 'i');nodes = tb.get(msg);(nodes.length).toEqual(1);textNode: html.Text = nodes[0] as any;(textNode instanceof html.Text).toEqual(true);(textNode.value).toBe('<p>bar</p>');    });    it('should translate a message with placeholder', () => {msgMap = { [new i18n.Text('bar', null!),new i18n.Placeholder('', 'ph1', null!),phMap = { createPlaceholder('*phContent*'),tb = new TranslationBundle(msgMap, null, (_) => 'foo');msg = new i18n.Message([srcNode], phMap, {}, 'm', 'd', 'i');(serializeNodes(tb.get(msg))).toEqual(['bar*phContent*']);    });    it('should translate a message with placeholder referencing messages', () => {msgMap = { [new i18n.Text('--', null!),new i18n.Placeholder('', 'ph1', null!),new i18n.Text('++', null!), [new i18n.Text('*refMsg*', null!),refMsg = new i18n.Message([srcNode], {}, {}, 'm', 'd', 'i');msg = new i18n.Message([srcNode], {}, {ph1: refMsg}, 'm', 'd', 'i');unt = 0;digest = (_: any) => count++ ? 'ref' : 'foo';tb = new TranslationBundle(msgMap, null, digest);(serializeNodes(tb.get(msg))).toEqual(['--*refMsg*++']);    });    it('should use the original message or throw when a translation is not found', () => {src =`<some-tag>some text{{ some_expression }}</some-tag>{count, plural, =0 {no} few {a <b>few</b>}}`;messages = _extractMessages(`<div i18n>${src}</div>`);digest = (_: any) => `no matching id`;ty message map -> use source messages in Ignore mode = new TranslationBundle({}, null, digest, null!, MissingTranslationStrategy.Ignore);(serializeNodes(tb.get(messages[0])).join('')).toEqual(src);ty message map -> use source messages in Warning modeew TranslationBundle({}, null, digest, null!, MissingTranslationStrategy.Warning);(serializeNodes(tb.get(messages[0])).join('')).toEqual(src);ty message map -> throw in Error modeew TranslationBundle({}, null, digest, null!, MissingTranslationStrategy.Error);(() => serializeNodes(tb.get(messages[0])).join('')).toThrow();    });    describe('errors reporting', () => {ould report unknown placeholders', () => {t msgMap = {foo: [ new i18n.Text('bar', null!), new i18n.Placeholder('', 'ph1', span),]t tb = new TranslationBundle(msgMap, null, (_) => 'foo');t msg = new i18n.Message([srcNode], {}, {}, 'm', 'd', 'i');ct(() => tb.get(msg)).toThrowError(/Unknown placeholder/);ould report missing translation', () => {t tb = new TranslationBundle({}, null, (_) => 'foo', null!, MissingTranslationStrategy.Error);t msg = new i18n.Message([srcNode], {}, {}, 'm', 'd', 'i');ct(() => tb.get(msg)).toThrowError(/Missing translation for message "foo"/);ould report missing translation with MissingTranslationStrategy.Warning', () => {t log: string[] = [];t console = {log: (msg: string) => { throw `unexpected`;},warn: (msg: string) => log.push(msg),t tb = new TranslationBundle( {}, 'en', (_) => 'foo', null!, MissingTranslationStrategy.Warning, console);t msg = new i18n.Message([srcNode], {}, {}, 'm', 'd', 'i');ct(() => tb.get(msg)).not.toThrowError();ct(log.length).toEqual(1);ct(log[0]).toMatch(/Missing translation for message "foo" for locale "en"/);ould not report missing translation with MissingTranslationStrategy.Ignore', () => {t tb = new TranslationBundle({}, null, (_) => 'foo', null!, MissingTranslationStrategy.Ignore);t msg = new i18n.Message([srcNode], {}, {}, 'm', 'd', 'i');ct(() => tb.get(msg)).not.toThrowError();ould report missing referenced message', () => {t msgMap = {foo: [new i18n.Placeholder('', 'ph1', span)],t refMsg = new i18n.Message([srcNode], {}, {}, 'm', 'd', 'i');t msg = new i18n.Message([srcNode], {}, {ph1: refMsg}, 'm', 'd', 'i');count = 0;t digest = (_: any) => count++ ? 'ref' : 'foo';t tb = new TranslationBundle(msgMap, null, digest, null!, MissingTranslationStrategy.Error);ct(() => tb.get(msg)).toThrowError(/Missing translation for message "ref"/);ould report invalid translated html', () => {t msgMap = {foo: [ new i18n.Text('text', null!), new i18n.Placeholder('', 'ph1', null!),]t phMap = {ph1: createPlaceholder('</b>'),t tb = new TranslationBundle(msgMap, null, (_) => 'foo');t msg = new i18n.Message([srcNode], phMap, {}, 'm', 'd', 'i');ct(() => tb.get(msg)).toThrowError(/Unexpected closing tag "b"/);    });  });}function createPlaceholder(text: string): i18n.MessagePlaceholder {  const file = new ParseSourceFile(text, 'file://test');  const start = new ParseLocation(file, 0, 0, 0);  const end = new ParseLocation(file, text.length, 0, text.length);  return {    text,    sourceSpan: new ParseSourceSpan(start, end),  };}