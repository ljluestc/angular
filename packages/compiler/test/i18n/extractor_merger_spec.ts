/** * @license * Copyright Google LLC All Rights Reserved. * * Use of this source code is governed by an MIT-style license that can be * found in the LICENSE file at https://angular.io/license */import {DEFAULT_INTERPOLATION_CONFIG, HtmlParser} from '@angular/compiler';import {MissingTranslationStrategy} from '@angular/core';import {digest, serializeNodes as serializeI18nNodes} from '../../src/i18n/digest';import {extractMessages, mergeTranslations} from '../../src/i18n/extractor_merger';import * as i18n from '../../src/i18n/i18n_ast';import {TranslationBundle} from '../../src/i18n/translation_bundle';import * as html from '../../src/ml_parser/ast';import {serializeNodes as serializeHtmlNodes} from '../ml_parser/util/util';{  describe('Extractor', () => {    describe('elements', () => {ould extract from elements', () => {ct(extract('<div i18n="m|d|e">text<span>nested</span></div>')).toEqual([[ ['text', '<ph tag name="START_TAG_SPAN">nested</ph name="CLOSE_TAG_SPAN">'], 'm', 'd|e', ''],ould extract from attributes', () => {ct( extract( '<div i18n="m1|d1"><span i18n-title="m2|d2" title="single child">nested</span></div>')) .toEqual([   [['<ph tag name="START_TAG_SPAN">nested</ph name="CLOSE_TAG_SPAN">'], 'm1', 'd1', ''],   [['single child'], 'm2', 'd2', ''], ]);ould extract from attributes with id', () => {ct( extract( '<div i18n="m1|d1@@i1"><span i18n-title="m2|d2@@i2" title="single child">nested</span></div>')) .toEqual([   [ ['<ph tag name="START_TAG_SPAN">nested</ph name="CLOSE_TAG_SPAN">'], 'm1', 'd1', 'i1'   ],   [['single child'], 'm2', 'd2', 'i2'], ]);ould trim whitespace from custom ids (but not meanings)', () => {ct(extract('<div i18n="\n   m1|d1@@i1\n   ">test</div>')).toEqual([[['test'], '\n   m1', 'd1', 'i1'],ould extract from attributes without meaning and with id', () => {ct( extract( '<div i18n="d1@@i1"><span i18n-title="d2@@i2" title="single child">nested</span></div>')) .toEqual([   [['<ph tag name="START_TAG_SPAN">nested</ph name="CLOSE_TAG_SPAN">'], '', 'd1', 'i1'],   [['single child'], '', 'd2', 'i2'], ]);ould extract from attributes with id only', () => {ct( extract( '<div i18n="@@i1"><span i18n-title="@@i2" title="single child">nested</span></div>')) .toEqual([   [['<ph tag name="START_TAG_SPAN">nested</ph name="CLOSE_TAG_SPAN">'], '', '', 'i1'],   [['single child'], '', '', 'i2'], ]);ould extract from ICU messages', () => {ct( extract( '<div i18n="m|d">{count, plural, =0 { <p i18n-title i18n-desc title="title" desc="desc"></p>}}</div>')) .toEqual([   [ [   '{count, plural, =0 {[<ph tag name="START_PARAGRAPH"></ph name="CLOSE_PARAGRAPH">]}}' ], 'm', 'd', ''   ],   [['title'], '', '', ''],   [['desc'], '', '', ''], ]);ould not create a message for empty elements', () => {ct(extract('<div i18n="m|d"></div>')).toEqual([]);ould ignore implicit elements in translatable elements', () => {ct(extract('<div i18n="m|d"><p></p></div>', ['p'])).toEqual([[['<ph tag name="START_PARAGRAPH"></ph name="CLOSE_PARAGRAPH">'], 'm', 'd', '']    });    describe('blocks', () => {ould extract from elements inside block groups', () => {ct(extract(    '{#defer}<span i18n="a|b|c">main <span>nested</span></span>' +    '{:loading}<div i18n="d|e|f">loading <span>nested</span></div>' +    '{:placeholder}<strong i18n="g|h|i">placeholder <span>nested</span></strong>' +    '{/defer}')) .toEqual([   [ ['main ', '<ph tag name="START_TAG_SPAN">nested</ph name="CLOSE_TAG_SPAN">'], 'a', 'b|c', ''   ],   [ ['loading ', '<ph tag name="START_TAG_SPAN">nested</ph name="CLOSE_TAG_SPAN">'], 'd', 'e|f', ''   ],   [ ['placeholder ', '<ph tag name="START_TAG_SPAN">nested</ph name="CLOSE_TAG_SPAN">'], 'g', 'h|i', ''   ] ]);ould extract from i18n comment blocks inside block groups', () => {ct( extract( '{#defer}<!-- i18n: mainMeaning|mainDesc -->main message<!-- /i18n -->' + '{:loading}<!-- i18n: loadingMeaning|loadingDesc -->loading message<!-- /i18n -->' + '{:placeholder}<!-- i18n: placeholderMeaning|placeholderDesc -->placeholder message<!-- /i18n -->' + '{/defer}')) .toEqual([   [['main message'], 'mainMeaning', 'mainDesc', ''],   [['loading message'], 'loadingMeaning', 'loadingDesc', ''],   [['placeholder message'], 'placeholderMeaning', 'placeholderDesc', ''] ]);ould extract ICUs from elements inside block groups', () => {ct(extract(    '{#defer}<div i18n="a|b">{count, plural, =0 {mainText}}</div>' +    '{:loading}<div i18n="c|d">{count, plural, =0 {loadingText}}</div>' +    '{:placeholder}<div i18n="e|f">{count, plural, =0 {placeholderText}}</div>' +    '{/defer}')) .toEqual([   [['{count, plural, =0 {[mainText]}}'], 'a', 'b', ''],   [['{count, plural, =0 {[loadingText]}}'], 'c', 'd', ''],   [['{count, plural, =0 {[placeholderText]}}'], 'e', 'f', ''] ]);ould not extract messages from ICUs directly inside block groups', () => {t expression = '{count, plural, =0 {text}}';ct(extract(    `{#defer}${expression}` +    `{:loading}${expression}` +    `{:placeholder}${expression}` +    `{/defer}`)) .toEqual([]);ould handle blocks inside of translated elements', () => {ct(extract('<span i18n="a|b|c">{#if cond}main content{:else}else content{/if}</span>')) .toEqual([[['[[main content], [else content]]'], 'a', 'b|c', '']]);ould handle blocks inside of translated elements', () => {ct(extract('<span i18n="a|b|c">{#if cond}main content{:else}else content{/if}</span>')) .toEqual([[['[[main content], [else content]]'], 'a', 'b|c', '']]);    });    describe('i18n comment blocks', () => {ould extract from blocks', () => {ct(extract(`<!-- i18n: meaning1|desc1 -->message1<!-- /i18n -->: desc2 -->message2<!-- /i18n --> -->message3<!-- /i18n -->: meaning4|desc4@@id4 -->message4<!-- /i18n -->: @@id5 -->message5<!-- /i18n -->`)) .toEqual([   [['message1'], 'meaning1', 'desc1', ''], [['message2'], '', 'desc2', ''],   [['message3'], '', '', ''], [['message4'], 'meaning4', 'desc4', 'id4'],   [['message5'], '', '', 'id5'] ]);ould ignore implicit elements in blocks', () => {ct(extract('<!-- i18n:m|d --><p></p><!-- /i18n -->', ['p'])).toEqual([[['<ph tag name="START_PARAGRAPH"></ph name="CLOSE_PARAGRAPH">'], 'm', 'd', '']ould extract siblings', () => {ct( extract( `<!-- i18n -->text<p>html<b>nested</b></p>{count, plural, =0 {<span>html</span>}}{{interp}}<!-- /i18n -->`)) .toEqual([   [ [   '{count, plural, =0 {[<ph tag name="START_TAG_SPAN">html</ph name="CLOSE_TAG_SPAN">]}}' ], '', '', ''   ],   [ [   'text',   '<ph tag name="START_PARAGRAPH">html, <ph tag' +e="START_BOLD_TEXT">nested</ph name="CLOSE_BOLD_TEXT"></ph name="CLOSE_PARAGRAPH">',   '<ph icu name="ICU">{count, plural, =0 {[<ph tag' +e="START_TAG_SPAN">html</ph name="CLOSE_TAG_SPAN">]}}</ph>',   '[<ph name="INTERPOLATION">interp</ph>]' ], '', '', ''   ], ]);ould ignore other comments', () => {ct(extract(`<!-- i18n: meaning1|desc1@@id1 --><!-- other -->message1<!-- /i18n -->`)) .toEqual([   [['message1'], 'meaning1', 'desc1', 'id1'], ]);ould not create a message for empty blocks', () => {ct(extract(`<!-- i18n: meaning1|desc1 --><!-- /i18n -->`)).toEqual([]);    });    describe('ICU messages', () => {ould extract ICU messages from translatable elements', () => {ingle message when ICU is the only childrenct(extract('<div i18n="m|d">{count, plural, =0 {text}}</div>')).toEqual([[['{count, plural, =0 {[text]}}'], 'm', 'd', ''],ingle message when ICU is the only (implicit) childrenct(extract('<div>{count, plural, =0 {text}}</div>', ['div'])).toEqual([[['{count, plural, =0 {[text]}}'], '', '', ''],ne message for the element content and one message for the ICUct(extract('<div i18n="m|d@@i">before{count, plural, =0 {text}}after</div>')).toEqual([[ ['before', '<ph icu name="ICU">{count, plural, =0 {[text]}}</ph>', 'after'], 'm', 'd', 'i'],[['{count, plural, =0 {[text]}}'], '', '', ''],ould extract ICU messages from translatable block', () => {ingle message when ICU is the only childrenct(extract('<!-- i18n:m|d -->{count, plural, =0 {text}}<!-- /i18n -->')).toEqual([[['{count, plural, =0 {[text]}}'], 'm', 'd', ''],ne message for the block content and one message for the ICUct(extract('<!-- i18n:m|d -->before{count, plural, =0 {text}}after<!-- /i18n -->')) .toEqual([   [['{count, plural, =0 {[text]}}'], '', '', ''],   [ ['before', '<ph icu name="ICU">{count, plural, =0 {[text]}}</ph>', 'after'], 'm', 'd', ''   ], ]);ould not extract ICU messages outside of i18n sections', () => {ct(extract('{count, plural, =0 {text}}')).toEqual([]);ould ignore nested ICU messages', () => {ct(extract('<div i18n="m|d">{count, plural, =0 { {sex, select, male {m}} }}</div>')) .toEqual([   [['{count, plural, =0 {[{sex, select, male {[m]}},  ]}}'], 'm', 'd', ''], ]);ould ignore implicit elements in non translatable ICU messages', () => {ct(extract(    '<div i18n="m|d@@i">{count, plural, =0 { {sex, select, male {<p>ignore</p>}}' +</div>',    ['p'])) .toEqual([[   [ '{count, plural, =0 {[{sex, select, male {[<ph tag name="START_PARAGRAPH">ignore</ph name="CLOSE_PARAGRAPH">]}},  ]}}'   ],   'm', 'd', 'i' ]]);ould ignore implicit elements in non translatable ICU messages', () => {ct(extract('{count, plural, =0 { {sex, select, male {<p>ignore</p>}} }}', ['p'])) .toEqual([]);    });    describe('attributes', () => {ould extract from attributes outside of translatable sections', () => {ct(extract('<div i18n-title="m|d@@i" title="msg"></div>')).toEqual([[['msg'], 'm', 'd', 'i'],ould extract from attributes in translatable elements', () => {ct(extract('<div i18n><p><b i18n-title="m|d@@i" title="msg"></b></p></div>')).toEqual([[ ['<ph tag name="START_PARAGRAPH"><ph tag name="START_BOLD_TEXT"></ph' +  ' name="CLOSE_BOLD_TEXT"></ph name="CLOSE_PARAGRAPH">'], '', '', ''],[['msg'], 'm', 'd', 'i'],ould extract from attributes in translatable blocks', () => {ct(extract('<!-- i18n --><p><b i18n-title="m|d" title="msg"></b></p><!-- /i18n -->')) .toEqual([   [['msg'], 'm', 'd', ''],   [ ['<ph tag name="START_PARAGRAPH"><ph tag name="START_BOLD_TEXT"></ph' +  ' name="CLOSE_BOLD_TEXT"></ph name="CLOSE_PARAGRAPH">'], '', '', ''   ], ]);ould extract from attributes in translatable ICUs', () => {ct(extract(`<!-- i18n -->{count, plural, =0 {<p><b i18n-title="m|d@@i"  title="msg"></b></p>}}<!-- /i18n -->`)) .toEqual([   [['msg'], 'm', 'd', 'i'],   [ [   '{count, plural, =0 {[<ph tag name="START_PARAGRAPH"><ph tag' +   ' name="START_BOLD_TEXT"></ph name="CLOSE_BOLD_TEXT"></ph name="CLOSE_PARAGRAPH">]}}' ], '', '', ''   ], ]);ould extract from attributes in non translatable ICUs', () => {ct(extract('{count, plural, =0 {<p><b i18n-title="m|d" title="msg"></b></p>}}')) .toEqual([   [['msg'], 'm', 'd', ''], ]);ould not create a message for empty attributes', () => {ct(extract('<div i18n-title="m|d" title></div>')).toEqual([]);    });    describe('implicit elements', () => {ould extract from implicit elements', () => {ct(extract('<b>bold</b><i>italic</i>', ['b'])).toEqual([[['bold'], '', '', ''],ould allow nested implicit elements', () => {result: any[] = undefined!;ct(() => {result = extract('<div>outer<div>inner</div></div>', ['div']);ot.toThrow();ct(result).toEqual([[['outer', '<ph tag name="START_TAG_DIV">inner</ph name="CLOSE_TAG_DIV">'], '', '', ''],    });    describe('implicit attributes', () => {ould extract implicit attributes', () => {ct(extract('<b title="bb">bold</b><i title="ii">italic</i>', [], {'b': ['title']})) .toEqual([   [['bb'], '', '', ''], ]);    });    describe('errors', () => {be('elements', () => {should report nested translatable elements', () => {expect(extractErrors(`<p i18n><b i18n></b></p>`)).toEqual([ [   'Could not mark an element as translatable inside a translatable section',   '<b i18n></b>' ],]);should report translatable elements in implicit elements', () => {expect(extractErrors(`<p><b i18n></b></p>`, ['p'])).toEqual([ [   'Could not mark an element as translatable inside a translatable section',   '<b i18n></b>' ],]);should report translatable elements in translatable blocks', () => {expect(extractErrors(`<!-- i18n --><b i18n></b><!-- /i18n -->`)).toEqual([ [   'Could not mark an element as translatable inside a translatable section',   '<b i18n></b>' ],]);be('blocks', () => {should report nested blocks', () => {expect(extractErrors(`<!-- i18n --><!-- i18n --><!-- /i18n --><!-- /i18n -->`)).toEqual([ ['Could not start a block inside a translatable section', '<!-- i18n -->'], ['Trying to close an unopened block', '<!-- /i18n -->'],]);should report unclosed blocks', () => {expect(extractErrors(`<!-- i18n -->`)).toEqual([ ['Unclosed block', '<!-- i18n -->'],]);should report translatable blocks in translatable elements', () => {expect(extractErrors(`<p i18n><!-- i18n --><!-- /i18n --></p>`)).toEqual([ ['Could not start a block inside a translatable section', '<!-- i18n -->'], ['Trying to close an unopened block', '<!-- /i18n -->'],]);should report translatable blocks in implicit elements', () => {expect(extractErrors(`<p><!-- i18n --><!-- /i18n --></p>`, ['p'])).toEqual([ ['Could not start a block inside a translatable section', '<!-- i18n -->'], ['Trying to close an unopened block', '<!-- /i18n -->'],]);should report when start and end of a block are not at the same level', () => {expect(extractErrors(`<!-- i18n --><p><!-- /i18n --></p>`)).toEqual([ ['I18N blocks should not cross element boundaries', '<!-- /i18n -->'], ['Unclosed block', '<p><!-- /i18n --></p>'],]);expect(extractErrors(`<p><!-- i18n --></p><!-- /i18n -->`)).toEqual([ ['I18N blocks should not cross element boundaries', '<!-- /i18n -->'], ['Unclosed block', '<!-- /i18n -->'],]);    });  });  describe('Merger', () => {    describe('elements', () => {ould merge elements', () => {t HTML = `<p i18n="m|d">foo</p>`;ct(fakeTranslate(HTML)).toEqual('<p>**foo**</p>');ould merge nested elements', () => {t HTML = `<div>before<p i18n="m|d">foo</p><!-- comment --></div>`;ct(fakeTranslate(HTML)).toEqual('<div>before<p>**foo**</p></div>');ould merge empty messages', () => {t HTML = `<div i18n>some element</div>`;t htmlNodes: html.Node[] = parseHtml(HTML);t messages: i18n.Message[] = extractMessages(htmlNodes, DEFAULT_INTERPOLATION_CONFIG, [], {}).messages;ct(messages.length).toEqual(1);t i18nMsgMap: {[id: string]: i18n.Node[]} = {};MsgMap[digest(messages[0])] = [];t translations = new TranslationBundle(i18nMsgMap, null, digest);t output = mergeTranslations(htmlNodes, translations, DEFAULT_INTERPOLATION_CONFIG, [], {});ct(output.errors).toEqual([]);ct(serializeHtmlNodes(output.rootNodes).join('')).toEqual(`<div></div>`);    });    describe('i18n comment blocks', () => {ould console.warn if we use i18n comments', () => {ODO(ocombe): expect a warning message when we have a proper log serviceact('<!-- i18n --><p><b i18n-title="m|d" title="msg"></b></p><!-- /i18n -->');ould merge blocks', () => {t HTML = `before<!-- i18n --><p>foo</p><span><i>bar</i></span><!-- /i18n -->after`;ct(fakeTranslate(HTML)) .toEqual( 'before**[ph tag name="START_PARAGRAPH">foo[/ph name="CLOSE_PARAGRAPH">[ph tag' + ' name="START_TAG_SPAN">[ph tag name="START_ITALIC_TEXT">bar[/ph' + ' name="CLOSE_ITALIC_TEXT">[/ph name="CLOSE_TAG_SPAN">**after');ould merge nested blocks', () => {t HTML = `<div>before<!-- i18n --><p>foo</p><span><i>bar</i></span><!-- /i18n -->after</div>`;ct(fakeTranslate(HTML)) .toEqual( '<div>before**[ph tag name="START_PARAGRAPH">foo[/ph name="CLOSE_PARAGRAPH">[ph' + ' tag name="START_TAG_SPAN">[ph tag name="START_ITALIC_TEXT">bar[/ph' + ' name="CLOSE_ITALIC_TEXT">[/ph name="CLOSE_TAG_SPAN">**after</div>');    });    describe('attributes', () => {ould merge attributes', () => {t HTML = `<p i18n-title="m|d" title="foo"></p>`;ct(fakeTranslate(HTML)).toEqual('<p title="**foo**"></p>');ould merge attributes with ids', () => {t HTML = `<p i18n-title="@@id" title="foo"></p>`;ct(fakeTranslate(HTML)).toEqual('<p title="**foo**"></p>');ould merge nested attributes', () => {t HTML = `<div>{count, plural, =0 {<p i18n-title title="foo"></p>}}</div>`;ct(fakeTranslate(HTML)) .toEqual('<div>{count, plural, =0 {<p title="**foo**"></p>}}</div>');ould merge attributes without values', () => {t HTML = `<p i18n-title="m|d" title=""></p>`;ct(fakeTranslate(HTML)).toEqual('<p title=""></p>');ould merge empty attributes', () => {t HTML = `<div i18n-title title="some attribute">some element</div>`;t htmlNodes: html.Node[] = parseHtml(HTML);t messages: i18n.Message[] = extractMessages(htmlNodes, DEFAULT_INTERPOLATION_CONFIG, [], {}).messages;ct(messages.length).toEqual(1);t i18nMsgMap: {[id: string]: i18n.Node[]} = {};MsgMap[digest(messages[0])] = [];t translations = new TranslationBundle(i18nMsgMap, null, digest);t output = mergeTranslations(htmlNodes, translations, DEFAULT_INTERPOLATION_CONFIG, [], {});ct(output.errors).toEqual([]);ct(serializeHtmlNodes(output.rootNodes).join('')) .toEqual(`<div title="">some element</div>`);    });    describe('no translations', () => {ould remove i18n attributes', () => {t HTML = `<p i18n="m|d">foo</p>`;ct(fakeNoTranslate(HTML)).toEqual('<p>foo</p>');ould remove i18n- attributes', () => {t HTML = `<p i18n-title="m|d" title="foo"></p>`;ct(fakeNoTranslate(HTML)).toEqual('<p title="foo"></p>');ould remove i18n comment blocks', () => {t HTML = `before<!-- i18n --><p>foo</p><span><i>bar</i></span><!-- /i18n -->after`;ct(fakeNoTranslate(HTML)).toEqual('before<p>foo</p><span><i>bar</i></span>after');ould remove nested i18n markup', () => {t HTML = `<!-- i18n --><span someAttr="ok">foo</span><div>{count, plural, =0 {<p i18n-title title="foo"></p>}}</div><!-- /i18n -->`;ct(fakeNoTranslate(HTML)) .toEqual( '<span someAttr="ok">foo</span><div>{count, plural, =0 {<p title="foo"></p>}}</div>');    });  });}function parseHtml(html: string): html.Node[] {  const htmlParser = new HtmlParser();  const parseResult = htmlParser.parse('extractor spec', {tokenizeExpansionForms: true, tokenizeBlocks: true});  if (parseResult.errors.length > 1) {    throw new Error(`unexpected parse errors: ${parseResult.errors.join('\n')}`);  }  return parseResult.rootNodes;}function fakeTranslate(    content: string, implicitTags: string[] = [],    implicitAttrs: {[k: string]: string[]} = {}): string {  const htmlNodes: html.Node[] = parseHtml(content);  const messages: i18n.Message[] =tMessages(htmlNodes, DEFAULT_INTERPOLATION_CONFIG, implicitTags, implicitAttrs).messages;  const i18nMsgMap: {[id: string]: i18n.Node[]} = {};  messages.forEach(message => {    const id = digest(message);    const text = serializeI18nNodes(message.nodes).join('').replace(/</g, '[');    i18nMsgMap[id] = [new i18n.Text(`**${text}**`, null!)];  });  const translationBundle = new TranslationBundle(i18nMsgMap, null, digest);  const output = mergeTranslations(des, translationBundle, DEFAULT_INTERPOLATION_CONFIG, implicitTags, implicitAttrs);  expect(output.errors).toEqual([]);  return serializeHtmlNodes(output.rootNodes).join('');}function fakeNoTranslate(    content: string, implicitTags: string[] = [],    implicitAttrs: {[k: string]: string[]} = {}): string {  const htmlNodes: html.Node[] = parseHtml(content);  const translationBundle = new TranslationBundle(ll, digest, undefined, MissingTranslationStrategy.Ignore, console);  const output = mergeTranslations(des, translationBundle, DEFAULT_INTERPOLATION_CONFIG, implicitTags, implicitAttrs);  expect(output.errors).toEqual([]);  return serializeHtmlNodes(output.rootNodes).join('');}function extract(    html: string, implicitTags: string[] = [],    implicitAttrs: {[k: string]: string[]} = {}): [string[], string, string, string][] {  const result =tMessages(parseHtml(html), DEFAULT_INTERPOLATION_CONFIG, implicitTags, implicitAttrs);  if (result.errors.length > 0) {    throw new Error(`unexpected errors: ${result.errors.join('\n')}`);  }  // clang-format off  // https://github.com/angular/clang-format/issues/35  return result.messages.map(    message => [serializeI18nNodes(message.nodes), message.meaning, message.description, message.id]) as [string[], string, string, string][];  // clang-format on}function extractErrors(    html: string, implicitTags: string[] = [], implicitAttrs: {[k: string]: string[]} = {}): any[] {  const errors =tMessages(parseHtml(html), DEFAULT_INTERPOLATION_CONFIG, implicitTags, implicitAttrs).errors;  return errors.map((e): [string, string] => [e.msg, e.span.toString()]);}