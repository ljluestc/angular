/** * @license * Copyright Google LLC All Rights Reserved. * * Use of this source code is governed by an MIT-style license that can be * found in the LICENSE file at https://angular.io/license */import {AbsoluteSourceSpan, ASTWithSource, BindingPipe, Call, EmptyExpr, Interpolation, ParserError, PropertyRead, TemplateBinding, VariableBinding} from '@angular/compiler/src/expression_parser/ast';import {Lexer} from '@angular/compiler/src/expression_parser/lexer';import {Parser, SplitInterpolation} from '@angular/compiler/src/expression_parser/parser';import {expect} from '@angular/platform-browser/testing/src/matchers';import {unparse, unparseWithSpan} from './utils/unparser';import {validate} from './utils/validator';describe('parser', () => {  describe('parseAction', () => {    it('should parse numbers', () => {ction('1');    });    it('should parse strings', () => {ction('\'1\'', '"1"');ction('"1"');    });    it('should parse null', () => {ction('null');    });    it('should parse undefined', () => {ction('undefined');    });    it('should parse unary - and + expressions', () => {ction('-1', '-1');ction('+1', '+1');ction(`-'1'`, `-"1"`);ction(`+'1'`, `+"1"`);    });    it('should parse unary ! expressions', () => {ction('!true');ction('!!true');ction('!!!true');    });    it('should parse postfix ! expression', () => {ction('true!');ction('a!.b');ction('a!!!!.b');ction('a!()');ction('a.b!()');    });    it('should parse multiplicative expressions', () => {ction('3*4/2%5', '3 * 4 / 2 % 5');    });    it('should parse additive expressions', () => {ction('3 + 6 - 2');    });    it('should parse relational expressions', () => {ction('2 < 3');ction('2 > 3');ction('2 <= 2');ction('2 >= 2');    });    it('should parse equality expressions', () => {ction('2 == 3');ction('2 != 3');    });    it('should parse strict equality expressions', () => {ction('2 === 3');ction('2 !== 3');    });    it('should parse expressions', () => {ction('true && true');ction('true || false');ction('null ?? 0');ction('null ?? undefined ?? 0');    });    it('should parse grouped expressions', () => {ction('(1 + 2) * 3', '1 + 2 * 3');    });    it('should ignore comments in expressions', () => {ction('a //comment', 'a');    });    it('should retain // in string literals', () => {ction(`"http://www.google.com"`, `"http://www.google.com"`);    });    it('should parse an empty string', () => {ction('');    });    describe('literals', () => {ould parse array', () => {kAction('[1][0]');kAction('[[1]][0][0]');kAction('[]');kAction('[].length');kAction('[1, 2].length');kAction('[1, 2,]', '[1, 2]');ould parse map', () => {kAction('{}');kAction('{a: 1, "b": 2}[2]');kAction('{}["a"]');kAction('{a: 1, b: 2,}', '{a: 1, b: 2}');ould only allow identifier, string, or keyword as map key', () => {ctActionError('{(:0}', 'expected identifier, keyword, or string');ctActionError('{1234:0}', 'expected identifier, keyword, or string');ctActionError('{#myField:0}', 'expected identifier, keyword or string');ould parse property shorthand declarations', () => {kAction('{a, b, c}', '{a: a, b: b, c: c}');kAction('{a: 1, b}', '{a: 1, b: b}');kAction('{a, b: 1}', '{a: a, b: 1}');kAction('{a: 1, b, c: 2}', '{a: 1, b: b, c: 2}');ould not allow property shorthand declaration on quoted properties', () => {ctActionError('{"a-b"}', 'expected : at column 7');ould not infer invalid identifiers as shorthand property declarations', () => {ctActionError('{a.b}', 'expected } at column 3');ctActionError('{a["b"]}', 'expected } at column 3');ctActionError('{1234}', ' expected identifier, keyword, or string at column 2');    });    describe('member access', () => {ould parse field access', () => {kAction('a');kAction('this.a', 'a');kAction('a.a');ould error for private identifiers with implicit receiver', () => {kActionWithError( '#privateField', '', 'Private identifiers are not supported. Unexpected private identifier: #privateField at column 1');ould only allow identifier or keyword as member names', () => {kActionWithError('x.', 'x.', 'identifier or keyword');kActionWithError('x.(', 'x.', 'identifier or keyword');kActionWithError('x. 1234', 'x.', 'identifier or keyword');kActionWithError('x."foo"', 'x.', 'identifier or keyword');kActionWithError( 'x.#privateField', 'x.', 'Private identifiers are not supported. Unexpected private identifier: #privateField, expected identifier or keyword');ould parse safe field access', () => {kAction('a?.a');kAction('a.a?.a');ould parse incomplete safe field accesses', () => {kActionWithError('a?.a.', 'a?.a.', 'identifier or keyword');kActionWithError('a.a?.a.', 'a.a?.a.', 'identifier or keyword');kActionWithError('a.a?.a?. 1234', 'a.a?.a?.', 'identifier or keyword');    });    describe('property write', () => {ould parse property writes', () => {kAction('a.a = 1 + 2');kAction('this.a.a = 1 + 2', 'a.a = 1 + 2');kAction('a.a.a = 1 + 2');be('malformed property writes', () => {should recover on empty rvalues', () => {checkActionWithError('a.a = ', 'a.a = ', 'Unexpected end of expression');should recover on incomplete rvalues', () => {checkActionWithError('a.a = 1 + ', 'a.a = 1 + ', 'Unexpected end of expression');should recover on missing properties', () => {checkActionWithError(   'a. = 1', 'a. = 1', 'Expected identifier for property access at column 2');should error on writes after a property write', () => {const ast = parseAction('a.a = 1 = 2');expect(unparse(ast)).toEqual('a.a = 1');validate(ast);expect(ast.errors.length).toBe(1);expect(ast.errors[0].message).toContain('Unexpected token \'=\'');    });    describe('calls', () => {ould parse calls', () => {kAction('fn()');kAction('add(1, 2)');kAction('a.add(1, 2)');kAction('fn().add(1, 2)');kAction('fn()(1, 2)');ould parse an EmptyExpr with a correct span for a trailing empty argument', () => {t ast = parseAction('fn(1, )').ast as Call;ct(ast.args[1]).toBeInstanceOf(EmptyExpr);t sourceSpan = (ast.args[1] as EmptyExpr).sourceSpan;ct([sourceSpan.start, sourceSpan.end]).toEqual([5, 6]);ould parse safe calls', () => {kAction('fn?.()');kAction('add?.(1, 2)');kAction('a.add?.(1, 2)');kAction('a?.add?.(1, 2)');kAction('fn?.().add?.(1, 2)');kAction('fn?.()?.(1, 2)');    });    describe('keyed read', () => {ould parse keyed reads', () => {kBinding('a["a"]');kBinding('this.a["a"]', 'a["a"]');kBinding('a.a["a"]');ould parse safe keyed reads', () => {kBinding('a?.["a"]');kBinding('this.a?.["a"]', 'a?.["a"]');kBinding('a.a?.["a"]');kBinding('a.a?.["a" | foo]', 'a.a?.[("a" | foo)]');be('malformed keyed reads', () => {should recover on missing keys', () => {checkActionWithError('a[]', 'a[]', 'Key access cannot be empty');should recover on incomplete expression keys', () => {checkActionWithError('a[1 + ]', 'a[1 + ]', 'Unexpected token ]');should recover on unterminated keys', () => {checkActionWithError(   'a[1 + 2', 'a[1 + 2]', 'Missing expected ] at the end of the expression');should recover on incomplete and unterminated keys', () => {checkActionWithError(   'a[1 + ', 'a[1 + ]', 'Missing expected ] at the end of the expression');    });    describe('keyed write', () => {ould parse keyed writes', () => {kAction('a["a"] = 1 + 2');kAction('this.a["a"] = 1 + 2', 'a["a"] = 1 + 2');kAction('a.a["a"] = 1 + 2');ould report on safe keyed writes', () => {ctActionError('a?.["a"] = 123', 'cannot be used in the assignment');be('malformed keyed writes', () => {should recover on empty rvalues', () => {checkActionWithError('a["a"] = ', 'a["a"] = ', 'Unexpected end of expression');should recover on incomplete rvalues', () => {checkActionWithError('a["a"] = 1 + ', 'a["a"] = 1 + ', 'Unexpected end of expression');should recover on missing keys', () => {checkActionWithError('a[] = 1', 'a[] = 1', 'Key access cannot be empty');should recover on incomplete expression keys', () => {checkActionWithError('a[1 + ] = 1', 'a[1 + ] = 1', 'Unexpected token ]');should recover on unterminated keys', () => {checkActionWithError('a[1 + 2 = 1', 'a[1 + 2] = 1', 'Missing expected ]');should recover on incomplete and unterminated keys', () => {const ast = parseAction('a[1 + = 1');expect(unparse(ast)).toEqual('a[1 + ] = 1');validate(ast);const errors = ast.errors.map(e => e.message);expect(errors.length).toBe(2);expect(errors[0]).toContain('Unexpected token =');expect(errors[1]).toContain('Missing expected ]');should error on writes after a keyed write', () => {const ast = parseAction('a[1] = 1 = 2');expect(unparse(ast)).toEqual('a[1] = 1');validate(ast);expect(ast.errors.length).toBe(1);expect(ast.errors[0].message).toContain('Unexpected token \'=\'');should recover on parenthesized empty rvalues', () => {const ast = parseAction('(a[1] = b) = c = d');expect(unparse(ast)).toEqual('a[1] = b');validate(ast);expect(ast.errors.length).toBe(1);expect(ast.errors[0].message).toContain('Unexpected token \'=\'');    });    describe('conditional', () => {ould parse ternary/conditional expressions', () => {kAction('7 == 3 + 4 ? 10 : 20');kAction('false ? 10 : 20');ould report incorrect ternary operator syntax', () => {ctActionError('true?1', 'Conditional expression true?1 requires all 3 expressions');    });    describe('assignment', () => {ould support field assignments', () => {kAction('a = 12');kAction('a.a.a = 123');kAction('a = 123; b = 234;');ould report on safe field assignments', () => {ctActionError('a?.a = 123', 'cannot be used in the assignment');ould support array updates', () => {kAction('a[0] = 200');    });    it('should error when using pipes', () => {ActionError('x|blah', 'Cannot have a pipe');    });    it('should store the source in the result', () => {(parseAction('someExpr', 'someExpr'));    });    it('should store the passed-in location', () => {(parseAction('someExpr', 'location').location).toBe('location');    });    it('should report when encountering interpolation', () => {ActionError('{{a()}}', 'Got interpolation ({{}}) where expression was expected');    });    it('should not report interpolation inside a string', () => {(parseAction(`"{{a()}}"`).errors).toEqual([]);(parseAction(`'{{a()}}'`).errors).toEqual([]);(parseAction(`"{{a('\\"')}}"`).errors).toEqual([]);(parseAction(`'{{a("\\'")}}'`).errors).toEqual([]);    });  });  describe('parse spans', () => {    it('should record property read span', () => {ast = parseAction('foo');(unparseWithSpan(ast)).toContain(['foo', 'foo']);(unparseWithSpan(ast)).toContain(['foo', '[nameSpan] foo']);    });    it('should record accessed property read span', () => {ast = parseAction('foo.bar');(unparseWithSpan(ast)).toContain(['foo.bar', 'foo.bar']);(unparseWithSpan(ast)).toContain(['foo.bar', '[nameSpan] bar']);    });    it('should record safe property read span', () => {ast = parseAction('foo?.bar');(unparseWithSpan(ast)).toContain(['foo?.bar', 'foo?.bar']);(unparseWithSpan(ast)).toContain(['foo?.bar', '[nameSpan] bar']);    });    it('should record call span', () => {ast = parseAction('foo()');(unparseWithSpan(ast)).toContain(['foo()', 'foo()']);(unparseWithSpan(ast)).toContain(['foo()', '[argumentSpan] ']);(unparseWithSpan(ast)).toContain(['foo', '[nameSpan] foo']);    });    it('should record call argument span', () => {ast = parseAction('foo(1 + 2)');(unparseWithSpan(ast)).toContain(['foo(1 + 2)', '[argumentSpan] 1 + 2']);    });    it('should record accessed call span', () => {ast = parseAction('foo.bar()');(unparseWithSpan(ast)).toContain(['foo.bar()', 'foo.bar()']);(unparseWithSpan(ast)).toContain(['foo.bar', '[nameSpan] bar']);    });    it('should record property write span', () => {ast = parseAction('a = b');(unparseWithSpan(ast)).toContain(['a = b', 'a = b']);(unparseWithSpan(ast)).toContain(['a = b', '[nameSpan] a']);    });    it('should record accessed property write span', () => {ast = parseAction('a.b = c');(unparseWithSpan(ast)).toContain(['a.b = c', 'a.b = c']);(unparseWithSpan(ast)).toContain(['a.b = c', '[nameSpan] b']);    });    it('should include parenthesis in spans', () => {n a LHS expression is parenthesized, the parenthesis on the left used to beluded from the span. This test verifies that the parenthesis are properly includedthe span for both LHS and RHS expressions.ps://github.com/angular/angular/issues/40721Span('(foo) && (bar)');Span('(foo) || (bar)');Span('(foo) == (bar)');Span('(foo) === (bar)');Span('(foo) != (bar)');Span('(foo) !== (bar)');Span('(foo) > (bar)');Span('(foo) >= (bar)');Span('(foo) < (bar)');Span('(foo) <= (bar)');Span('(foo) + (bar)');Span('(foo) - (bar)');Span('(foo) * (bar)');Span('(foo) / (bar)');Span('(foo) % (bar)');Span('(foo) | pipe');Span('(foo)()');Span('(foo).bar');Span('(foo)?.bar');Span('(foo).bar = (baz)');Span('(foo | pipe) == false');Span('(((foo) && bar) || baz) === true');on expectSpan(input: string) {ct(unparseWithSpan(parseBinding(input))).toContain([jasmine.any(String), input]);    });  });  describe('general error handling', () => {    it('should report an unexpected token', () => {ActionError('[1,2] trac', 'Unexpected token \'trac\'');    });    it('should report reasonable error for unconsumed tokens', () => {ActionError(')', 'Unexpected token ) at column 1 in [)]');    });    it('should report a missing expected token', () => {ActionError('a(b', 'Missing expected ) at the end of the expression [a(b]');    });  });  describe('parseBinding', () => {    describe('pipes', () => {ould parse pipes', () => {kBinding('a(b | c)', 'a((b | c))');kBinding('a.b(c.d(e) | f)', 'a.b((c.d(e) | f))');kBinding('[1, 2, 3] | a', '([1, 2, 3] | a)');kBinding('{a: 1, "b": 2} | c', '({a: 1, "b": 2} | c)');kBinding('a[b] | c', '(a[b] | c)');kBinding('a?.b | c', '(a?.b | c)');kBinding('true | a', '(true | a)');kBinding('a | b:c | d', '((a | b:c) | d)');kBinding('a | b:(c | d)', '(a | b:(c | d))');be('should parse incomplete pipes', () => {t cases: Array<[string, string, string, string]> = [[ 'should parse missing pipe names: end', 'a | b | ', '((a | b) | )', 'Unexpected end of input, expected identifier or keyword',],[ 'should parse missing pipe names: middle', 'a | | b', '((a | ) | b)', 'Unexpected token |, expected identifier or keyword',],[ 'should parse missing pipe names: start', ' | a | b', '(( | a) | b)', 'Unexpected token |',],[ 'should parse missing pipe args: end', 'a | b | c: ', '((a | b) | c:)', 'Unexpected end of expression',],[ 'should parse missing pipe args: middle', 'a | b: | c', '((a | b:) | c)', 'Unexpected token |',],[ 'should parse incomplete pipe args', 'a | b: (a | ) + | c', '((a | b:(a | ) + ) | c)', 'Unexpected token |',],(const [name, input, output, err] of cases) {it(name, () => { checkBinding(input, output); expectBindingError(input, err);});should parse an incomplete pipe with a source span that includes trailing whitespace',() => {  const bindingText = 'foo | ';  const binding = parseBinding(bindingText).ast as BindingPipe;  // The sourceSpan should include all characters of the input.  expect(rawSpan(binding.sourceSpan)).toEqual([0, bindingText.length]);  // The nameSpan should be positioned at the end of the input.  expect(rawSpan(binding.nameSpan)).toEqual([bindingText.length, bindingText.length]);});ould only allow identifier or keyword as formatter names', () => {ctBindingError('"Foo"|(', 'identifier or keyword');ctBindingError('"Foo"|1234', 'identifier or keyword');ctBindingError('"Foo"|"uppercase"', 'identifier or keyword');ctBindingError('"Foo"|#privateIdentifier"', 'identifier or keyword');ould not crash when prefix part is not tokenizable', () => {kBinding('"a:b"', '"a:b"');    });    it('should store the source in the result', () => {(parseBinding('someExpr').source).toBe('someExpr');    });    it('should store the passed-in location', () => {(parseBinding('someExpr', 'location').location).toBe('location');    });    it('should report chain expressions', () => {Error(parseBinding('1;2'), 'contain chained expression');    });    it('should report assignment', () => {Error(parseBinding('a=2'), 'contain assignments');    });    it('should report when encountering interpolation', () => {BindingError('{{a.b}}', 'Got interpolation ({{}}) where expression was expected');    });    it('should not report interpolation inside a string', () => {(parseBinding(`"{{exp}}"`).errors).toEqual([]);(parseBinding(`'{{exp}}'`).errors).toEqual([]);(parseBinding(`'{{\\"}}'`).errors).toEqual([]);(parseBinding(`'{{\\'}}'`).errors).toEqual([]);    });    it('should parse conditional expression', () => {inding('a < b ? a : b');    });    it('should ignore comments in bindings', () => {inding('a //comment', 'a');    });    it('should retain // in string literals', () => {inding(`"http://www.google.com"`, `"http://www.google.com"`);    });  });  describe('parseTemplateBindings', () => {    function humanize(bindings: TemplateBinding[]): Array<[string, string | null, boolean]> { bindings.map(binding => {t key = binding.key.source;t value = binding.value ? binding.value.source : null;t keyIsVar = binding instanceof VariableBinding;rn [key, value, keyIsVar];    }    function humanizeSpans(ings: TemplateBinding[], attr: string): Array<[string, string, string | null]> { bindings.map(binding => {t {sourceSpan, key, value} = binding;t sourceStr = attr.substring(sourceSpan.start, sourceSpan.end);t keyStr = attr.substring(key.span.start, key.span.end);valueStr = null;value) {const {start, end} = value instanceof ASTWithSource ? value.ast.sourceSpan : value.span;valueStr = attr.substring(start, end);rn [sourceStr, keyStr, valueStr];    }    it('should parse key and value', () => {cases: Array<[string, string, string | null, boolean, string, string, string | null]> =[ // expression, key, value, VariableBinding, source span, key span, value span ['*a=""', 'a', null, false, 'a="', 'a', null], ['*a="b"', 'a', 'b', false, 'a="b', 'a', 'b'], ['*a-b="c"', 'a-b', 'c', false, 'a-b="c', 'a-b', 'c'], ['*a="1+1"', 'a', '1+1', false, 'a="1+1', 'a', '1+1'],];onst [attr, key, value, keyIsVar, sourceSpan, keySpan, valueSpan] of cases) {t bindings = parseTemplateBindings(attr);ct(humanize(bindings)).toEqual([[key, value, keyIsVar],ct(humanizeSpans(bindings, attr)).toEqual([[sourceSpan, keySpan, valueSpan],    });    it('should variable declared via let', () => {bindings = parseTemplateBindings('*a="let b"');(humanize(bindings)).toEqual([ey, value, VariableBinding, null, false],, null, true],    });    it('should allow multiple pairs', () => {bindings = parseTemplateBindings('*a="1 b 2"');(humanize(bindings)).toEqual([ey, value, VariableBinding, '1', false],', '2', false],    });    it('should allow space and colon as separators', () => {bindings = parseTemplateBindings('*a="1,b 2"');(humanize(bindings)).toEqual([ey, value, VariableBinding, '1', false],', '2', false],    });    it('should store the templateUrl', () => {bindings = parseTemplateBindings('*a="1,b 2"', '/foo/bar.html');(humanize(bindings)).toEqual([ey, value, VariableBinding, '1', false],', '2', false],((bindings[0].value as ASTWithSource).location).toEqual('/foo/bar.html');    });    it('should support common usage of ngIf', () => {bindings = parseTemplateBindings('*ngIf="cond | pipe as foo, let x; ngIf as y"');(humanize(bindings)).toEqual([ key, value, VariableBinding ]If', 'cond | pipe', false],o', 'ngIf', true],, null, true],, 'ngIf', true],    });    it('should support common usage of ngFor', () => {ndings: TemplateBinding[];gs = parseTemplateBindings('*ngFor="let person of people"');(humanize(bindings)).toEqual([ key, value, VariableBinding ]For', null, false],rson', null, true],ForOf', 'people', false],gs = parseTemplateBindings('*ngFor="let item; of items | slice:0:1 as collection, trackBy: func; index as i"');(humanize(bindings)).toEqual([ key, value, VariableBinding ]For', null, false],em', null, true],ForOf', 'items | slice:0:1', false],llection', 'ngForOf', true],ForTrackBy', 'func', false],, 'index', true],gs = parseTemplateBindings('*ngFor="let item, of: [1,2,3] | pipe as items; let i=index, count as len"');(humanize(bindings)).toEqual([ key, value, VariableBinding ]For', null, false],em', null, true],ForOf', '[1,2,3] | pipe', false],ems', 'ngForOf', true],, 'index', true],n', 'count', true],    });    it('should parse pipes', () => {bindings = parseTemplateBindings('*key="value|pipe "');(humanize(bindings)).toEqual([ key, value, VariableBinding ]y', 'value|pipe', false],{value} = bindings[0];(value).toBeInstanceOf(ASTWithSource);((value as ASTWithSource).ast).toBeInstanceOf(BindingPipe);    });    describe('"let" binding', () => {ould support single declaration', () => {t bindings = parseTemplateBindings('*key="let i"');ct(humanize(bindings)).toEqual([// [ key, value, VariableBinding ]['key', null, false],['i', null, true],ould support multiple declarations', () => {t bindings = parseTemplateBindings('*key="let a; let b"');ct(humanize(bindings)).toEqual([// [ key, value, VariableBinding ]['key', null, false],['a', null, true],['b', null, true],ould support empty string assignment', () => {t bindings = parseTemplateBindings(`*key="let a=''; let b='';"`);ct(humanize(bindings)).toEqual([// [ key, value, VariableBinding ]['key', null, false],['a', '', true],['b', '', true],ould support key and value names with dash', () => {t bindings = parseTemplateBindings('*key="let i-a = j-a,"');ct(humanize(bindings)).toEqual([// [ key, value, VariableBinding ]['key', null, false],['i-a', 'j-a', true],ould support declarations with or without value assignment', () => {t bindings = parseTemplateBindings('*key="let item; let i = k"');ct(humanize(bindings)).toEqual([// [ key, value, VariableBinding ]['key', null, false],['item', null, true],['i', 'k', true],ould support declaration before an expression', () => {t bindings = parseTemplateBindings('*directive="let item in expr; let a = b"');ct(humanize(bindings)).toEqual([// [ key, value, VariableBinding ]['directive', null, false],['item', null, true],['directiveIn', 'expr', false],['a', 'b', true],    });    describe('"as" binding', () => {ould support single declaration', () => {t bindings = parseTemplateBindings('*ngIf="exp as local"');ct(humanize(bindings)).toEqual([// [ key, value, VariableBinding ]['ngIf', 'exp', false],['local', 'ngIf', true],ould support declaration after an expression', () => {t bindings = parseTemplateBindings('*ngFor="let item of items as iter; index as i"');ct(humanize(bindings)).toEqual([// [ key, value, VariableBinding ]['ngFor', null, false],['item', null, true],['ngForOf', 'items', false],['iter', 'ngForOf', true],['i', 'index', true],ould support key and value names with dash', () => {t bindings = parseTemplateBindings('*key="foo, k-b as l-b;"');ct(humanize(bindings)).toEqual([// [ key, value, VariableBinding ]['key', 'foo', false],['l-b', 'k-b', true],    });    describe('source, key, value spans', () => {ould map empty expression', () => {t attr = '*ngIf=""';t bindings = parseTemplateBindings(attr);ct(humanizeSpans(bindings, attr)).toEqual([// source span, key span, value span['ngIf="', 'ngIf', null],ould map variable declaration via "let"', () => {t attr = '*key="let i"';t bindings = parseTemplateBindings(attr);ct(humanizeSpans(bindings, attr)).toEqual([// source span, key span, value span['key="', 'key', null],  // source span stretches till next binding['let i', 'i', null],oud map multiple variable declarations via "let"', () => {t attr = '*key="let item; let i=index; let e=even;"';t bindings = parseTemplateBindings(attr);ct(humanizeSpans(bindings, attr)).toEqual([// source span, key span, value span['key="', 'key', null],['let item; ', 'item', null],['let i=index; ', 'i', 'index'],['let e=even;', 'e', 'even'],oud map expression with pipe', () => {t attr = '*ngIf="cond | pipe as foo, let x; ngIf as y"';t bindings = parseTemplateBindings(attr);ct(humanizeSpans(bindings, attr)).toEqual([// source span, key span, value span['ngIf="cond | pipe ', 'ngIf', 'cond | pipe'],['ngIf="cond | pipe as foo, ', 'foo', 'ngIf'],['let x; ', 'x', null],['ngIf as y', 'y', 'ngIf'],ould report unexpected token when encountering interpolation', () => {t attr = '*ngIf="name && {{name}}"';ctParseTemplateBindingsError( attr, 'Parser Error: Unexpected token {, expected identifier, keyword, or string at column 10 in [name && {{name}}] in foo.html');ould map variable declaration via "as"', () => {t attr = '*ngFor="let item; of items | slice:0:1 as collection, trackBy: func; index as i"';t bindings = parseTemplateBindings(attr);ct(humanizeSpans(bindings, attr)).toEqual([// source span, key span, value span['ngFor="', 'ngFor', null],['let item; ', 'item', null],['of items | slice:0:1 ', 'of', 'items | slice:0:1'],['of items | slice:0:1 as collection, ', 'collection', 'of'],['trackBy: func; ', 'trackBy', 'func'],['index as i', 'i', 'index'],ould map literal array', () => {t attr = '*ngFor="let item, of: [1,2,3] | pipe as items; let i=index, count as len, "';t bindings = parseTemplateBindings(attr);ct(humanizeSpans(bindings, attr)).toEqual([// source span, key span, value span['ngFor="', 'ngFor', null],['let item, ', 'item', null],['of: [1,2,3] | pipe ', 'of', '[1,2,3] | pipe'],['of: [1,2,3] | pipe as items; ', 'items', 'of'],['let i=index, ', 'i', 'index'],['count as len,', 'len', 'count'],    });  });  describe('parseInterpolation', () => {    it('should return null if no interpolation', () => {(parseInterpolation('nothing')).toBe(null);    });    it('should not parse malformed interpolations as strings', () => {ast = parseInterpolation('{{a}} {{example}<!--->}')!.ast as Interpolation;(ast.strings).toEqual(['', ' {{example}<!--->}']);(ast.expressions.length).toEqual(1);((ast.expressions[0] as PropertyRead).name).toEqual('a');    });    it('should parse no prefix/suffix interpolation', () => {ast = parseInterpolation('{{a}}')!.ast as Interpolation;(ast.strings).toEqual(['', '']);(ast.expressions.length).toEqual(1);((ast.expressions[0] as PropertyRead).name).toEqual('a');    });    it('should parse interpolation inside quotes', () => {ast = parseInterpolation('"{{a}}"')!.ast as Interpolation;(ast.strings).toEqual(['"', '"']);(ast.expressions.length).toEqual(1);((ast.expressions[0] as PropertyRead).name).toEqual('a');    });    it('should parse interpolation with interpolation characters inside quotes', () => {nterpolation('{{"{{a}}"}}', '{{ "{{a}}" }}');nterpolation('{{"{{"}}', '{{ "{{" }}');nterpolation('{{"}}"}}', '{{ "}}" }}');nterpolation('{{"{"}}', '{{ "{" }}');nterpolation('{{"}"}}', '{{ "}" }}');    });    it('should parse interpolation with escaped quotes', () => {nterpolation(`{{'It\\'s just Angular'}}`, `{{ "It's just Angular" }}`);nterpolation(`{{'It\\'s {{ just Angular'}}`, `{{ "It's {{ just Angular" }}`);nterpolation(`{{'It\\'s }} just Angular'}}`, `{{ "It's }} just Angular" }}`);    });    it('should parse interpolation with escaped backslashes', () => {nterpolation(`{{foo.split('\\\\')}}`, `{{ foo.split("\\") }}`);nterpolation(`{{foo.split('\\\\\\\\')}}`, `{{ foo.split("\\\\") }}`);nterpolation(`{{foo.split('\\\\\\\\\\\\')}}`, `{{ foo.split("\\\\\\") }}`);    });    it('should not parse interpolation with mismatching quotes', () => {(parseInterpolation(`{{ "{{a}}' }}`)).toBeNull();    });    it('should parse prefix/suffix with multiple interpolation', () => {originalExp = 'before {{ a }} middle {{ b }} after';ast = parseInterpolation(originalExp)!.ast;(unparse(ast)).toEqual(originalExp);te(ast);    });    it('should report empty interpolation expressions', () => {Error(parseInterpolation('{{}}')!, 'Blank expressions are not allowed in interpolated strings');Error(parseInterpolation('foo {{  }}')!,'Parser Error: Blank expressions are not allowed in interpolated strings');    });    it('should produce an empty expression ast for empty interpolations', () => {parsed = parseInterpolation('{{}}')!.ast as Interpolation;(parsed.expressions.length).toBe(1);(parsed.expressions[0]).toBeInstanceOf(EmptyExpr);    });    it('should parse conditional expression', () => {nterpolation('{{ a < b ? a : b }}');    });    it('should parse expression with newline characters', () => {nterpolation(`{{ 'foo' +\n 'bar' +\r 'baz' }}`, `{{ "foo" + "bar" + "baz" }}`);    });    it('should support custom interpolation', () => {parser = new Parser(new Lexer());ast =parser.parseInterpolation('{% a %}', '', 0, null, {start: '{%', end: '%}'})!.ast as any;(ast.strings).toEqual(['', '']);(ast.expressions.length).toEqual(1);(ast.expressions[0].name).toEqual('a');    });    describe('comments', () => {ould ignore comments in interpolation expressions', () => {kInterpolation('{{a //comment}}', '{{ a }}');ould retain // in single quote strings', () => {kInterpolation(`{{ 'http://www.google.com' }}`, `{{ "http://www.google.com" }}`);ould retain // in double quote strings', () => {kInterpolation(`{{ "http://www.google.com" }}`, `{{ "http://www.google.com" }}`);ould ignore comments after string literals', () => {kInterpolation(`{{ "a//b" //comment }}`, `{{ "a//b" }}`);ould retain // in complex strings', () => {kInterpolation( `{{"//a\'//b\`//c\`//d\'//e" //comment}}`, `{{ "//a\'//b\`//c\`//d\'//e" }}`);ould retain // in nested, unterminated strings', () => {kInterpolation(`{{ "a\'b\`" //comment}}`, `{{ "a\'b\`" }}`);ould ignore quotes inside a comment', () => {kInterpolation(`"{{name // " }}"`, `"{{ name }}"`);    });  });  describe('parseSimpleBinding', () => {    it('should parse a field access', () => {p = parseSimpleBinding('name');(unparse(p)).toEqual('name');te(p);    });    it('should report when encountering pipes', () => {Error(validate(parseSimpleBinding('a | somePipe')),'Host binding expression cannot contain pipes');    });    it('should report when encountering interpolation', () => {Error(validate(parseSimpleBinding('{{exp}}')),'Got interpolation ({{}}) where expression was expected');    });    it('should not report interpolation inside a string', () => {(parseSimpleBinding(`"{{exp}}"`).errors).toEqual([]);(parseSimpleBinding(`'{{exp}}'`).errors).toEqual([]);(parseSimpleBinding(`'{{\\"}}'`).errors).toEqual([]);(parseSimpleBinding(`'{{\\'}}'`).errors).toEqual([]);    });    it('should report when encountering field write', () => {Error(validate(parseSimpleBinding('a = b')), 'Bindings cannot contain assignments');    });    it('should throw if a pipe is used inside a conditional', () => {Error(validate(parseSimpleBinding('(hasId | myPipe) ? "my-id" : ""')),'Host binding expression cannot contain pipes');    });    it('should throw if a pipe is used inside a call', () => {Error(validate(parseSimpleBinding('getId(true, id | myPipe)')),'Host binding expression cannot contain pipes');    });    it('should throw if a pipe is used inside a call to a property access', () => {Error(validate(parseSimpleBinding('idService.getId(true, id | myPipe)')),'Host binding expression cannot contain pipes');    });    it('should throw if a pipe is used inside a call to a safe property access', () => {Error(validate(parseSimpleBinding('idService?.getId(true, id | myPipe)')),'Host binding expression cannot contain pipes');    });    it('should throw if a pipe is used inside a property access', () => {Error(validate(parseSimpleBinding('a[id | myPipe]')),'Host binding expression cannot contain pipes');    });    it('should throw if a pipe is used inside a keyed read expression', () => {Error(validate(parseSimpleBinding('a[id | myPipe].b')),'Host binding expression cannot contain pipes');    });    it('should throw if a pipe is used inside a safe property read', () => {Error(validate(parseSimpleBinding('(id | myPipe)?.id')),'Host binding expression cannot contain pipes');    });    it('should throw if a pipe is used inside a non-null assertion', () => {Error(validate(parseSimpleBinding('[id | myPipe]!')),'Host binding expression cannot contain pipes');    });    it('should throw if a pipe is used inside a prefix not expression', () => {Error(validate(parseSimpleBinding('!(id | myPipe)')),'Host binding expression cannot contain pipes');    });    it('should throw if a pipe is used inside a binary expression', () => {Error(validate(parseSimpleBinding('(id | myPipe) === true')),'Host binding expression cannot contain pipes');    });  });  describe('wrapLiteralPrimitive', () => {    it('should wrap a literal primitive', () => {(unparse(validate(createParser().wrapLiteralPrimitive('foo', '', 0)))).toEqual('"foo"');    });  });  describe('error recovery', () => {    function recover(text: string, expected?: string) {expr = validate(parseAction(text));(unparse(expr)).toEqual(expected || text);    }    it('should be able to recover from an extra paren', () => recover('((a)))', 'a'));    it('should be able to recover from an extra bracket', () => recover('[[a]]]', '[[a]]'));    it('should be able to recover from a missing )', () => recover('(a;b', 'a; b;'));    it('should be able to recover from a missing ]', () => recover('[a,b', '[a, b]'));    it('should be able to recover from a missing selector', () => recover('a.'));    it('should be able to recover from a missing selector in a array literal', recover('[[a.], b, c]'));  });  describe('offsets', () => {    it('should retain the offsets of an interpolation', () => {interpolations = splitInterpolation('{{a}}  {{b}}  {{c}}')!;(interpolations.offsets).toEqual([2, 9, 16]);    });    it('should retain the offsets into the expression AST of interpolations', () => {source = parseInterpolation('{{a}}  {{b}}  {{c}}')!;interpolation = source.ast as Interpolation;(interpolation.expressions.map(e => e.span.start)).toEqual([2, 9, 16]);    });  });});function createParser() {  return new Parser(new Lexer());}function parseAction(text: string, location: any = null, offset: number = 0): ASTWithSource {  return createParser().parseAction(text, /* isAssignmentEvent */ false, location, offset);}function parseBinding(text: string, location: any = null, offset: number = 0): ASTWithSource {  return createParser().parseBinding(text, location, offset);}function parseTemplateBindings(attribute: string, templateUrl = 'foo.html'): TemplateBinding[] {  const result = _parseTemplateBindings(attribute, templateUrl);  expect(result.errors).toEqual([]);  expect(result.warnings).toEqual([]);  return result.templateBindings;}function expectParseTemplateBindingsError(attribute: string, error: string) {  const result = _parseTemplateBindings(attribute, 'foo.html');  expect(result.errors[0].message).toEqual(error);}function _parseTemplateBindings(attribute: string, templateUrl: string) {  const match = attribute.match(/^\*(.+)="(.*)"$/);  expect(match).toBeTruthy(`failed to extract key and value from ${attribute}`);  const [_, key, value] = match!;  const absKeyOffset = 1;  // skip the * prefix  const absValueOffset = attribute.indexOf('=') + '="'.length;  const parser = createParser();  return parser.parseTemplateBindings(key, value, templateUrl, absKeyOffset, absValueOffset);}function parseInterpolation(text: string, location: any = null, offset: number = 0): ASTWithSource|    null {  return createParser().parseInterpolation(text, location, offset, null);}function splitInterpolation(text: string, location: any = null): SplitInterpolation|null {  return createParser().splitInterpolation(text, location, null);}function parseSimpleBinding(text: string, location: any = null, offset: number = 0): ASTWithSource {  return createParser().parseSimpleBinding(text, location, offset);}function checkInterpolation(exp: string, expected?: string) {  const ast = parseInterpolation(exp);  if (expected == null) expected = exp;  if (ast === null) {    throw Error(`Failed to parse expression "${exp}"`);  }  expect(unparse(ast)).toEqual(expected);  validate(ast);}function checkBinding(exp: string, expected?: string) {  const ast = parseBinding(exp);  if (expected == null) expected = exp;  expect(unparse(ast)).toEqual(expected);  validate(ast);}function checkAction(exp: string, expected?: string) {  const ast = parseAction(exp);  if (expected == null) expected = exp;  expect(unparse(ast)).toEqual(expected);  validate(ast);}function expectError(ast: {errors: ParserError[]}, message: string) {  for (const error of ast.errors) {    if (error.message.indexOf(message) >= 0) {;    }  }  const errMsgs = ast.errors.map(err => err.message).join('\n');  throw Error(ted an error containing "${message}" to be reported, but got the errors:\n` + errMsgs);}function expectActionError(text: string, message: string) {  expectError(validate(parseAction(text)), message);}function expectBindingError(text: string, message: string) {  expectError(validate(parseBinding(text)), message);}/** * Check that a malformed action parses to a recovered AST while emitting an error. */function checkActionWithError(text: string, expected: string, error: string) {  checkAction(text, expected);  expectActionError(text, error);}function rawSpan(span: AbsoluteSourceSpan): [number, number] {  return [span.start, span.end];}