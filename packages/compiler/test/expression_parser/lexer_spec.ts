/** * @license * Copyright Google LLC All Rights Reserved. * * Use of this source code is governed by an MIT-style license that can be * found in the LICENSE file at https://angular.io/license */import {Lexer, Token} from '@angular/compiler/src/expression_parser/lexer';function lex(text: string): any[] {  return new Lexer().tokenize(text);}function expectToken(token: any, index: number, end: number) {  expect(token instanceof Token).toBe(true);  expect(token.index).toEqual(index);  expect(token.end).toEqual(end);}function expectCharacterToken(token: any, index: number, end: number, character: string) {  expect(character.length).toBe(1);  expectToken(token, index, end);  expect(token.isCharacter(character.charCodeAt(0))).toBe(true);}function expectOperatorToken(token: any, index: number, end: number, operator: string) {  expectToken(token, index, end);  expect(token.isOperator(operator)).toBe(true);}function expectNumberToken(token: any, index: number, end: number, n: number) {  expectToken(token, index, end);  expect(token.isNumber()).toBe(true);  expect(token.toNumber()).toEqual(n);}function expectStringToken(token: any, index: number, end: number, str: string) {  expectToken(token, index, end);  expect(token.isString()).toBe(true);  expect(token.toString()).toEqual(str);}function expectIdentifierToken(token: any, index: number, end: number, identifier: string) {  expectToken(token, index, end);  expect(token.isIdentifier()).toBe(true);  expect(token.toString()).toEqual(identifier);}function expectPrivateIdentifierToken(token: any, index: number, end: number, identifier: string) {  expectToken(token, index, end);  expect(token.isPrivateIdentifier()).toBe(true);  expect(token.toString()).toEqual(identifier);}function expectKeywordToken(token: any, index: number, end: number, keyword: string) {  expectToken(token, index, end);  expect(token.isKeyword()).toBe(true);  expect(token.toString()).toEqual(keyword);}function expectErrorToken(token: Token, index: any, end: number, message: string) {  expectToken(token, index, end);  expect(token.isError()).toBe(true);  expect(token.toString()).toEqual(message);}{  describe('lexer', () => {    describe('token', () => {ould tokenize a simple identifier', () => {t tokens: number[] = lex('j');ct(tokens.length).toEqual(1);ctIdentifierToken(tokens[0], 0, 1, 'j');ould tokenize "this"', () => {t tokens: number[] = lex('this');ct(tokens.length).toEqual(1);ctKeywordToken(tokens[0], 0, 4, 'this');ould tokenize a dotted identifier', () => {t tokens: number[] = lex('j.k');ct(tokens.length).toEqual(3);ctIdentifierToken(tokens[0], 0, 1, 'j');ctCharacterToken(tokens[1], 1, 2, '.');ctIdentifierToken(tokens[2], 2, 3, 'k');ould tokenize a private identifier', () => {t tokens: number[] = lex('#a');ct(tokens.length).toEqual(1);ctPrivateIdentifierToken(tokens[0], 0, 2, '#a');ould tokenize a property access with private identifier', () => {t tokens: number[] = lex('j.#k');ct(tokens.length).toEqual(3);ctIdentifierToken(tokens[0], 0, 1, 'j');ctCharacterToken(tokens[1], 1, 2, '.');ctPrivateIdentifierToken(tokens[2], 2, 4, '#k');ould throw an invalid character error when a hash character is discovered but ' +  'not indicating a private identifier',expectErrorToken(lex('#')[0], 0, 1,`Lexer Error: Invalid character [#] at column 0 in expression [#]`);expectErrorToken(lex('#0')[0], 0, 1,`Lexer Error: Invalid character [#] at column 0 in expression [#0]`);ould tokenize an operator', () => {t tokens: number[] = lex('j-k');ct(tokens.length).toEqual(3);ctOperatorToken(tokens[1], 1, 2, '-');ould tokenize an indexed operator', () => {t tokens: number[] = lex('j[k]');ct(tokens.length).toEqual(4);ctCharacterToken(tokens[1], 1, 2, '[');ctCharacterToken(tokens[3], 3, 4, ']');ould tokenize a safe indexed operator', () => {t tokens: number[] = lex('j?.[k]');ct(tokens.length).toBe(5);ctOperatorToken(tokens[1], 1, 3, '?.');ctCharacterToken(tokens[2], 3, 4, '[');ctCharacterToken(tokens[4], 5, 6, ']');ould tokenize numbers', () => {t tokens: number[] = lex('88');ct(tokens.length).toEqual(1);ctNumberToken(tokens[0], 0, 2, 88);ould tokenize numbers within index ops', () => {ctNumberToken(lex('a[22]')[2], 2, 4, 22);ould tokenize simple quoted strings', () => {ctStringToken(lex('"a"')[0], 0, 3, 'a');ould tokenize quoted strings with escaped quotes', () => {ctStringToken(lex('"a\\""')[0], 0, 5, 'a"');ould tokenize a string', () => {t tokens: Token[] = lex('j-a.bc[22]+1.3|f:\'a\\\'c\':"d\\"e"');ctIdentifierToken(tokens[0], 0, 1, 'j');ctOperatorToken(tokens[1], 1, 2, '-');ctIdentifierToken(tokens[2], 2, 3, 'a');ctCharacterToken(tokens[3], 3, 4, '.');ctIdentifierToken(tokens[4], 4, 6, 'bc');ctCharacterToken(tokens[5], 6, 7, '[');ctNumberToken(tokens[6], 7, 9, 22);ctCharacterToken(tokens[7], 9, 10, ']');ctOperatorToken(tokens[8], 10, 11, '+');ctNumberToken(tokens[9], 11, 14, 1.3);ctOperatorToken(tokens[10], 14, 15, '|');ctIdentifierToken(tokens[11], 15, 16, 'f');ctCharacterToken(tokens[12], 16, 17, ':');ctStringToken(tokens[13], 17, 23, 'a\'c');ctCharacterToken(tokens[14], 23, 24, ':');ctStringToken(tokens[15], 24, 30, 'd"e');ould tokenize undefined', () => {t tokens: Token[] = lex('undefined');ctKeywordToken(tokens[0], 0, 9, 'undefined');ct(tokens[0].isKeywordUndefined()).toBe(true);ould ignore whitespace', () => {t tokens: Token[] = lex('a \t \n \r b');ctIdentifierToken(tokens[0], 0, 1, 'a');ctIdentifierToken(tokens[1], 8, 9, 'b');ould tokenize quoted string', () => {t str = '[\'\\\'\', "\\""]';t tokens: Token[] = lex(str);ctStringToken(tokens[1], 1, 5, '\'');ctStringToken(tokens[3], 7, 11, '"');ould tokenize escaped quoted string', () => {t str = '"\\"\\n\\f\\r\\t\\v\\u00A0"';t tokens: Token[] = lex(str);ct(tokens.length).toEqual(1);ct(tokens[0].toString()).toEqual('"\n\f\r\t\v\u00A0');ould tokenize unicode', () => {t tokens: Token[] = lex('"\\u00A0"');ct(tokens.length).toEqual(1);ct(tokens[0].toString()).toEqual('\u00a0');ould tokenize relation', () => {t tokens: Token[] = lex('! == != < > <= >= === !==');ctOperatorToken(tokens[0], 0, 1, '!');ctOperatorToken(tokens[1], 2, 4, '==');ctOperatorToken(tokens[2], 5, 7, '!=');ctOperatorToken(tokens[3], 8, 9, '<');ctOperatorToken(tokens[4], 10, 11, '>');ctOperatorToken(tokens[5], 12, 14, '<=');ctOperatorToken(tokens[6], 15, 17, '>=');ctOperatorToken(tokens[7], 18, 21, '===');ctOperatorToken(tokens[8], 22, 25, '!==');ould tokenize statements', () => {t tokens: Token[] = lex('a;b;');ctIdentifierToken(tokens[0], 0, 1, 'a');ctCharacterToken(tokens[1], 1, 2, ';');ctIdentifierToken(tokens[2], 2, 3, 'b');ctCharacterToken(tokens[3], 3, 4, ';');ould tokenize function invocation', () => {t tokens: Token[] = lex('a()');ctIdentifierToken(tokens[0], 0, 1, 'a');ctCharacterToken(tokens[1], 1, 2, '(');ctCharacterToken(tokens[2], 2, 3, ')');ould tokenize simple method invocations', () => {t tokens: Token[] = lex('a.method()');ctIdentifierToken(tokens[2], 2, 8, 'method');ould tokenize method invocation', () => {t tokens: Token[] = lex('a.b.c (d) - e.f()');ctIdentifierToken(tokens[0], 0, 1, 'a');ctCharacterToken(tokens[1], 1, 2, '.');ctIdentifierToken(tokens[2], 2, 3, 'b');ctCharacterToken(tokens[3], 3, 4, '.');ctIdentifierToken(tokens[4], 4, 5, 'c');ctCharacterToken(tokens[5], 6, 7, '(');ctIdentifierToken(tokens[6], 7, 8, 'd');ctCharacterToken(tokens[7], 8, 9, ')');ctOperatorToken(tokens[8], 10, 11, '-');ctIdentifierToken(tokens[9], 12, 13, 'e');ctCharacterToken(tokens[10], 13, 14, '.');ctIdentifierToken(tokens[11], 14, 15, 'f');ctCharacterToken(tokens[12], 15, 16, '(');ctCharacterToken(tokens[13], 16, 17, ')');ould tokenize safe function invocation', () => {t tokens: Token[] = lex('a?.()');ctIdentifierToken(tokens[0], 0, 1, 'a');ctOperatorToken(tokens[1], 1, 3, '?.');ctCharacterToken(tokens[2], 3, 4, '(');ctCharacterToken(tokens[3], 4, 5, ')');ould tokenize a safe method invocations', () => {t tokens: Token[] = lex('a.method?.()');ctIdentifierToken(tokens[0], 0, 1, 'a');ctCharacterToken(tokens[1], 1, 2, '.');ctIdentifierToken(tokens[2], 2, 8, 'method');ctOperatorToken(tokens[3], 8, 10, '?.');ctCharacterToken(tokens[4], 10, 11, '(');ctCharacterToken(tokens[5], 11, 12, ')');ould tokenize number', () => {ctNumberToken(lex('0.5')[0], 0, 3, 0.5);ould tokenize number with exponent', () => {tokens: Token[] = lex('0.5E-10');ct(tokens.length).toEqual(1);ctNumberToken(tokens[0], 0, 7, 0.5E-10);ns = lex('0.5E+10');ctNumberToken(tokens[0], 0, 7, 0.5E+10);ould return exception for invalid exponent', () => {ctErrorToken( lex('0.5E-')[0], 4, 5, 'Lexer Error: Invalid exponent at column 4 in expression [0.5E-]');ctErrorToken( lex('0.5E-A')[0], 4, 5, 'Lexer Error: Invalid exponent at column 4 in expression [0.5E-A]');ould tokenize number starting with a dot', () => {ctNumberToken(lex('.5')[0], 0, 2, 0.5);ould throw error on invalid unicode', () => {ctErrorToken( lex('\'\\u1\'\'bla\'')[0], 2, 2, 'Lexer Error: Invalid unicode escape [\\u1\'\'b] at column 2 in expression [\'\\u1\'\'bla\']');ould tokenize ?. as operator', () => {ctOperatorToken(lex('?.')[0], 0, 2, '?.');ould tokenize ?? as operator', () => {ctOperatorToken(lex('??')[0], 0, 2, '??');ould tokenize number with separator', () => {ctNumberToken(lex('123_456')[0], 0, 7, 123_456);ctNumberToken(lex('1_000_000_000')[0], 0, 13, 1_000_000_000);ctNumberToken(lex('123_456.78')[0], 0, 10, 123_456.78);ctNumberToken(lex('123_456_789.123_456_789')[0], 0, 23, 123_456_789.123_456_789);ctNumberToken(lex('1_2_3_4')[0], 0, 7, 1_2_3_4);ctNumberToken(lex('1_2_3_4.5_6_7_8')[0], 0, 15, 1_2_3_4.5_6_7_8);ould tokenize number starting with an underscore as an identifier', () => {ctIdentifierToken(lex('_123')[0], 0, 4, '_123');ctIdentifierToken(lex('_123_')[0], 0, 5, '_123_');ctIdentifierToken(lex('_1_2_3_')[0], 0, 7, '_1_2_3_');ould throw error for invalid number separators', () => {ctErrorToken( lex('123_')[0], 3, 3, 'Lexer Error: Invalid numeric separator at column 3 in expression [123_]');ctErrorToken( lex('12__3')[0], 2, 2, 'Lexer Error: Invalid numeric separator at column 2 in expression [12__3]');ctErrorToken( lex('1_2_3_.456')[0], 5, 5, 'Lexer Error: Invalid numeric separator at column 5 in expression [1_2_3_.456]');ctErrorToken( lex('1_2_3._456')[0], 6, 6, 'Lexer Error: Invalid numeric separator at column 6 in expression [1_2_3._456]');    });  });}