/** * @license * Copyright Google LLC All Rights Reserved. * * Use of this source code is governed by an MIT-style license that can be * found in the LICENSE file at https://angular.io/license */import {BindingType} from '../../src/expression_parser/ast';import * as t from '../../src/render3/r3_ast';import {unparse} from '../expression_parser/utils/unparser';import {parseR3 as parse} from './view/util';// Transform an IVY AST to a flat list of nodes to ease testingclass R3AstHumanizer implements t.Visitor<void> {  result: any[] = [];  visitElement(element: t.Element) {    this.result.push(['Element', element.name]);    this.visitAll([t.attributes,t.inputs,t.outputs,t.references,t.children,    ]);  }  visitTemplate(template: t.Template) {    this.result.push(['Template']);    this.visitAll([te.attributes,te.inputs,te.outputs,te.templateAttrs,te.references,te.variables,te.children,    ]);  }  visitContent(content: t.Content) {    this.result.push(['Content', content.selector]);    t.visitAll(this, content.attributes);  }  visitVariable(variable: t.Variable) {    this.result.push(['Variable', variable.name, variable.value]);  }  visitReference(reference: t.Reference) {    this.result.push(['Reference', reference.name, reference.value]);  }  visitTextAttribute(attribute: t.TextAttribute) {    this.result.push(['TextAttribute', attribute.name, attribute.value]);  }  visitBoundAttribute(attribute: t.BoundAttribute) {    this.result.push([Attribute',ute.type,ute.name,e(attribute.value),    ]);  }  visitBoundEvent(event: t.BoundEvent) {    this.result.push([Event',name,target,e(event.handler),    ]);  }  visitText(text: t.Text) {    this.result.push(['Text', text.value]);  }  visitBoundText(text: t.BoundText) {    this.result.push(['BoundText', unparse(text.value)]);  }  visitIcu(icu: t.Icu) {    return null;  }  visitDeferredBlock(deferred: t.DeferredBlock): void {    this.result.push(['DeferredBlock']);    deferred.visitAll(this);  }  visitSwitchBlock(block: t.SwitchBlock): void {    this.result.push(['SwitchBlock', unparse(block.expression)]);    this.visitAll([block.cases]);  }  visitSwitchBlockCase(block: t.SwitchBlockCase): void {    this.result.push(itchBlockCase', block.expression === null ? null : unparse(block.expression)]);    this.visitAll([block.children]);  }  visitForLoopBlock(block: t.ForLoopBlock): void {    const result: any[] = ['ForLoopBlock', unparse(block.expression), unparse(block.trackBy)];    block.contextVariables !== null && result.push(block.contextVariables);    this.result.push(result);    this.visitAll([block.children]);    block.empty?.visit(this);  }  visitForLoopBlockEmpty(block: t.ForLoopBlockEmpty): void {    this.result.push(['ForLoopBlockEmpty']);    this.visitAll([block.children]);  }  visitIfBlock(block: t.IfBlock): void {    this.result.push(['IfBlock']);    this.visitAll([block.branches]);  }  visitIfBlockBranch(block: t.IfBlockBranch): void {    const result = ['IfBlockBranch', block.expression === null ? null : unparse(block.expression)];    block.expressionAlias !== null && result.push(block.expressionAlias);    this.result.push(result);    this.visitAll([block.children]);  }  visitDeferredTrigger(trigger: t.DeferredTrigger): void {    if (trigger instanceof t.BoundDeferredTrigger) {esult.push(['BoundDeferredTrigger', unparse(trigger.value)]);    } else if (trigger instanceof t.ImmediateDeferredTrigger) {esult.push(['ImmediateDeferredTrigger']);    } else if (trigger instanceof t.HoverDeferredTrigger) {esult.push(['HoverDeferredTrigger']);    } else if (trigger instanceof t.IdleDeferredTrigger) {esult.push(['IdleDeferredTrigger']);    } else if (trigger instanceof t.TimerDeferredTrigger) {esult.push(['TimerDeferredTrigger', trigger.delay]);    } else if (trigger instanceof t.InteractionDeferredTrigger) {esult.push(['InteractionDeferredTrigger', trigger.reference]);    } else if (trigger instanceof t.ViewportDeferredTrigger) {esult.push(['ViewportDeferredTrigger', trigger.reference]);    } else {new Error('Unknown trigger');    }  }  visitDeferredBlockPlaceholder(block: t.DeferredBlockPlaceholder): void {    const result = ['DeferredBlockPlaceholder'];    block.minimumTime !== null && result.push(`minimum ${block.minimumTime}ms`);    this.result.push(result);    this.visitAll([block.children]);  }  visitDeferredBlockLoading(block: t.DeferredBlockLoading): void {    const result = ['DeferredBlockLoading'];    block.afterTime !== null && result.push(`after ${block.afterTime}ms`);    block.minimumTime !== null && result.push(`minimum ${block.minimumTime}ms`);    this.result.push(result);    this.visitAll([block.children]);  }  visitDeferredBlockError(block: t.DeferredBlockError): void {    this.result.push(['DeferredBlockError']);    this.visitAll([block.children]);  }  private visitAll(nodes: t.Node[][]) {    nodes.forEach(node => t.visitAll(this, node));  }}function expectFromHtml(html: string, ignoreError = false, enabledBlockTypes?: string[]) {  const res = parse(html, {ignoreError, enabledBlockTypes});  return expectFromR3Nodes(res.nodes);}function expectFromR3Nodes(nodes: t.Node[]) {  const humanizer = new R3AstHumanizer();  t.visitAll(humanizer, nodes);  return expect(humanizer.result);}function expectSpanFromHtml(html: string) {  const {nodes} = parse(html);  return expect(nodes[0]!.sourceSpan.toString());}describe('R3 template transform', () => {  describe('ParseSpan on nodes toString', () => {    it('should create valid text span on Element with adjacent start and end tags', () => {SpanFromHtml('<div></div>').toBe('<div></div>');    });  });  describe('Nodes without binding', () => {    it('should parse incomplete tags terminated by EOF', () => {FromHtml('<a', true /* ignoreError */).toEqual([ement', 'a'],    });    it('should parse incomplete tags terminated by another tag', () => {FromHtml('<a <span></span>', true /* ignoreError */).toEqual([ement', 'a'],ement', 'span'],    });    it('should parse text nodes', () => {FromHtml('a').toEqual([xt', 'a'],    });    it('should parse elements with attributes', () => {FromHtml('<div a=b></div>').toEqual([ement', 'div'],xtAttribute', 'a', 'b'],    });    it('should parse ngContent', () => {res = parse('<ng-content select="a"></ng-content>');FromR3Nodes(res.nodes).toEqual([ntent', 'a'],xtAttribute', 'select', 'a'],    });    it('should parse ngContent when it contains WS only', () => {FromHtml('<ng-content select="a">    \n   </ng-content>').toEqual([ntent', 'a'],xtAttribute', 'select', 'a'],    });    it('should parse ngContent regardless the namespace', () => {FromHtml('<svg><ng-content select="a"></ng-content></svg>').toEqual([ement', ':svg:svg'],ntent', 'a'],xtAttribute', 'select', 'a'],    });  });  describe('Bound text nodes', () => {    it('should parse bound text nodes', () => {FromHtml('{{a}}').toEqual([undText', '{{ a }}'],    });  });  describe('Bound attributes', () => {    it('should parse mixed case bound properties', () => {FromHtml('<div [someProp]="v"></div>').toEqual([ement', 'div'],undAttribute', BindingType.Property, 'someProp', 'v'],    });    it('should parse bound properties via bind- ', () => {FromHtml('<div bind-prop="v"></div>').toEqual([ement', 'div'],undAttribute', BindingType.Property, 'prop', 'v'],    });    it('should report missing property names in bind- syntax', () => {(() => parse('<div bind-></div>')).toThrowError(/Property name is missing in binding/);    });    it('should parse bound properties via {{...}}', () => {FromHtml('<div prop="{{v}}"></div>').toEqual([ement', 'div'],undAttribute', BindingType.Property, 'prop', '{{ v }}'],    });    it('should parse dash case bound properties', () => {FromHtml('<div [some-prop]="v"></div>').toEqual([ement', 'div'],undAttribute', BindingType.Property, 'some-prop', 'v'],    });    it('should parse dotted name bound properties', () => {FromHtml('<div [d.ot]="v"></div>').toEqual([ement', 'div'],undAttribute', BindingType.Property, 'd.ot', 'v'],    });    it('should not normalize property names via the element schema', () => {FromHtml('<div [mappedAttr]="v"></div>').toEqual([ement', 'div'],undAttribute', BindingType.Property, 'mappedAttr', 'v'],    });    it('should parse mixed case bound attributes', () => {FromHtml('<div [attr.someAttr]="v"></div>').toEqual([ement', 'div'],undAttribute', BindingType.Attribute, 'someAttr', 'v'],    });    it('should parse and dash case bound classes', () => {FromHtml('<div [class.some-class]="v"></div>').toEqual([ement', 'div'],undAttribute', BindingType.Class, 'some-class', 'v'],    });    it('should parse mixed case bound classes', () => {FromHtml('<div [class.someClass]="v"></div>').toEqual([ement', 'div'],undAttribute', BindingType.Class, 'someClass', 'v'],    });    it('should parse mixed case bound styles', () => {FromHtml('<div [style.someStyle]="v"></div>').toEqual([ement', 'div'],undAttribute', BindingType.Style, 'someStyle', 'v'],    });  });  describe('templates', () => {    it('should support * directives', () => {FromHtml('<div *ngIf></div>').toEqual([mplate'],xtAttribute', 'ngIf', ''],ement', 'div'],    });    it('should support <ng-template>', () => {FromHtml('<ng-template></ng-template>').toEqual([mplate'],    });    it('should support <ng-template> regardless the namespace', () => {FromHtml('<svg><ng-template></ng-template></svg>').toEqual([ement', ':svg:svg'],mplate'],    });    it('should support <ng-template> with structural directive', () => {FromHtml('<ng-template *ngIf="true"></ng-template>').toEqual([mplate'],undAttribute', 0, 'ngIf', 'true'],mplate'],res = parse('<ng-template *ngIf="true"></ng-template>', {ignoreError: false});((res.nodes[0] as t.Template).tagName).toEqual(null);(((res.nodes[0] as t.Template).children[0] as t.Template).tagName).toEqual('ng-template');    });    it('should support reference via #...', () => {FromHtml('<ng-template #a></ng-template>').toEqual([mplate'],ference', 'a', ''],    });    it('should support reference via ref-...', () => {FromHtml('<ng-template ref-a></ng-template>').toEqual([mplate'],ference', 'a', ''],    });    it('should report an error if a reference is used multiple times on the same template', () => {(() => parse('<ng-template #a #a></ng-template>')).toThrowError(/Reference "#a" is defined more than once/);    });    it('should parse variables via let-...', () => {FromHtml('<ng-template let-a="b"></ng-template>').toEqual([mplate'],riable', 'a', 'b'],    });    it('should parse attributes', () => {FromHtml('<ng-template k1="v1" k2="v2"></ng-template>').toEqual([mplate'],xtAttribute', 'k1', 'v1'],xtAttribute', 'k2', 'v2'],    });    it('should parse bound attributes', () => {FromHtml('<ng-template [k1]="v1" [k2]="v2"></ng-template>').toEqual([mplate'],undAttribute', BindingType.Property, 'k1', 'v1'],undAttribute', BindingType.Property, 'k2', 'v2'],    });  });  describe('inline templates', () => {    it('should support attribute and bound attributes', () => {ugared form is-template ngFor [ngForOf]="items" let-item>div></div>g-template>FromHtml('<div *ngFor="let item of items"></div>').toEqual([mplate'],xtAttribute', 'ngFor', ''],undAttribute', BindingType.Property, 'ngForOf', 'items'],riable', 'item', '$implicit'],ement', 'div'],e that this test exercises an *incorrect* usage of the ngForective. There is a missing 'let' in the beginning of the expressionch causes the template to be desugared into-template [ngFor]="item" [ngForOf]="items">div></div>g-template>FromHtml('<div *ngFor="item of items"></div>').toEqual([mplate'],undAttribute', BindingType.Property, 'ngFor', 'item'],undAttribute', BindingType.Property, 'ngForOf', 'items'],ement', 'div'],    });    it('should parse variables via let ...', () => {FromHtml('<div *ngIf="let a=b"></div>').toEqual([mplate'],xtAttribute', 'ngIf', ''],riable', 'a', 'b'],ement', 'div'],    });    it('should parse variables via as ...', () => {FromHtml('<div *ngIf="expr as local"></div>').toEqual([mplate'],undAttribute', BindingType.Property, 'ngIf', 'expr'],riable', 'local', 'ngIf'],ement', 'div'],    });  });  describe('events', () => {    it('should parse bound events with a target', () => {FromHtml('<div (window:event)="v"></div>').toEqual([ement', 'div'],undEvent', 'event', 'window', 'v'],    });    it('should parse event names case sensitive', () => {FromHtml('<div (some-event)="v"></div>').toEqual([ement', 'div'],undEvent', 'some-event', null, 'v'],FromHtml('<div (someEvent)="v"></div>').toEqual([ement', 'div'],undEvent', 'someEvent', null, 'v'],    });    it('should parse bound events via on-', () => {FromHtml('<div on-event="v"></div>').toEqual([ement', 'div'],undEvent', 'event', null, 'v'],    });    it('should report missing event names in on- syntax', () => {(() => parse('<div on-></div>')).toThrowError(/Event name is missing in binding/);    });    it('should parse bound events and properties via [(...)]', () => {FromHtml('<div [(prop)]="v"></div>').toEqual([ement', 'div'],undAttribute', BindingType.Property, 'prop', 'v'],undEvent', 'propChange', null, 'v = $event'],    });    it('should parse bound events and properties via bindon-', () => {FromHtml('<div bindon-prop="v"></div>').toEqual([ement', 'div'],undAttribute', BindingType.Property, 'prop', 'v'],undEvent', 'propChange', null, 'v = $event'],    });    it('should parse bound events and properties via [(...)] with non-null operator', () => {FromHtml('<div [(prop)]="v!"></div>').toEqual([ement', 'div'],undAttribute', BindingType.Property, 'prop', 'v!'],undEvent', 'propChange', null, 'v = $event'],    });    it('should report an error for assignments into non-null asserted expressions', () => {O(joost): this syntax is allowed in TypeScript. Consider changing the grammar tolow this syntax, or improve the error message. https://github.com/angular/angular/pull/37809(() => parse('<div (prop)="v! = $event"></div>')).toThrowError(/Unexpected token '=' at column 4/);    });    it('should report missing property names in bindon- syntax', () => {(() => parse('<div bindon-></div>')).toThrowError(/Property name is missing in binding/);    });    it('should report an error on empty expression', () => {(() => parse('<div (event)="">')).toThrowError(/Empty expressions are not allowed/);(() => parse('<div (event)="   ">')).toThrowError(/Empty expressions are not allowed/);    });    it('should parse bound animation events when event name is empty', () => {FromHtml('<div (@)="onAnimationEvent($event)"></div>', true).toEqual([ement', 'div'],undEvent', '', null, 'onAnimationEvent($event)'],(() => parse('<div (@)></div>')).toThrowError(/Animation event name is missing in binding/);    });    it('should report invalid phase value of animation event', () => {(() => parse('<div (@event.invalidPhase)></div>')).toThrowError(   /The provided animation output phase value "invalidphase" for "@event" is not supported \(use start or done\)/);(() => parse('<div (@event.)></div>')).toThrowError(   /The animation trigger output event \(@event\) is missing its phase value name \(start or done are currently supported\)/);(() => parse('<div (@event)></div>')).toThrowError(   /The animation trigger output event \(@event\) is missing its phase value name \(start or done are currently supported\)/);    });  });  describe('variables', () => {    it('should report variables not on template elements', () => {(() => parse('<div let-a-name="b"></div>')).toThrowError(/"let-" is only supported on ng-template elements./);    });    it('should report missing variable names', () => {(() => parse('<ng-template let-><ng-template>')).toThrowError(/Variable does not have a name/);    });  });  describe('references', () => {    it('should parse references via #...', () => {FromHtml('<div #a></div>').toEqual([ement', 'div'],ference', 'a', ''],    });    it('should parse references via ref-', () => {FromHtml('<div ref-a></div>').toEqual([ement', 'div'],ference', 'a', ''],    });    it('should parse camel case references', () => {FromHtml('<div #someA></div>').toEqual([ement', 'div'],ference', 'someA', ''],    });    it('should report invalid reference names', () => {(() => parse('<div #a-b></div>')).toThrowError(/"-" is not allowed in reference names/);    });    it('should report missing reference names', () => {(() => parse('<div #></div>')).toThrowError(/Reference does not have a name/);    });    it('should report an error if a reference is used multiple times on the same element', () => {(() => parse('<div #a #a></div>')).toThrowError(/Reference "#a" is defined more than once/);    });  });  describe('literal attribute', () => {    it('should report missing animation trigger in @ syntax', () => {(() => parse('<div @></div>')).toThrowError(/Animation trigger is missing/);    });  });  describe('ng-content', () => {    it('should parse ngContent without selector', () => {res = parse('<ng-content></ng-content>');FromR3Nodes(res.nodes).toEqual([ntent', '*'],    });    it('should parse ngContent with a specific selector', () => {res = parse('<ng-content select="tag[attribute]"></ng-content>');selectors = ['', 'tag[attribute]'];FromR3Nodes(res.nodes).toEqual([ntent', selectors[1]],xtAttribute', 'select', selectors[1]],    });    it('should parse ngContent with a selector', () => {res = parse('<ng-content select="a"></ng-content><ng-content></ng-content><ng-content select="b"></ng-content>');selectors = ['*', 'a', 'b'];FromR3Nodes(res.nodes).toEqual([ntent', selectors[1]],xtAttribute', 'select', selectors[1]],ntent', selectors[0]],ntent', selectors[2]],xtAttribute', 'select', selectors[2]],    });    it('should parse ngProjectAs as an attribute', () => {res = parse('<ng-content ngProjectAs="a"></ng-content>');FromR3Nodes(res.nodes).toEqual([ntent', '*'],xtAttribute', 'ngProjectAs', 'a'],    });  });  describe('Ignored elements', () => {    it('should ignore <script> elements', () => {FromHtml('<script></script>a').toEqual([xt', 'a'],    });    it('should ignore <style> elements', () => {FromHtml('<style></style>a').toEqual([xt', 'a'],    });  });  describe('<link rel="stylesheet">', () => {    it('should keep <link rel="stylesheet"> elements if they have an absolute url', () => {FromHtml('<link rel="stylesheet" href="http://someurl">').toEqual([ement', 'link'],xtAttribute', 'rel', 'stylesheet'],xtAttribute', 'href', 'http://someurl'],FromHtml('<link REL="stylesheet" href="http://someurl">').toEqual([ement', 'link'],xtAttribute', 'REL', 'stylesheet'],xtAttribute', 'href', 'http://someurl'],    });    it('should keep <link rel="stylesheet"> elements if they have no uri', () => {FromHtml('<link rel="stylesheet">').toEqual([ement', 'link'],xtAttribute', 'rel', 'stylesheet'],FromHtml('<link REL="stylesheet">').toEqual([ement', 'link'],xtAttribute', 'REL', 'stylesheet'],    });    it('should ignore <link rel="stylesheet"> elements if they have a relative uri', () => {FromHtml('<link rel="stylesheet" href="./other.css">').toEqual([]);FromHtml('<link REL="stylesheet" HREF="./other.css">').toEqual([]);    });  });  describe('ngNonBindable', () => {    it('should ignore bindings on children of elements with ngNonBindable', () => {FromHtml('<div ngNonBindable>{{b}}</div>').toEqual([ement', 'div'],xtAttribute', 'ngNonBindable', ''],xt', '{{b}}'],    });    it('should keep nested children of elements with ngNonBindable', () => {FromHtml('<div ngNonBindable><span>{{b}}</span></div>').toEqual([ement', 'div'],xtAttribute', 'ngNonBindable', ''],ement', 'span'],xt', '{{b}}'],    });    it('should ignore <script> elements inside of elements with ngNonBindable', () => {FromHtml('<div ngNonBindable><script></script>a</div>').toEqual([ement', 'div'],xtAttribute', 'ngNonBindable', ''],xt', 'a'],    });    it('should ignore <style> elements inside of elements with ngNonBindable', () => {FromHtml('<div ngNonBindable><style></style>a</div>').toEqual([ement', 'div'],xtAttribute', 'ngNonBindable', ''],xt', 'a'],    });    it('should ignore <link rel="stylesheet"> elements inside of elements with ngNonBindable', {mHtml('<div ngNonBindable><link rel="stylesheet">a</div>').toEqual([['Element', 'div'],['TextAttribute', 'ngNonBindable', ''],['Text', 'a'],  });  describe('deferred blocks', () => {    // TODO(crisbeto): temporary utility while blocks are disabled by default.    function expectDeferred(html: string) { expectFromR3Nodes(parse(html, {enabledBlockTypes: ['defer']}).nodes);    }    function expectDeferredError(html: string) { expect(() => parse(html, {enabledBlockTypes: ['defer']}));    }    it('should parse a simple deferred block', () => {Deferred('{#defer}hello{/defer}').toEqual([ferredBlock'],xt', 'hello'],    });    it('should parse a deferred block with a `when` trigger', () => {Deferred('{#defer when isVisible() && loaded}hello{/defer}').toEqual([ferredBlock'],undDeferredTrigger', 'isVisible() && loaded'],xt', 'hello'],    });    it('should parse a deferred block with a single `on` trigger', () => {Deferred('{#defer on idle}hello{/defer}').toEqual([ferredBlock'],leDeferredTrigger'],xt', 'hello'],    });    it('should parse a deferred block with multiple `on` triggers', () => {Deferred('{#defer on idle, viewport(button)}hello{/defer}').toEqual([ferredBlock'],leDeferredTrigger'],ewportDeferredTrigger', 'button'],xt', 'hello'],    });    it('should parse a deferred block with a non-parenthesized trigger at the end', () => {Deferred('{#defer on idle, viewport(button), immediate}hello{/defer}').toEqual([ferredBlock'],leDeferredTrigger'],ewportDeferredTrigger', 'button'],mediateDeferredTrigger'],xt', 'hello'],    });    it('should parse a deferred block with `when` and `on` triggers', () => {markup ='{#defer when isVisible(); on timer(100ms), idle, viewport(button)}hello{/defer}';Deferred(markup).toEqual([ferredBlock'],undDeferredTrigger', 'isVisible()'],merDeferredTrigger', 100],leDeferredTrigger'],ewportDeferredTrigger', 'button'],xt', 'hello'],    });    it('should allow new line after trigger name', () => {markup =`{#defer\nwhen\nisVisible(); on\ntimer(100ms),\nidle, viewport(button)}hello{/defer}`;Deferred(markup).toEqual([ferredBlock'],undDeferredTrigger', 'isVisible()'],merDeferredTrigger', 100],leDeferredTrigger'],ewportDeferredTrigger', 'button'],xt', 'hello'],    });    it('should parse a deferred block with a timeout set in seconds', () => {Deferred('{#defer on timer(10s)}hello{/defer}').toEqual([ferredBlock'],merDeferredTrigger', 10000],xt', 'hello'],    });    it('should parse a deferred block with a timeout that has no units', () => {Deferred('{#defer on timer(100)}hello{/defer}').toEqual([ferredBlock'],merDeferredTrigger', 100],xt', 'hello'],    });    it('should parse a deferred block with a hover trigger', () => {Deferred('{#defer on hover}hello{/defer}').toEqual([ferredBlock'],verDeferredTrigger'],xt', 'hello'],    });    it('should parse a deferred block with an interaction trigger', () => {Deferred('{#defer on interaction(button)}hello{/defer}').toEqual([ferredBlock'],teractionDeferredTrigger', 'button'],xt', 'hello'],    });    it('should parse a deferred block with secondary blocks', () => {Deferred('{#defer}' +'<calendar-cmp [date]="current"/>' +'{:loading}' +'Loading...' +'{:placeholder}' +'Placeholder content!' +'{:error}' +'Loading failed :(' +'{/defer}').toEqual([ ['DeferredBlock'], ['Element', 'calendar-cmp'], ['BoundAttribute', 0, 'date', 'current'], ['DeferredBlockPlaceholder'], ['Text', 'Placeholder content!'], ['DeferredBlockLoading'], ['Text', 'Loading...'], ['DeferredBlockError'], ['Text', 'Loading failed :('],]);    });    it('should parse a loading block with parameters', () => {Deferred('{#defer}' +'<calendar-cmp [date]="current"/>' +'{:loading after 100ms; minimum 1s}' +'Loading...' +'{/defer}').toEqual([ ['DeferredBlock'], ['Element', 'calendar-cmp'], ['BoundAttribute', 0, 'date', 'current'], ['DeferredBlockLoading', 'after 100ms', 'minimum 1000ms'], ['Text', 'Loading...'],]);    });    it('should parse a placeholder block with parameters', () => {Deferred('{#defer}' +'<calendar-cmp [date]="current"/>' +'{:placeholder minimum 1s}' +'Placeholder...' +'{/defer}').toEqual([ ['DeferredBlock'], ['Element', 'calendar-cmp'], ['BoundAttribute', 0, 'date', 'current'], ['DeferredBlockPlaceholder', 'minimum 1000ms'], ['Text', 'Placeholder...'],]);    });    it('should parse a deferred block with prefetch triggers', () => {html ='{#defer on idle; prefetch on viewport(button), hover; prefetch when shouldPrefetch()}hello{/defer}';Deferred(html).toEqual([ferredBlock'],leDeferredTrigger'],ewportDeferredTrigger', 'button'],verDeferredTrigger'],undDeferredTrigger', 'shouldPrefetch()'],xt', 'hello'],    });    it('should allow arbitrary number of spaces after the `prefetch` keyword', () => {html ='{#defer on idle; prefetchrt(button), hover; prefetch    when shouldPrefetch()}hello{/defer}';Deferred(html).toEqual([ferredBlock'],leDeferredTrigger'],ewportDeferredTrigger', 'button'],verDeferredTrigger'],undDeferredTrigger', 'shouldPrefetch()'],xt', 'hello'],    });    it('should parse a complete example', () => {Deferred('{#defer when isVisible() && foo; on hover, timer(10s), idle, immediate, ' +'interaction(button), viewport(container); prefetch on immediate; ' +'prefetch when isDataLoaded()}' +'<calendar-cmp [date]="current"/>' +'{:loading minimum 1s; after 100ms}' +'Loading...' +'{:placeholder minimum 500}' +'Placeholder content!' +'{:error}' +'Loading failed :(' +'{/defer}').toEqual([ ['DeferredBlock'], ['BoundDeferredTrigger', 'isVisible() && foo'], ['HoverDeferredTrigger'], ['TimerDeferredTrigger', 10000], ['IdleDeferredTrigger'], ['ImmediateDeferredTrigger'], ['InteractionDeferredTrigger', 'button'], ['ViewportDeferredTrigger', 'container'], ['ImmediateDeferredTrigger'], ['BoundDeferredTrigger', 'isDataLoaded()'], ['Element', 'calendar-cmp'], ['BoundAttribute', 0, 'date', 'current'], ['DeferredBlockPlaceholder', 'minimum 500ms'], ['Text', 'Placeholder content!'], ['DeferredBlockLoading', 'after 100ms', 'minimum 1000ms'], ['Text', 'Loading...'], ['DeferredBlockError'], ['Text', 'Loading failed :('],]);    });    it('should treat blocks as plain text inside ngNonBindable', () => {Deferred('<div ngNonBindable>' +'{#defer when isVisible() && foo; on hover, timer(10s); ' +'prefetch on immediate; prefetch when isDataLoaded()}' +'<calendar-cmp [date]="current"/>' +'{:loading}' +'Loading...' +'{:placeholder}' +'Placeholder content!' +'{:error}' +'Loading failed :(' +'{/defer}' +'</div>').toEqual([ ['Element', 'div'], ['TextAttribute', 'ngNonBindable', ''], [   'Text',   '{#defer when isVisible() && foo; on hover, timer(10s); prefetch on immediate; prefetch when isDataLoaded()}' ], ['Element', 'calendar-cmp'], ['TextAttribute', '[date]', 'current'], ['Text', '{:loading}'], ['Text', 'Loading...'], ['Text', '{:placeholder}'], ['Text', 'Placeholder content!'], ['Text', '{:error}'], ['Text', 'Loading failed :('], ['Text', '{/defer}'],]);    });    describe('block validations', () => {ould report syntax error in `when` trigger', () => {ctDeferredError('{#defer when isVisible(}hello{/defer}') .toThrowError(/Unexpected end of expression/);ould report unrecognized trigger', () => {ctDeferredError('{#defer unknown visible()}hello{/defer}') .toThrowError(/Unrecognized trigger/);ould report unrecognized block', () => {ctDeferredError('{#defer}hello{:unknown}world{/defer}') .toThrowError(/Unrecognized block "unknown"/);ould report multiple placeholder blocks', () => {ctDeferredError('{#defer}hello{:placeholder}p1{:placeholder}p2{/defer}') .toThrowError(/"defer" block can only have one "placeholder" block/);ould report multiple loading blocks', () => {ctDeferredError('{#defer}hello{:loading}l1{:loading}l2{/defer}') .toThrowError(/"defer" block can only have one "loading" block/);ould report multiple error blocks', () => {ctDeferredError('{#defer}hello{:error}e1{:error}e2{/defer}') .toThrowError(/"defer" block can only have one "error" block/);ould report unrecognized parameter in placeholder block', () => {ctDeferredError('{#defer}hello{:placeholder unknown 100ms}hi{/defer}') .toThrowError(/Unrecognized parameter in "placeholder" block: "unknown 100ms"/);ould report unrecognized parameter in loading block', () => {ctDeferredError('{#defer}hello{:loading unknown 100ms}hi{/defer}') .toThrowError(/Unrecognized parameter in "loading" block: "unknown 100ms"/);ould report any parameter usage in error block', () => {ctDeferredError('{#defer}hello{:error foo}hi{/defer}') .toThrowError(/"error" block cannot have parameters/);ould report if minimum placeholder time cannot be parsed', () => {ctDeferredError('{#defer}hello{:placeholder minimum 123abc}hi{/defer}') .toThrowError(/Could not parse time value of parameter "minimum"/);ould report if minimum loading time cannot be parsed', () => {ctDeferredError('{#defer}hello{:loading minimum 123abc}hi{/defer}') .toThrowError(/Could not parse time value of parameter "minimum"/);ould report if after loading time cannot be parsed', () => {ctDeferredError('{#defer}hello{:loading after 123abc}hi{/defer}') .toThrowError(/Could not parse time value of parameter "after"/);ould report unrecognized `on` trigger', () => {ctDeferredError('{#defer on foo}hello{/defer}') .toThrowError(/Unrecognized trigger type "foo"/);ould report missing comma after unparametarized `on` trigger', () => {ctDeferredError('{#defer on hover idle}hello{/defer}').toThrowError(/Unexpected token/);ould report missing comma after parametarized `on` trigger', () => {ctDeferredError('{#defer on viewport(button) idle}hello{/defer}') .toThrowError(/Unexpected token/);ould report mutliple commas after between `on` triggers', () => {ctDeferredError('{#defer on viewport(button), , idle}hello{/defer}') .toThrowError(/Unexpected token/);ould report unclosed parenthesis in `on` trigger', () => {ctDeferredError('{#defer on viewport(button}hello{/defer}') .toThrowError(/Unexpected end of expression/);ould report incorrect closing parenthesis in `on` trigger', () => {ctDeferredError('{#defer on viewport(but)ton}hello{/defer}') .toThrowError(/Unexpected token/);ould report stray closing parenthesis in `on` trigger', () => {ctDeferredError('{#defer on idle)}hello{/defer}').toThrowError(/Unexpected token/);ould report non-identifier token usage in `on` trigger', () => {ctDeferredError('{#defer on 123)}hello{/defer}').toThrowError(/Unexpected token/);ould report if identifier is not followed by an opening parenthesis', () => {ctDeferredError('{#defer on viewport[]}hello{/defer}').toThrowError(/Unexpected token/);ould report if parameters are passed to `idle` trigger', () => {ctDeferredError('{#defer on idle(1)}hello{/defer}') .toThrowError(/"idle" trigger cannot have parameters/);ould report if no parameters are passed into `timer` trigger', () => {ctDeferredError('{#defer on timer}hello{/defer}') .toThrowError(/"timer" trigger must have exactly one parameter/);ould report if `timer` trigger value cannot be parsed', () => {ctDeferredError('{#defer on timer(123abc)}hello{/defer}') .toThrowError(/Could not parse time value of trigger "timer"/);ould report if `interaction` trigger has more than one parameter', () => {ctDeferredError('{#defer on interaction(a, b)}hello{/defer}') .toThrowError(/"interaction" trigger can only have zero or one parameters/);ould report if parameters are passed to `immediate` trigger', () => {ctDeferredError('{#defer on immediate(1)}hello{/defer}') .toThrowError(/"immediate" trigger cannot have parameters/);ould report if parameters are passed to `hover` trigger', () => {ctDeferredError('{#defer on hover(1)}hello{/defer}') .toThrowError(/"hover" trigger cannot have parameters/);ould report if `viewport` trigger has more than one parameter', () => {ctDeferredError('{#defer on viewport(a, b)}hello{/defer}') .toThrowError(/"viewport" trigger can only have zero or one parameters/);ould report duplicate when triggers', () => {ctDeferredError('{#defer when isVisible(); when somethingElse()}hello{/defer}') .toThrowError(/Duplicate "when" trigger is not allowed/);ould report duplicate on triggers', () => {ctDeferredError('{#defer on idle; when isVisible(); on timer(10), idle}hello{/defer}') .toThrowError(/Duplicate "idle" trigger is not allowed/);ould report duplicate prefetch when triggers', () => {ctDeferredError( '{#defer prefetch when isVisible(); prefetch when somethingElse()}hello{/defer}') .toThrowError(/Duplicate "when" trigger is not allowed/);ould report duplicate prefetch on triggers', () => {ctDeferredError( '{#defer prefetch on idle; prefetch when isVisible(); prefetch on timer(10), idle}hello{/defer}') .toThrowError(/Duplicate "idle" trigger is not allowed/);ould report multiple minimum parameters on a placeholder block', () => {ctDeferredError( '{#defer}hello{:placeholder minimum 1s; minimum 500ms}placeholder{/defer}') .toThrowError(/Placeholder block can only have one "minimum" parameter/);ould report multiple minimum parameters on a loading block', () => {ctDeferredError('{#defer}hello{:loading minimum 1s; minimum 500ms}loading{/defer}') .toThrowError(/Loading block can only have one "minimum" parameter/);ould report multiple after parameters on a loading block', () => {ctDeferredError('{#defer}hello{:loading after 1s; after 500ms}loading{/defer}') .toThrowError(/Loading block can only have one "after" parameter/);    });  });  describe('switch blocks', () => {    // TODO(crisbeto): temporary utility while control flow is disabled by default.    function expectSwitch(html: string, preserveWhitespaces?: boolean) { expectFromR3Nodes(parse(html, {enabledBlockTypes: ['switch'], preserveWhitespaces}).nodes);    }    function expectSwitchError(html: string) { expect(() => parse(html, {enabledBlockTypes: ['switch']}));    }    it('should parse a switch block', () => {Switch(`{#switch cond.kind} {:case x()} X case {:case 'hello'} <button>Y case</button> {:case 42} Z case {:default} No case matched{/switch}oEqual([itchBlock', 'cond.kind'],itchBlockCase', 'x()'],xt', ' X case '],itchBlockCase', '"hello"'],ement', 'button'],xt', 'Y case'],itchBlockCase', '42'],xt', ' Z case '],itchBlockCase', null],xt', ' No case matched '],    });    // This is a special case for `switch` blocks, because `preserveWhitespaces` will cause    // some text nodes with whitespace to be preserve in the primary block.    it('should parse a switch block when preserveWhitespaces is enabled', () => {template = `itch cond.kind}{:case x()} X case{:case 'hello'} <button>Y case</button>{:case 42} Z case{:default} No case matcheditch}Switch(template, true).toEqual([xt', '\n  '],itchBlock', 'cond.kind'],itchBlockCase', 'x()'],xt', ' X case\n'],itchBlockCase', '"hello"'],xt', ' '],ement', 'button'],xt', 'Y case'],xt', '\n'],itchBlockCase', '42'],xt', ' Z case\n'],itchBlockCase', null],xt', ' No case matched\n  '],xt', '\n'],    });    it('should parse a switch block with optional parentheses', () => {Switch(`{#switch (cond.kind)} {:case (x())} X case {:case ('hello')} <button>Y case</button> {:case (42)} Z case {:default} No case matched{/switch}oEqual([itchBlock', 'cond.kind'],itchBlockCase', 'x()'],xt', ' X case '],itchBlockCase', '"hello"'],ement', 'button'],xt', 'Y case'],itchBlockCase', '42'],xt', ' Z case '],itchBlockCase', null],xt', ' No case matched '],    });    it('should parse a nested switch block', () => {Switch(`{#switch cond} {:case 'a'}   {#switch innerCond} {:case 'innerA'} Inner A {:case 'innerB'} Inner B   {/switch} {:case 'b'} <button>Y case</button> {:case 'c'} Z case {:default}   {#switch innerCond} {:case 'innerC'} Inner C {:case 'innerD'} Inner D {:default}   {#switch innerInnerCond}     {:case 'innerInnerA'} Inner inner A     {:case 'innerInnerA'} Inner inner B   {/switch}   {/switch}{/switch}oEqual([itchBlock', 'cond'],itchBlockCase', '"a"'],itchBlock', 'innerCond'],itchBlockCase', '"innerA"'],xt', ' Inner A '],itchBlockCase', '"innerB"'],xt', ' Inner B '],itchBlockCase', '"b"'],ement', 'button'],xt', 'Y case'],itchBlockCase', '"c"'],xt', ' Z case '],itchBlockCase', null],itchBlock', 'innerCond'],itchBlockCase', '"innerC"'],xt', ' Inner C '],itchBlockCase', '"innerD"'],xt', ' Inner D '],itchBlockCase', null],itchBlock', 'innerInnerCond'],itchBlockCase', '"innerInnerA"'],xt', ' Inner inner A '],itchBlockCase', '"innerInnerA"'],xt', ' Inner inner B '],    });    describe('validations', () => {ould report syntax error in switch expression', () => {ctSwitchError(`{#switch cond/.kind} {:case x()} X case {:default} No case matched{/switch}oThrowError(/Parser Error: Unexpected token \./);ould report syntax error in case expression', () => {ctSwitchError(`{#switch cond} {:case x(} X case{/switch}oThrowError(/Unexpected end of expression: x\(/);ould report if a block different from "case" and "default" is used in a switch', () => {ctSwitchError(`{#switch cond} {:case x()} X case {:foo} Foo{/switch}oThrowError(/Switch block can only contain "case" and "default" blocks/);ould report if a switch has no parameters', () => {ctSwitchError(`{#switch} {:case 1} case{/switch}oThrowError(/Switch block must have exactly one parameter/);ould report if a switch has more than one parameter', () => {ctSwitchError(`{#switch foo; bar} {:case 1} case{/switch}oThrowError(/Switch block must have exactly one parameter/);ould report if a case has no parameters', () => {ctSwitchError(`{#switch cond} {:case} case{/switch}oThrowError(/Case block must have exactly one parameter/);ould report if a case has more than one parameter', () => {ctSwitchError(`{#switch cond} {:case foo; bar} case{/switch}oThrowError(/Case block must have exactly one parameter/);ould report if a switch has multiple default blocks', () => {ctSwitchError(`{#switch cond} {:case foo} foo {:default} one {:default} two{/switch}oThrowError(/Switch block can only have one "default" block/);ould report if a default block has parameters', () => {ctSwitchError(`{#switch cond} {:case foo} foo {:default bar} bar{/switch}oThrowError(/Default block cannot have parameters/);    });  });  describe('for loop blocks', () => {    // TODO(crisbeto): temporary utility while control flow is disabled by default.    function expectLoop(html: string) { expectFromR3Nodes(parse(html, {enabledBlockTypes: ['for']}).nodes);    }    function expectLoopError(html: string) { expect(() => parse(html, {enabledBlockTypes: ['for']}));    }    it('should parse a for loop block', () => {Loop(`r item of items.foo.bar; track item.id}{{ item }}pty}There were no items in the list.r}qual([rLoopBlock', 'items.foo.bar', 'item.id'],undText', ' {{ item }} '],rLoopBlockEmpty'],xt', ' There were no items in the list. '],    });    it('should parse a for loop block with optional parentheses', () => {Loop(`r (item of items.foo.bar); track item.id}{{ item }}{/for}qual([rLoopBlock', 'items.foo.bar', 'item.id'],undText', '{{ item }}'],Loop(`r (item of items.foo.bar()); track item.id}{{ item }}{/for}qual([rLoopBlock', 'items.foo.bar()', 'item.id'],undText', '{{ item }}'],Loop(`r (   ( (item of items.foo.bar()) )   ); track item.id}{{ item }}{/for}qual([rLoopBlock', 'items.foo.bar()', 'item.id'],undText', '{{ item }}'],    });    it('should parse a for loop block with let parameters', () => {Loop(`r item of items.foo.bar; track item.id; let idx = $index, f = $first, c = $count; let l = $last, ev = $even, od = $odd}{{ item }}r}qual(['ForLoopBlock', 'items.foo.bar', 'item.id',{'$index': 'idx', '$first': 'f', '$last': 'l', '$even': 'ev', '$odd': 'od', '$count': 'c'}undText', ' {{ item }} '],    });    it('should parse nested for loop blocks', () => {Loop(`r item of items.foo.bar; track item.id}{{ item }}<div> {#for subitem of item.items; track subitem.id}<h1>{{subitem}}</h1>{/for}</div>pty}There were no items in the list.r}qual([rLoopBlock', 'items.foo.bar', 'item.id'],undText', ' {{ item }} '],ement', 'div'],rLoopBlock', 'item.items', 'subitem.id'],ement', 'h1'],undText', '{{ subitem }}'],rLoopBlockEmpty'],xt', ' There were no items in the list. '],    });    it('should parse a for loop block with a function call in the `track` expression', () => {Loop(`r item of items.foo.bar; track trackBy(item.id, 123)}{{ item }}{/for}qual([rLoopBlock', 'items.foo.bar', 'trackBy(item.id, 123)'],undText', '{{ item }}'],    });    describe('validations', () => {ould report if for loop does not have an expression', () => {ctLoopError(`{#for}hello{/for}`).toThrowError(/For loop does not have an expression/);ould report if for loop does not have a tracking expression', () => {ctLoopError(`{#for a of b}hello{/for}`) .toThrowError(/For loop must have a "track" expression/);ould report mismatching optional parentheses around for loop expression', () => {ctLoopError(`{#for (a of b; track c}hello{/for}`) .toThrowError(/Unclosed parentheses in expression/);ctLoopError(`{#for (a of b(); track c}hello{/for}`) .toThrowError(/Unexpected end of expression: b\(/);ctLoopError(`{#for a of b); track c}hello{/for}`) .toThrowError(/Parser Error: Unexpected token '\)'/);ould report unrecognized for loop parameters', () => {ctLoopError(`{#for a of b; foo bar}hello{/for}`) .toThrowError(/Unrecognized loop paramater "foo bar"/);ould report multiple `track` parameters', () => {ctLoopError(`{#for a of b; track c; track d}hello{/for}`) .toThrowError(/For loop can only have one "track" expression/);ould report invalid for loop expression', () => {t errorPattern = /Cannot parse expression\. For loop expression must match the pattern "<identifier> of <expression>"/;ctLoopError(`{#for //invalid of items}hello{/for}`).toThrowError(errorPattern);ctLoopError(`{#for item}hello{/for}`).toThrowError(errorPattern);ctLoopError(`{#for item in items}hello{/for}`).toThrowError(errorPattern);ctLoopError(`{#for item of    }hello{/for}`).toThrowError(errorPattern);ould report syntax error in for loop expression', () => {ctLoopError(`{#for item of items..foo}hello{/for}`).toThrowError(/Unexpected token \./);ould report for loop with multiple `empty` blocks', () => {ctLoopError(`{#for a of b} main {:empty} Empty one {:empty} Empty two{/for}oThrowError(/For loop can only have one "empty" block/);ould report empty block with parameters', () => {ctLoopError(`{#for a of b} main {:empty foo} empty{/for}oThrowError(/Empty block cannot have parameters/);ould report unrecognized loop blocks', () => {ctLoopError(`{#for a of b} main {:unknown} unknown{/for}oThrowError(/Unrecognized loop block "unknown"/);ould report an empty `let` parameter', () => {ctLoopError(`{#for item of items.foo.bar; track item.id; let }{/for}`) .toThrowError( /Invalid for loop "let" parameter. Parameter should match the pattern "<name> = <variable name>"/);ould report an invalid `let` parameter', () => {ctLoopError(`{#for item of items.foo.bar; track item.id; let i = $index, $odd}{/for}`) .toThrowError( /Invalid for loop "let" parameter\. Parameter should match the pattern "<name> = <variable name>"/);ould an unknown variable in a `let` parameter', () => {ctLoopError(`{#for item of items.foo.bar; track item.id; let foo = $foo}{/for}`) .toThrowError(/Unknown "let" parameter variable "\$foo"\. The allowed variables are:/);ould report duplicate `let` parameter variables', () => {ctLoopError( `{#for item of items.foo.bar; track item.id; let i = $index, f = $first, in = $index}{/for}`) .toThrowError(/Duplicate "let" parameter variable "\$index"/);    });  });  describe('if blocks', () => {    // TODO(crisbeto): temporary utility while control flow is disabled by default.    function expectIf(html: string) { expectFromR3Nodes(parse(html, {enabledBlockTypes: ['if']}).nodes);    }    function expectIfError(html: string) { expect(() => parse(html, {enabledBlockTypes: ['if']}));    }    it('should parse an if block', () => {If(` cond.expr; as foo}Main case was true!se if other.expr}Extra case was true!se}False case!}oEqual([Block'],BlockBranch', 'cond.expr', 'foo'],xt', ' Main case was true! '],BlockBranch', 'other.expr'],xt', ' Extra case was true! '],BlockBranch', null],xt', ' False case! '],    });    it('should parse an if block with optional parentheses', () => {If(` (cond.expr)}Main case was true!se if (other.expr)}Extra case was true!se}False case!}oEqual([Block'],BlockBranch', 'cond.expr'],xt', ' Main case was true! '],BlockBranch', 'other.expr'],xt', ' Extra case was true! '],BlockBranch', null],xt', ' False case! '],    });    it('should parse nested if blocks', () => {If(` a}{#if a1} a1 {:else} b1{/if}se if b}bse}{#if c1} c1 {:else if c2} c2 {:else} c3{/if}}oEqual([Block'],BlockBranch', 'a'],Block'],BlockBranch', 'a1'],xt', ' a1 '],BlockBranch', null],xt', ' b1 '],BlockBranch', 'b'],xt', ' b '],BlockBranch', null],Block'],BlockBranch', 'c1'],xt', ' c1 '],BlockBranch', 'c2'],xt', ' c2 '],BlockBranch', null],xt', ' c3 '],    });    describe('validations', () => {ould report an if block without a condition', () => {ctIfError(`{#if}hello{/if}oThrowError(/Conditional block does not have an expression/);ould report an unknown parameter in an if block', () => {ctIfError(`{#if foo; bar}hello{/if}oThrowError(/Unrecognized conditional paramater "bar"/);ould report an unknown parameter in an else if block', () => {ctIfError(`{#if foo}hello{:else if bar; baz}goodbye{/if}oThrowError(/Unrecognized conditional paramater "baz"/);ould report an if block that has multiple `as` expressions', () => {ctIfError(`{#if foo; as foo; as bar}hello{/if}oThrowError(/Conditional can only have one "as" expression/);ould report an else if block that has an `as` expression', () => {ctIfError(`{#if foo}hello{:else if bar; as alias}goodbye{/if}oThrowError(/"as" expression is only allowed on the primary "if" block/);ould report an unknown block inside an if block', () => {ctIfError(`{#if foo}hello{:unknown}goodbye{/if}oThrowError(/Unrecognized conditional block "unknown"/);ould report an if block inside an if block', () => {ctIfError(`{#if foo}hello{:if bar}goodbye{:else if baz}{/if}oThrowError(/Unrecognized conditional block "if"/);ould report an else block with parameters', () => {ctIfError(`{#if foo}hello{:else bar}goodbye{/if}oThrowError(/Else block cannot have parameters/);ould report a conditional with multiple else blocks', () => {ctIfError(`{#if foo}hello{:else}goodbye{:else}goodbye again{/if}oThrowError(/Conditional can only have one "else" block/);ould report an else if block after an else block', () => {ctIfError(`{#if foo}hello{:else}goodbye{:else if bar}goodbye again{/if}oThrowError(/Else block must be last inside the conditional/);    });  });});