/** * @license * Copyright Google LLC All Rights Reserved. * * Use of this source code is governed by an MIT-style license that can be * found in the LICENSE file at https://angular.io/license */import {ParseSourceSpan} from '../../src/parse_util';import * as t from '../../src/render3/r3_ast';import {parseR3 as parse} from './view/util';class R3AstSourceSpans implements t.Visitor<void> {  result: any[] = [];  visitElement(element: t.Element) {    this.result.push([nt', humanizeSpan(element.sourceSpan), humanizeSpan(element.startSourceSpan),zeSpan(element.endSourceSpan)    ]);    this.visitAll([t.attributes,t.inputs,t.outputs,t.references,t.children,    ]);  }  visitTemplate(template: t.Template) {    this.result.push([ate', humanizeSpan(template.sourceSpan), humanizeSpan(template.startSourceSpan),zeSpan(template.endSourceSpan)    ]);    this.visitAll([te.attributes,te.inputs,te.outputs,te.templateAttrs,te.references,te.variables,te.children,    ]);  }  visitContent(content: t.Content) {    this.result.push(['Content', humanizeSpan(content.sourceSpan)]);    t.visitAll(this, content.attributes);  }  visitVariable(variable: t.Variable) {    this.result.push([ble',zeSpan(variable.sourceSpan),zeSpan(variable.keySpan),zeSpan(variable.valueSpan),    ]);  }  visitReference(reference: t.Reference) {    this.result.push([ence', humanizeSpan(reference.sourceSpan), humanizeSpan(reference.keySpan),zeSpan(reference.valueSpan)    ]);  }  visitTextAttribute(attribute: t.TextAttribute) {    this.result.push([ttribute', humanizeSpan(attribute.sourceSpan), humanizeSpan(attribute.keySpan),zeSpan(attribute.valueSpan)    ]);  }  visitBoundAttribute(attribute: t.BoundAttribute) {    this.result.push([Attribute', humanizeSpan(attribute.sourceSpan), humanizeSpan(attribute.keySpan),zeSpan(attribute.valueSpan)    ]);  }  visitBoundEvent(event: t.BoundEvent) {    this.result.push([Event', humanizeSpan(event.sourceSpan), humanizeSpan(event.keySpan),zeSpan(event.handlerSpan)    ]);  }  visitText(text: t.Text) {    this.result.push(['Text', humanizeSpan(text.sourceSpan)]);  }  visitBoundText(text: t.BoundText) {    this.result.push(['BoundText', humanizeSpan(text.sourceSpan)]);  }  visitIcu(icu: t.Icu) {    this.result.push(['Icu', humanizeSpan(icu.sourceSpan)]);    for (const key of Object.keys(icu.vars)) {esult.push(['Icu:Var', humanizeSpan(icu.vars[key].sourceSpan)]);    }    for (const key of Object.keys(icu.placeholders)) {esult.push(['Icu:Placeholder', humanizeSpan(icu.placeholders[key].sourceSpan)]);    }  }  visitDeferredBlock(deferred: t.DeferredBlock): void {    this.result.push([redBlock', humanizeSpan(deferred.sourceSpan), humanizeSpan(deferred.startSourceSpan),zeSpan(deferred.endSourceSpan)    ]);    deferred.visitAll(this);  }  visitSwitchBlock(block: t.SwitchBlock): void {    this.result.push([hBlock', humanizeSpan(block.sourceSpan), humanizeSpan(block.startSourceSpan),zeSpan(block.endSourceSpan)    ]);    this.visitAll([block.cases]);  }  visitSwitchBlockCase(block: t.SwitchBlockCase): void {    this.result.push(itchBlockCase', humanizeSpan(block.sourceSpan), humanizeSpan(block.startSourceSpan)]);    this.visitAll([block.children]);  }  visitForLoopBlock(block: t.ForLoopBlock): void {    this.result.push([opBlock', humanizeSpan(block.sourceSpan), humanizeSpan(block.startSourceSpan),zeSpan(block.endSourceSpan)    ]);    this.visitAll([block.children]);    block.empty?.visit(this);  }  visitForLoopBlockEmpty(block: t.ForLoopBlockEmpty): void {    this.result.push(rLoopBlockEmpty', humanizeSpan(block.sourceSpan), humanizeSpan(block.startSourceSpan)]);    this.visitAll([block.children]);  }  visitIfBlock(block: t.IfBlock): void {    this.result.push([ck', humanizeSpan(block.sourceSpan), humanizeSpan(block.startSourceSpan),zeSpan(block.endSourceSpan)    ]);    this.visitAll([block.branches]);  }  visitIfBlockBranch(block: t.IfBlockBranch): void {    this.result.push(BlockBranch', humanizeSpan(block.sourceSpan), humanizeSpan(block.startSourceSpan)]);    this.visitAll([block.children]);  }  visitDeferredTrigger(trigger: t.DeferredTrigger): void {    let name: string;    if (trigger instanceof t.BoundDeferredTrigger) { 'BoundDeferredTrigger';    } else if (trigger instanceof t.ImmediateDeferredTrigger) { 'ImmediateDeferredTrigger';    } else if (trigger instanceof t.HoverDeferredTrigger) { 'HoverDeferredTrigger';    } else if (trigger instanceof t.IdleDeferredTrigger) { 'IdleDeferredTrigger';    } else if (trigger instanceof t.TimerDeferredTrigger) { 'TimerDeferredTrigger';    } else if (trigger instanceof t.InteractionDeferredTrigger) { 'InteractionDeferredTrigger';    } else if (trigger instanceof t.ViewportDeferredTrigger) { 'ViewportDeferredTrigger';    } else {new Error('Unknown trigger');    }    this.result.push([name, humanizeSpan(trigger.sourceSpan)]);  }  visitDeferredBlockPlaceholder(block: t.DeferredBlockPlaceholder): void {    this.result.push([redBlockPlaceholder', humanizeSpan(block.sourceSpan),zeSpan(block.startSourceSpan), humanizeSpan(block.endSourceSpan)    ]);    this.visitAll([block.children]);  }  visitDeferredBlockError(block: t.DeferredBlockError): void {    this.result.push([redBlockError', humanizeSpan(block.sourceSpan), humanizeSpan(block.startSourceSpan),zeSpan(block.endSourceSpan)    ]);    this.visitAll([block.children]);  }  visitDeferredBlockLoading(block: t.DeferredBlockLoading): void {    this.result.push([redBlockLoading', humanizeSpan(block.sourceSpan), humanizeSpan(block.startSourceSpan),zeSpan(block.endSourceSpan)    ]);    this.visitAll([block.children]);  }  private visitAll(nodes: t.Node[][]) {    nodes.forEach(node => t.visitAll(this, node));  }}function humanizeSpan(span: ParseSourceSpan|null|undefined): string {  if (span === null || span === undefined) {    return `<empty>`;  }  return span.toString();}function expectFromHtml(html: string, enabledBlockTypes?: string[]) {  const res = parse(html, {enabledBlockTypes});  return expectFromR3Nodes(res.nodes);}function expectFromR3Nodes(nodes: t.Node[]) {  const humanizer = new R3AstSourceSpans();  t.visitAll(humanizer, nodes);  return expect(humanizer.result);}describe('R3 AST source spans', () => {  describe('nodes without binding', () => {    it('is correct for text nodes', () => {FromHtml('a').toEqual([xt', 'a'],    });    it('is correct for elements with attributes', () => {FromHtml('<div a="b"></div>').toEqual([ement', '<div a="b"></div>', '<div a="b">', '</div>'],xtAttribute', 'a="b"', 'a', 'b'],    });    it('is correct for elements with attributes without value', () => {FromHtml('<div a></div>').toEqual([ement', '<div a></div>', '<div a>', '</div>'],xtAttribute', 'a', 'a', '<empty>'],    });    it('is correct for self-closing elements with trailing whitespace', () => {FromHtml('<input />\n  <span>\n</span>').toEqual([ement', '<input />', '<input />', '<input />'],ement', '<span>\n</span>', '<span>', '</span>'],    });  });  describe('bound text nodes', () => {    it('is correct for bound text nodes', () => {FromHtml('{{a}}').toEqual([undText', '{{a}}'],    });  });  describe('bound attributes', () => {    it('is correct for bound properties', () => {FromHtml('<div [someProp]="v"></div>').toEqual([ement', '<div [someProp]="v"></div>', '<div [someProp]="v">', '</div>'],undAttribute', '[someProp]="v"', 'someProp', 'v'],    });    it('is correct for bound properties without value', () => {FromHtml('<div [someProp]></div>').toEqual([ement', '<div [someProp]></div>', '<div [someProp]>', '</div>'],undAttribute', '[someProp]', 'someProp', '<empty>'],    });    it('is correct for bound properties via bind- ', () => {FromHtml('<div bind-prop="v"></div>').toEqual([ement', '<div bind-prop="v"></div>', '<div bind-prop="v">', '</div>'],undAttribute', 'bind-prop="v"', 'prop', 'v'],    });    it('is correct for bound properties via {{...}}', () => {FromHtml('<div prop="{{v}}"></div>').toEqual([ement', '<div prop="{{v}}"></div>', '<div prop="{{v}}">', '</div>'],undAttribute', 'prop="{{v}}"', 'prop', '{{v}}'],    });    it('is correct for bound properties via data-', () => {FromHtml('<div data-prop="{{v}}"></div>').toEqual([ement', '<div data-prop="{{v}}"></div>', '<div data-prop="{{v}}">', '</div>'],undAttribute', 'data-prop="{{v}}"', 'prop', '{{v}}'],    });    it('is correct for bound properties via @', () => {FromHtml('<div bind-@animation="v"></div>').toEqual([ement', '<div bind-@animation="v"></div>', '<div bind-@animation="v">', '</div>'],undAttribute', 'bind-@animation="v"', 'animation', 'v'],    });    it('is correct for bound properties via animation-', () => {FromHtml('<div bind-animate-animationName="v"></div>').toEqual(['Element', '<div bind-animate-animationName="v"></div>','<div bind-animate-animationName="v">', '</div>'undAttribute', 'bind-animate-animationName="v"', 'animationName', 'v'],    });    it('is correct for bound properties via @ without value', () => {FromHtml('<div @animation></div>').toEqual([ement', '<div @animation></div>', '<div @animation>', '</div>'],undAttribute', '@animation', 'animation', '<empty>'],    });  });  describe('templates', () => {    it('is correct for * directives', () => {FromHtml('<div *ngIf></div>').toEqual([mplate', '<div *ngIf></div>', '<div *ngIf>', '</div>'],xtAttribute', 'ngIf', 'ngIf', '<empty>'],ement', '<div *ngIf></div>', '<div *ngIf>', '</div>'],    });    it('is correct for <ng-template>', () => {FromHtml('<ng-template></ng-template>').toEqual([mplate', '<ng-template></ng-template>', '<ng-template>', '</ng-template>'],    });    it('is correct for reference via #...', () => {FromHtml('<ng-template #a></ng-template>').toEqual([mplate', '<ng-template #a></ng-template>', '<ng-template #a>', '</ng-template>'],ference', '#a', 'a', '<empty>'],    });    it('is correct for reference with name', () => {FromHtml('<ng-template #a="b"></ng-template>').toEqual(['Template', '<ng-template #a="b"></ng-template>', '<ng-template #a="b">', '</ng-template>'ference', '#a="b"', 'a', 'b'],    });    it('is correct for reference via ref-...', () => {FromHtml('<ng-template ref-a></ng-template>').toEqual([mplate', '<ng-template ref-a></ng-template>', '<ng-template ref-a>', '</ng-template>'],ference', 'ref-a', 'a', '<empty>'],    });    it('is correct for reference via data-ref-...', () => {FromHtml('<ng-template data-ref-a></ng-template>').toEqual(['Template', '<ng-template data-ref-a></ng-template>', '<ng-template data-ref-a>','</ng-template>'ference', 'data-ref-a', 'a', '<empty>'],    });    it('is correct for variables via let-...', () => {FromHtml('<ng-template let-a="b"></ng-template>').toEqual(['Template', '<ng-template let-a="b"></ng-template>', '<ng-template let-a="b">','</ng-template>'riable', 'let-a="b"', 'a', 'b'],    });    it('is correct for variables via data-let-...', () => {FromHtml('<ng-template data-let-a="b"></ng-template>').toEqual(['Template', '<ng-template data-let-a="b"></ng-template>', '<ng-template data-let-a="b">','</ng-template>'riable', 'data-let-a="b"', 'a', 'b'],    });    it('is correct for attributes', () => {FromHtml('<ng-template k1="v1"></ng-template>').toEqual(['Template', '<ng-template k1="v1"></ng-template>', '<ng-template k1="v1">','</ng-template>'xtAttribute', 'k1="v1"', 'k1', 'v1'],    });    it('is correct for bound attributes', () => {FromHtml('<ng-template [k1]="v1"></ng-template>').toEqual(['Template', '<ng-template [k1]="v1"></ng-template>', '<ng-template [k1]="v1">','</ng-template>'undAttribute', '[k1]="v1"', 'k1', 'v1'],    });  });  // TODO(joost): improve spans of nodes extracted from macrosyntax  describe('inline templates', () => {    it('is correct for attribute and bound attributes', () => {ugared form is-template ngFor [ngForOf]="items" let-item>div></div>g-template>FromHtml('<div *ngFor="let item of items"></div>').toEqual(['Template', '<div *ngFor="let item of items"></div>', '<div *ngFor="let item of items">','</div>'xtAttribute', 'ngFor', 'ngFor', '<empty>'],undAttribute', 'of items', 'of', 'items'],riable', 'let item ', 'item', '<empty>'],'Element', '<div *ngFor="let item of items"></div>', '<div *ngFor="let item of items">','</div>'e that this test exercises an *incorrect* usage of the ngForective. There is a missing 'let' in the beginning of the expressionch causes the template to be desugared into-template [ngFor]="item" [ngForOf]="items">div></div>g-template>FromHtml('<div *ngFor="item of items"></div>').toEqual(['Template', '<div *ngFor="item of items"></div>', '<div *ngFor="item of items">', '</div>'undAttribute', 'ngFor="item ', 'ngFor', 'item'],undAttribute', 'of items', 'of', 'items'],ement', '<div *ngFor="item of items"></div>', '<div *ngFor="item of items">', '</div>'],FromHtml('<div *ngFor="let item of items; trackBy: trackByFn"></div>').toEqual(['Template', '<div *ngFor="let item of items; trackBy: trackByFn"></div>','<div *ngFor="let item of items; trackBy: trackByFn">', '</div>'xtAttribute', 'ngFor', 'ngFor', '<empty>'],undAttribute', 'of items; ', 'of', 'items'],undAttribute', 'trackBy: trackByFn', 'trackBy', 'trackByFn'],riable', 'let item ', 'item', '<empty>'],'Element', '<div *ngFor="let item of items; trackBy: trackByFn"></div>','<div *ngFor="let item of items; trackBy: trackByFn">', '</div>'    });    it('is correct for variables via let ...', () => {FromHtml('<div *ngIf="let a=b"></div>').toEqual([mplate', '<div *ngIf="let a=b"></div>', '<div *ngIf="let a=b">', '</div>'],xtAttribute', 'ngIf', 'ngIf', '<empty>'],riable', 'let a=b', 'a', 'b'],ement', '<div *ngIf="let a=b"></div>', '<div *ngIf="let a=b">', '</div>'],    });    it('is correct for variables via as ...', () => {FromHtml('<div *ngIf="expr as local"></div>').toEqual([mplate', '<div *ngIf="expr as local"></div>', '<div *ngIf="expr as local">', '</div>'],undAttribute', 'ngIf="expr ', 'ngIf', 'expr'],riable', 'ngIf="expr as local', 'local', 'ngIf'],ement', '<div *ngIf="expr as local"></div>', '<div *ngIf="expr as local">', '</div>'],    });  });  describe('events', () => {    it('is correct for event names case sensitive', () => {FromHtml('<div (someEvent)="v"></div>').toEqual([ement', '<div (someEvent)="v"></div>', '<div (someEvent)="v">', '</div>'],undEvent', '(someEvent)="v"', 'someEvent', 'v'],    });    it('is correct for bound events via on-', () => {FromHtml('<div on-event="v"></div>').toEqual([ement', '<div on-event="v"></div>', '<div on-event="v">', '</div>'],undEvent', 'on-event="v"', 'event', 'v'],    });    it('is correct for bound events via data-on-', () => {FromHtml('<div data-on-event="v"></div>').toEqual([ement', '<div data-on-event="v"></div>', '<div data-on-event="v">', '</div>'],undEvent', 'data-on-event="v"', 'event', 'v'],    });    it('is correct for bound events and properties via [(...)]', () => {FromHtml('<div [(prop)]="v"></div>').toEqual([ement', '<div [(prop)]="v"></div>', '<div [(prop)]="v">', '</div>'],undAttribute', '[(prop)]="v"', 'prop', 'v'],undEvent', '[(prop)]="v"', 'prop', 'v'],    });    it('is correct for bound events and properties via bindon-', () => {FromHtml('<div bindon-prop="v"></div>').toEqual([ement', '<div bindon-prop="v"></div>', '<div bindon-prop="v">', '</div>'],undAttribute', 'bindon-prop="v"', 'prop', 'v'],undEvent', 'bindon-prop="v"', 'prop', 'v'],    });    it('is correct for bound events and properties via data-bindon-', () => {FromHtml('<div data-bindon-prop="v"></div>').toEqual([ement', '<div data-bindon-prop="v"></div>', '<div data-bindon-prop="v">', '</div>'],undAttribute', 'data-bindon-prop="v"', 'prop', 'v'],undEvent', 'data-bindon-prop="v"', 'prop', 'v'],    });    it('is correct for bound events via @', () => {FromHtml('<div (@name.done)="v"></div>').toEqual([ement', '<div (@name.done)="v"></div>', '<div (@name.done)="v">', '</div>'],undEvent', '(@name.done)="v"', 'name.done', 'v'],    });  });  describe('references', () => {    it('is correct for references via #...', () => {FromHtml('<div #a></div>').toEqual([ement', '<div #a></div>', '<div #a>', '</div>'],ference', '#a', 'a', '<empty>'],    });    it('is correct for references with name', () => {FromHtml('<div #a="b"></div>').toEqual([ement', '<div #a="b"></div>', '<div #a="b">', '</div>'],ference', '#a="b"', 'a', 'b'],    });    it('is correct for references via ref-', () => {FromHtml('<div ref-a></div>').toEqual([ement', '<div ref-a></div>', '<div ref-a>', '</div>'],ference', 'ref-a', 'a', '<empty>'],    });    it('is correct for references via data-ref-', () => {FromHtml('<div ref-a></div>').toEqual([ement', '<div ref-a></div>', '<div ref-a>', '</div>'],ference', 'ref-a', 'a', '<empty>'],    });  });  describe('ICU expressions', () => {    it('is correct for variables and placeholders', () => {FromHtml('<span i18n>{item.var, plural, other { {{item.placeholder}} items } }</span>').toEqual([ [   'Element',   '<span i18n>{item.var, plural, other { {{item.placeholder}} items } }</span>',   '<span i18n>', '</span>' ], ['Icu', '{item.var, plural, other { {{item.placeholder}} items } }'], ['Icu:Var', 'item.var'], ['Icu:Placeholder', '{{item.placeholder}}'],]);    });    it('is correct for nested ICUs', () => {FromHtml('<span i18n>{item.var, plural, other { {{item.placeholder}} {nestedVar, plural, other { {{nestedPlaceholder}} }}} }</span>').toEqual([ [   'Element',   '<span i18n>{item.var, plural, other { {{item.placeholder}} {nestedVar, plural, other { {{nestedPlaceholder}} }}} }</span>',   '<span i18n>', '</span>' ], [   'Icu',   '{item.var, plural, other { {{item.placeholder}} {nestedVar, plural, other { {{nestedPlaceholder}} }}} }' ], ['Icu:Var', 'nestedVar'], ['Icu:Var', 'item.var'], ['Icu:Placeholder', '{{item.placeholder}}'], ['Icu:Placeholder', '{{nestedPlaceholder}}'],]);    });  });  describe('deferred blocks', () => {    it('is correct for deferred blocks', () => {html = '{#defer when isVisible() && foo; on hover, timer(10s), idle, immediate, ' +'interaction(button), viewport(container); prefetch on immediate; ' +'prefetch when isDataLoaded()}' +'<calendar-cmp [date]="current"/>' +'{:loading minimum 1s; after 100ms}' +'Loading...' +'{:placeholder minimum 500}' +'Placeholder content!' +'{:error}' +'Loading failed :(' +'{/defer}';FromHtml(html, ['defer']).toEqual(['DeferredBlock','{#defer when isVisible() && foo; on hover, timer(10s), idle, immediate, ' +   'interaction(button), viewport(container); prefetch on immediate; ' +   'prefetch when isDataLoaded()}<calendar-cmp [date]="current"/>' +   '{:loading minimum 1s; after 100ms}Loading...' +   '{:placeholder minimum 500}Placeholder content!' +   '{:error}Loading failed :({/defer}','{#defer when isVisible() && foo; on hover, timer(10s), idle, immediate, ' +   'interaction(button), viewport(container); prefetch on immediate; ' +   'prefetch when isDataLoaded()}','{/defer}'undDeferredTrigger', 'when isVisible() && foo'],verDeferredTrigger', 'hover'],merDeferredTrigger', 'timer(10s)'],leDeferredTrigger', 'idle'],mediateDeferredTrigger', 'immediate'],teractionDeferredTrigger', 'interaction(button)'],ewportDeferredTrigger', 'viewport(container)'],mediateDeferredTrigger', 'immediate'],undDeferredTrigger', 'prefetch when isDataLoaded()'],'Element', '<calendar-cmp [date]="current"/>', '<calendar-cmp [date]="current"/>','<calendar-cmp [date]="current"/>'undAttribute', '[date]="current"', 'date', 'current'],'DeferredBlockPlaceholder', '{:placeholder minimum 500}Placeholder content!','{:placeholder minimum 500}', '<empty>'xt', 'Placeholder content!'],'DeferredBlockLoading', '{:loading minimum 1s; after 100ms}Loading...','{:loading minimum 1s; after 100ms}', '<empty>'xt', 'Loading...'],ferredBlockError', '{:error}Loading failed :(', '{:error}', '<empty>'],xt', 'Loading failed :('],    });  });  describe('switch blocks', () => {    it('is correct for switch blocks', () => {html = `{#switch cond.kind}` +`{:case x()} X case` +`{:case 'hello'} Y case` +`{:case 42} Z case` +`{:default} No case matched` +`{/switch}`;FromHtml(html, ['switch']).toEqual(['SwitchBlock','{#switch cond.kind}{:case x()} X case{:case \'hello\'} Y case{:case 42} Z case{:default} No case matched{/switch}','{#switch cond.kind}', '{/switch}'itchBlockCase', '{:case x()} X case', '{:case x()}'],xt', 'X case'],itchBlockCase', '{:case \'hello\'} Y case', '{:case \'hello\'}'],xt', 'Y case'],itchBlockCase', '{:case 42} Z case', '{:case 42}'],xt', 'Z case'],itchBlockCase', '{:default} No case matched', '{:default}'],xt', 'No case matched'],    });  });  describe('for loop blocks', () => {    it('is correct for loop blocks', () => {html = `{#for item of items.foo.bar; track item.id}` +`<h1>{{ item }}</h1>` +`{:empty}` +`There were no items in the list.` +`{/for}`;FromHtml(html, ['for']).toEqual(['ForLoopBlock','{#for item of items.foo.bar; track item.id}<h1>{{ item }}</h1>{:empty}There were no items in the list.{/for}','{#for item of items.foo.bar; track item.id}', '{/for}'ement', '<h1>{{ item }}</h1>', '<h1>', '</h1>'],undText', '{{ item }}'],rLoopBlockEmpty', '{:empty}There were no items in the list.', '{:empty}'],xt', 'There were no items in the list.'],    });  });  describe('if blocks', () => {    it('is correct for if blocks', () => {html = `{#if cond.expr; as foo}` +`Main case was true!` +`{:else if other.expr}` +`Extra case was true!` +`{:else}` +`False case!` +`{/if}`;FromHtml(html, ['if']).toEqual(['IfBlock','{#if cond.expr; as foo}Main case was true!{:else if other.expr}Extra case was true!{:else}False case!{/if}','{#if cond.expr; as foo}', '{/if}'BlockBranch', '{#if cond.expr; as foo}Main case was true!', '{#if cond.expr; as foo}'],xt', 'Main case was true!'],BlockBranch', '{:else if other.expr}Extra case was true!', '{:else if other.expr}'],xt', 'Extra case was true!'],BlockBranch', '{:else}False case!', '{:else}'],xt', 'False case!'],    });  });});