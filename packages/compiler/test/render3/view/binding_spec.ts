/** * @license * Copyright Google LLC All Rights Reserved. * * Use of this source code is governed by an MIT-style license that can be * found in the LICENSE file at https://angular.io/license */import * as e from '../../../src/expression_parser/ast';import * as a from '../../../src/render3/r3_ast';import {DirectiveMeta, InputOutputPropertySet} from '../../../src/render3/view/t2_api';import {R3TargetBinder} from '../../../src/render3/view/t2_binder';import {parseTemplate} from '../../../src/render3/view/template';import {CssSelector, SelectorMatcher} from '../../../src/selector';import {findExpression} from './util';/** * A `InputOutputPropertySet` which only uses an identity mapping for fields and properties. */class IdentityInputMapping implements InputOutputPropertySet {  private names: Set<string>;  constructor(names: string[]) {    this.names = new Set(names);  }  hasBindingPropertyName(propertyName: string): boolean {    return this.names.has(propertyName);  }}function makeSelectorMatcher(): SelectorMatcher<DirectiveMeta[]> {  const matcher = new SelectorMatcher<DirectiveMeta[]>();  matcher.addSelectables(CssSelector.parse('[ngFor][ngForOf]'), [{ name: 'NgFor', exportAs: null, inputs: new IdentityInputMapping(['ngForOf']), outputs: new IdentityInputMapping([]), isComponent: false, isStructural: true, selector: '[ngFor][ngForOf]', animationTriggerNames: null,}]);  matcher.addSelectables(CssSelector.parse('[dir]'), [{ name: 'Dir', exportAs: null, inputs: new IdentityInputMapping([]), outputs: new IdentityInputMapping([]), isComponent: false, isStructural: false, selector: '[dir]', animationTriggerNames: null,}]);  matcher.addSelectables(CssSelector.parse('[hasOutput]'), [{ name: 'HasOutput', exportAs: null, inputs: new IdentityInputMapping([]), outputs: new IdentityInputMapping(['outputBinding']), isComponent: false, isStructural: false, selector: '[hasOutput]', animationTriggerNames: null,}]);  matcher.addSelectables(CssSelector.parse('[hasInput]'), [{ name: 'HasInput', exportAs: null, inputs: new IdentityInputMapping(['inputBinding']), outputs: new IdentityInputMapping([]), isComponent: false, isStructural: false, selector: '[hasInput]', animationTriggerNames: null,}]);  matcher.addSelectables(CssSelector.parse('[sameSelectorAsInput]'), [{ name: 'SameSelectorAsInput', exportAs: null, inputs: new IdentityInputMapping(['sameSelectorAsInput']), outputs: new IdentityInputMapping([]), isComponent: false, isStructural: false, selector: '[sameSelectorAsInput]', animationTriggerNames: null,}]);  const simpleDirectives = ['a', 'b', 'c', 'd', 'e', 'f'];  const deferBlockDirectives = ['loading', 'error', 'placeholder'];  for (const dir of [...simpleDirectives, ...deferBlockDirectives]) {    const name = dir[0].toUpperCase() + dir.slice(1).toLowerCase();    matcher.addSelectables(CssSelector.parse(`[${dir}]`), [{   name: `Dir${name}`,   exportAs: null,   inputs: new IdentityInputMapping([]),   outputs: new IdentityInputMapping([]),   isComponent: false,   isStructural: true,   selector: `[${dir}]`,   animationTriggerNames: null, }]);  }  return matcher;}describe('t2 binding', () => {  it('should bind a simple template', () => {    const template = parseTemplate('<div *ngFor="let item of items">{{item.name}}</div>', '', {});    const binder = new R3TargetBinder(new SelectorMatcher<DirectiveMeta[]>());    const res = binder.bind({template: template.nodes});    const itemBinding =dExpression(template.nodes, '{{item.name}}')! as e.Interpolation).expressions[0] asopertyRead;    const item = itemBinding.receiver;    const itemTarget = res.getExpressionTarget(item);    if (!(itemTarget instanceof a.Variable)) { fail('Expected item to point to a Variable');    }    expect(itemTarget.value).toBe('$implicit');    const itemTemplate = res.getTemplateOfSymbol(itemTarget);    expect(itemTemplate).not.toBeNull();    expect(res.getNestingLevel(itemTemplate!)).toBe(1);  });  it('should match directives when binding a simple template', () => {    const template = parseTemplate('<div *ngFor="let item of items">{{item.name}}</div>', '', {});    const binder = new R3TargetBinder(makeSelectorMatcher());    const res = binder.bind({template: template.nodes});    const tmpl = template.nodes[0] as a.Template;    const directives = res.getDirectivesOfNode(tmpl)!;    expect(directives).not.toBeNull();    expect(directives.length).toBe(1);    expect(directives[0].name).toBe('NgFor');  });  it('should match directives on namespaced elements', () => {    const template = parseTemplate('<svg><text dir>SVG</text></svg>', '', {});    const matcher = new SelectorMatcher<DirectiveMeta[]>();    matcher.addSelectables(CssSelector.parse('text[dir]'), [{   name: 'Dir',   exportAs: null,   inputs: new IdentityInputMapping([]),   outputs: new IdentityInputMapping([]),   isComponent: false,   isStructural: false,   selector: 'text[dir]',   animationTriggerNames: null, }]);    const binder = new R3TargetBinder(matcher);    const res = binder.bind({template: template.nodes});    const svgNode = template.nodes[0] as a.Element;    const textNode = svgNode.children[0] as a.Element;    const directives = res.getDirectivesOfNode(textNode)!;    expect(directives).not.toBeNull();    expect(directives.length).toBe(1);    expect(directives[0].name).toBe('Dir');  });  it('should not match directives intended for an element on a microsyntax template', () => {    const template = parseTemplate('<div *ngFor="let item of items" dir></div>', '', {});    const binder = new R3TargetBinder(makeSelectorMatcher());    const res = binder.bind({template: template.nodes});    const tmpl = template.nodes[0] as a.Template;    const tmplDirectives = res.getDirectivesOfNode(tmpl)!;    expect(tmplDirectives).not.toBeNull();    expect(tmplDirectives.length).toBe(1);    expect(tmplDirectives[0].name).toBe('NgFor');    const elDirectives = res.getDirectivesOfNode(tmpl.children[0] as a.Element)!;    expect(elDirectives).not.toBeNull();    expect(elDirectives.length).toBe(1);    expect(elDirectives[0].name).toBe('Dir');  });  describe('matching inputs to consuming directives', () => {    it('should work for bound attributes', () => {template = parseTemplate('<div hasInput [inputBinding]="myValue"></div>', '', {});binder = new R3TargetBinder(makeSelectorMatcher());res = binder.bind({template: template.nodes});el = template.nodes[0] as a.Element;attr = el.inputs[0];consumer = res.getConsumerOfBinding(attr) as DirectiveMeta;(consumer.name).toBe('HasInput');    });    it('should work for text attributes on elements', () => {template = parseTemplate('<div hasInput inputBinding="text"></div>', '', {});binder = new R3TargetBinder(makeSelectorMatcher());res = binder.bind({template: template.nodes});el = template.nodes[0] as a.Element;attr = el.attributes[1];consumer = res.getConsumerOfBinding(attr) as DirectiveMeta;(consumer.name).toBe('HasInput');    });    it('should work for text attributes on templates', () => {template =parseTemplate('<ng-template hasInput inputBinding="text"></ng-template>', '', {});binder = new R3TargetBinder(makeSelectorMatcher());res = binder.bind({template: template.nodes});el = template.nodes[0] as a.Element;attr = el.attributes[1];consumer = res.getConsumerOfBinding(attr) as DirectiveMeta;(consumer.name).toBe('HasInput');    });    it('should not match directives on attribute bindings with the same name as an input', () => {template =parseTemplate('<ng-template [attr.sameSelectorAsInput]="123"></ng-template>', '', {});binder = new R3TargetBinder(makeSelectorMatcher());res = binder.bind({template: template.nodes});el = template.nodes[0] as a.Element;input = el.inputs[0];consumer = res.getConsumerOfBinding(input);(consumer).toEqual(el);    });    it('should bind to the encompassing node when no directive input is matched', () => {template = parseTemplate('<span dir></span>', '', {});binder = new R3TargetBinder(makeSelectorMatcher());res = binder.bind({template: template.nodes});el = template.nodes[0] as a.Element;attr = el.attributes[0];consumer = res.getConsumerOfBinding(attr);(consumer).toEqual(el);    });  });  describe('matching outputs to consuming directives', () => {    it('should work for bound events', () => {template =parseTemplate('<div hasOutput (outputBinding)="myHandler($event)"></div>', '', {});binder = new R3TargetBinder(makeSelectorMatcher());res = binder.bind({template: template.nodes});el = template.nodes[0] as a.Element;attr = el.outputs[0];consumer = res.getConsumerOfBinding(attr) as DirectiveMeta;(consumer.name).toBe('HasOutput');    });    it('should bind to the encompassing node when no directive output is matched', () => {template = parseTemplate('<span dir (fakeOutput)="myHandler($event)"></span>', '', {});binder = new R3TargetBinder(makeSelectorMatcher());res = binder.bind({template: template.nodes});el = template.nodes[0] as a.Element;attr = el.outputs[0];consumer = res.getConsumerOfBinding(attr);(consumer).toEqual(el);    });  });  describe('extracting defer blocks info', () => {    const templateOptions = {enabledBlockTypes: new Set(['defer'])};    it('should extract top-level defer blocks', () => {template = parseTemplate(` {#defer}<cmp-a />{/defer} {#defer}<cmp-b />{/defer} <cmp-c />`,'', templateOptions);binder = new R3TargetBinder(makeSelectorMatcher());bound = binder.bind({template: template.nodes});deferBlocks = bound.getDeferBlocks();(deferBlocks.length).toBe(2);    });    it('should extract nested defer blocks and associated pipes', () => {template = parseTemplate(` {#defer}   {{ name | pipeA }}   {#defer}{{ name | pipeB }}{/defer} {:loading}   {#defer}{{ name | pipeC }}{/defer}   {{ name | loading }} {:placeholder}   {#defer}{{ name | pipeD }}{/defer}   {{ name | placeholder }} {:error}   {#defer}{{ name | pipeE }}{/defer}   {{ name | error }} {/defer} {{ name | pipeF }}`,'', templateOptions);binder = new R3TargetBinder(makeSelectorMatcher());bound = binder.bind({template: template.nodes});deferBlocks = bound.getDeferBlocks();(deferBlocks.length).toBe(5);ord all pipes used within :placeholder, :loading and :error sub-blocks,o record pipes used outside of any {#defer} blocks.(bound.getEagerlyUsedPipes()).toEqual(['placeholder', 'loading', 'error', 'pipeF']);ord *all* pipes from the template, including the ones from {#defer} blocks.(bound.getUsedPipes()).toEqual([eA', 'pipeB', 'pipeD', 'placeholder', 'pipeC', 'loading', 'pipeE', 'error', 'pipeF'    });    it('should identify pipes used after a nested defer block as being lazy', () => {template = parseTemplate(`{#defer} {{ name | pipeA }} {#defer}{{ name | pipeB }}{/defer} {{ name | pipeC }}{/defer}`,'', templateOptions);binder = new R3TargetBinder(makeSelectorMatcher());bound = binder.bind({template: template.nodes});(bound.getUsedPipes()).toEqual(['pipeA', 'pipeB', 'pipeC']);(bound.getEagerlyUsedPipes()).toEqual([]);    });    it('should extract nested defer blocks and associated directives', () => {template = parseTemplate(` {#defer}   <img *a />   {#defer}<img *b />{/defer} {:loading}   {#defer}<img *c />{/defer}   <img *loading /> {:placeholder}   {#defer}<img *d />{/defer}   <img *placeholder /> {:error}   {#defer}<img *e />{/defer}   <img *error /> {/defer} <img *f />`,'', templateOptions);binder = new R3TargetBinder(makeSelectorMatcher());bound = binder.bind({template: template.nodes});deferBlocks = bound.getDeferBlocks();(deferBlocks.length).toBe(5);ord all directives used within :placeholder, :loading and :error sub-blocks,o record directives used outside of any {#defer} blocks.eagerDirs = bound.getEagerlyUsedDirectives();(eagerDirs.length).toBe(4);(eagerDirs.map(dir => dir.name)).toEqual([Placeholder', 'DirLoading', 'DirError', 'DirF'ord *all* directives from the template, including the ones from {#defer} blocks.allDirs = bound.getUsedDirectives();(allDirs.length).toBe(9);(allDirs.map(dir => dir.name)).toEqual([A', 'DirB', 'DirD', 'DirPlaceholder', 'DirC', 'DirLoading', 'DirE', 'DirError', 'DirF'    });    it('should identify directives used after a nested defer block as being lazy', () => {template = parseTemplate(`{#defer} <img *a /> {#defer}<img *b />{/defer} <img *c />{/defer}`,'', templateOptions);binder = new R3TargetBinder(makeSelectorMatcher());bound = binder.bind({template: template.nodes});allDirs = bound.getUsedDirectives().map(dir => dir.name);eagerDirs = bound.getEagerlyUsedDirectives().map(dir => dir.name);(allDirs).toEqual(['DirA', 'DirB', 'DirC']);(eagerDirs).toEqual([]);    });  });  describe('used pipes', () => {    it('should record pipes used in interpolations', () => {template = parseTemplate('{{value|date}}', '', {});binder = new R3TargetBinder(makeSelectorMatcher());res = binder.bind({template: template.nodes});(res.getUsedPipes()).toEqual(['date']);    });    it('should record pipes used in bound attributes', () => {template = parseTemplate('<person [age]="age|number"></person>', '', {});binder = new R3TargetBinder(makeSelectorMatcher());res = binder.bind({template: template.nodes});(res.getUsedPipes()).toEqual(['number']);    });    it('should record pipes used in bound template attributes', () => {template = parseTemplate('<ng-template [ngIf]="obs|async"></ng-template>', '', {});binder = new R3TargetBinder(makeSelectorMatcher());res = binder.bind({template: template.nodes});(res.getUsedPipes()).toEqual(['async']);    });    it('should record pipes used in ICUs', () => {template = parseTemplate(`<span i18n>{count|number, plural, =1 { {{value|date}} }}</span>`,'', {});binder = new R3TargetBinder(makeSelectorMatcher());res = binder.bind({template: template.nodes});(res.getUsedPipes()).toEqual(['number', 'date']);    });  });});