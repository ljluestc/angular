/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */   * This method will fail (throw) if there are components within the `ts.SourceFile` that do not
   * have TCBs available.   * allows the caller to hint to `getDiagnosticsF   * checking as part of the template type-checking program it creates.
   */
  getDiagnosticsForFile(sf: ts.SourceFile, optimizeFor: OptimizeFor): ts.Diagnostic[];  /**
   * Given a `shim` and position within the file, returns information for map   */
  getTemplateMappingAtTcbLocation(tcbLocation: Tcb   */
  getDiagnosticsForComponent(component: ts.ClassDeclaration): ts.Diagnostic[];  /**
   * Ensures shims for the whole program are generated. This type of operation would b   * check blocks generated from templates anywhere in the program.
   */   * Returns `true` if the given file is in the record of known shims generated by the compiler,
   * `false` if we cannot find the file in the shim records.  isTr   *
   * This can return `null` if there is no TCB available for the component.
   *
   * This method always runs in `OptimizeFor.SingleFile` mode.  getTypeCheckBlock(component: ts.ClassDeclaration): ts.Node|null;  /**
   * Retrieves a `Symbol` for the node in a component's template.   * This method can return `null` if a valid `Symbol` cannot be determined for the node.
   *
   * @see Symbol  getSymbolOfNode(node: TmplAstElement, component: ts.ClassDeclaration): ElementSymbol|null;
  getSymbolOfNode(node: TmplAstTemplate, component: ts.ClassDeclaration): TemplateSymbol|null;
  getSymbolOfNode(node: AST|TmplAstNode, component: ts.ClassDeclar   * include completions from the template's context component, as well as any local references or
   * template variables which are in scope for that expression.
   */
  getGlobalCompletions(      node: AST|TmplAstNode): GlobalCompletion|null;  /**   * autocompletion at that point in the expression, if such a location exists.
   */      expr: PropertyRead|SafePropertyRead, component: ts.ClassDeclaration): TcbLocation|null;  /**
   * For the given node represents a `LiteralPrimitive`(the `TextAttribute` represents a string
   * literal), retrieve a `TcbLocatio   */
  getLiteralCompletionLocation(
      strNode: LiteralPrimitive|TmplAstTextAttribute, component: t  getPotentialPipes(component: ts.ClassDeclaration): PotentialPipe[];  /**
   * Retrieve a `Map` of potential template element tags, to either the `PotentialDirective` that
   * declares them (if the tag is from a directive/component), or `null` if the tag originates from
   * the DOM schema.  getPotentialElementTags(component: ts.ClassDeclaration): Map<str   */
  getPotentialImportsFor(      importMode: PotentialImportMode): ReadonlyArray<PotentialImport>;  /**   * `@Injectable`.
   */
  getPrimaryAngularDecorator(target:    * probably means the provided component is standalone.
   */
  getOwningNgModule(component: ts.ClassDeclaration): ts.ClassDeclaration|null;  /**      */  getPotentialDomEvents(tagName: string): string[];  /**
   * Retrieve the type checking engine's metadata for the given directive class, if available.
   */   * Retrieve the type checking engine's metadata for the given NgModule class, if available.
   */
  getNgModuleMetadata(module: ts.ClassDeclaration): NgModuleMeta|null;  /**
   * Retrieve the type checking engine's metadata for the given pipe class, if  getPipeMetadata(pipe: ts.ClassDeclaration): PipeMeta|null;  /**    * Gets the pipes that have been used in a component's template.
   */   * Reset the `TemplateTypeChecker`'s state for the given class, so th   */   * Constructs a `ts.Diagnostic` for a given `ParseSourceSpan` within a template.
   */
  makeTemplateDiagnostic<T extends Er        start: number,
        end: number,
        sourceFile: ts.SourceFile,}/**  /**   * given file, and wants them as fast as possible.   * Indicates that a consumer of a `TemplateTypeCh   *
   * Initial calls to retrieve type-checking information may take longer, but repeated calls to
   * gather information for the whole user program will be significan}
