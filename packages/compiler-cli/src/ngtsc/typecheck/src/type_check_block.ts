/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */   * The caller must only use the generated TCB code in a context where such copies will still be
   * valid, such as an inlin}/**
 * Given a `ts.ClassDeclaration` for a component, and metadata regarding that component, compose a
 * "type check block" function. * When passed th *
 * As a side  * recorded in either the `domSchemaChecker` (which checks usage of DOM e * to sufficiently understand a template).
  * @param ref a `Reference` to the component class which should be type-checked.
 * @param name a `ts.Identifier` to use for the generated `ts.FunctionDeclaration`.
 * @param meta metadata about the component's template and the * and bindings. * translated into types during TCB generation.
 * @param gen */
export function generateTypeCheckBlock(
    env: Environment, ref: Reference<ClassDeclaration<ts.ClassDeclaration>>, name: ts.Identifier,
     genericContextBehavior: TcbGenericContextBehavior): ts.FunctionDeclaration {
  const tcb = new Context(
      env, domSchemaChecker, oobRecorder, meta.id, meta.boundT  const scope = S  if (!ts.isTypeReferenceNode(ctxRawType)) {
    throw new  }  let typeParameters: ts.TypeParameterDeclaration[]|undefined = undefined;
  let typeArguments: ts.TypeNode[]|undefined = undefined;  if (ref.node.typeParameters !== undefined) {
    if (!env.config.useContextGenericType) {
       case TcbGenericContextBehavior.UseEmitter:
        // Guaranteed to emit type parameters since we checked that the class has them above.
        typeParameters = new TypeParameterEmitter(ref.node.typeParameters, env.reflector)
    .emit(typeRef => env.referenceType(typeRef))!;
        typeArgum      case TcbGenericContextBehavior.CopyClassNodes:
        typeP           typeArguments = ref.node.typeParameters.map(
  () => ts.factory.createKeywordTypeNode(ts.SyntaxKind.An    }
  }  const paramList = [tcbThisParam(ctxRawType.typeName, typeArguments)];  const scopeStatements = scope.render();
   // the `ts.Printer` to format the type-check block nicely.
  const body = ts.factory.createBlock(
      [ts.factory.createIfStatement(ts.factory.createTrue(), innerBody, undefined)]);
  const fnDecl = ts.factory.createFunctionDeclaration(
      /* modifier      /* name */ name,
      /* typeParameters */ env.config.useContextGenericType ? typeParameters : undefined,
      /* parameters */ paramList,
     addTemplateId(fnDecl, meta.id);
  return fnDecl; * A code generation operation that's involved in the construction of a Type Check Block.
 * * construct certain types earlier than they otherwise would be constru * directive, extracting a variable from a let- operation, etc), then it's possible for operations
  *
 * Each `TcbOp` may insert statements into the body of the TCB, and also optionally return a
 * `ts.Expression` which can be used to reference the operation's result.
 */
abstract class TcbOp {
  /**
   * Set to true if this operation can be considered optional. Optional operations are only executed
   * when depended upon by other operations, otherwise they are disregarded. This allows for less
   * code to generate, parse and type-check, overall positively contributing to performance.
      * Replacement value or operation used while this `TcbOp` is executing (i.e. to resolve circular
   * references during its execution).   * circular references.
       return INFER_TYPE_FOR_CIRCULAR_OP_EXPR;}/**
 * A `TcbOp` which creates an expression for a native DOM element (or web component) from a
 * `T * Exclass TcbElementOp extends TcbOp {
  constructor(private tcb: Context, private scope: Scope, private element: TmplAstElement) {
    super();
  }  override get optional() {
    // The statement generated by this operation is only used for type-inference of the DOM
    // element's type and won't report diagnostics by itself, so the operation is marked as optional
    // to avoid generating statements for DOM elements that are never referenced.
    return true;
  }  override execute(): ts.Identifier {
    const id = this.tcb.allocateId();
   }/**
 * A `TcbOp` which creates an expression for particular l */
cla      private tcb: Context, private scope: Scope, private template: Tmp     return false;
  }  override execute(): ts.Identifier {
    /    /    const initializer = ts.factory.createPropertyAccessExpression(
        /* expression */ ctx,
        /* name */ this.variable.value || '$implicit');
       if (this.variable.valueSpan !== undefined) {
      addParseSpanInfo(initializer, this.variable.valueSpan);
      variable = tsCreateVariable(id, wrapForTypeChecker(initializer));
    } else {
      variable = tsCreateVariable(id, initializer);
       this.scope.addStatement(variable);
    return id;
  }c    super();
  }  // The declaration of the context variable is only n    const ctx = this.tcb.allocateId();
       return ctx;} * This operation wraps the children's type-checking code in an `if` block, which may include one
 * class TcbTemplateBodyOp extends TcbOp {
  con  }      // `if` is used for two reasons: it creates a new syntactic scope, isolating variables declared
    // in the template's TCB from the outer context, and it allows any directives on the templates
    // to perform type narrowing of either expressions or the template's context.
       // Collect these into `guards` by processing the directives.
    const directiveGuards: ts.Expression[] = [];    const directives = this.tcb.boundTarget.getDirectivesOfNode(this.template);
    if (directives !== null) {
      for (const dir of directives) {
        const dirInstId = this.scope.resolve(this.template, dir);
           // the expression passed to an @Input of the directive. Scan the directive to see if it has
        // any template guards, and generate them if needed.
        dir.ngTemplateGuards.forEach(guard => {
/    this.template.templateAttrs.find(       i instanceof TmplAstBoundAttribute  // If there is such a binding, generate an expression for it.
   markIgnoreDiagnostics(expr);  if (guard.type === 'binding') {
     } else {
  expr,
    ]);
     }   addParseSpanInfo(guardInvoke, this.template.sourceSpan);
  d    this.template.variables.length > 0 &&
    this.tcb.env.config.suggestionsForSuboptimalTypeInference) {
  // The compiler could have inferred a better typ}
         if (directiveGuards.length > 0) {
      // Pop the first value and use it as the initializer to reduce(). This way, a single guard
      // will be used on its own, but two or more will be combined into binary AND expressions.
       }    // Create a new Scope for the template. This constructs the list of operations for the template
    // children, as well as tracks bindings with    const statements = tmplScope.render();
    if (statements.length === 0) {
      // As an optimization, don't generate the scope's block if it has no statements. This is
      // beneficial for templates that contain for example `<span *ngIf="first"></span>`, in which
         return null;
    }    let tmplBlock: ts.Statement = ts.factory.createBlock(statements);
    if (guard !== null) {
       tmplBlock =    }  }
} */  constructor(private tcb: Context, private scope: Scope, private expression: AST) {
       return false;
   }
}/**
 * A `TcbOp` which constructs an instance of a directive. For generic directives, generic
 * parameters are set to `any` type.
 */
abstract class TcbDirectiveTypeOpBase extends TcbOp {
     return true;
  }    if (this.dir.isGeneric === false || dirRef.node.typeParameters === undefined) {
      type = rawType;
    } else {      }
            addExpressionIdentifier(type, ExpressionIdentifier.DIRECTIVE);
    addParseSpanInfo(type, this.node.star    return id;
  }
}/**
 * A `TcbOp` which constructs an instance of a non-generic directive _without_ setting any of its
 *  * Ex */
class TcbNonGenericDirectiveTypeOp extends TcbDi   */
  override execute(): ts.Identifier {
    const dirRef = this.dir.ref as Reference<ClassDeclaration<ts.ClassDeclaration>>;
    if (this.dir.isGeneric) {
   }/**
 * A  * `any` type. This is used for situations where we want to avoid inlining.
 *
  */  override execute(): ts.Identifier {dirRef.debugName}`);
  * access this variable as wel * var _t1 = document.createElement('div');
 *  * for a reference. In most cases, this isn't essential; that is, the information for the symbol
 *  * the shim file, but also to nar *
 * Executing this operation returns a reference to the directive instance variable with its inferred
 * type.
   constructor(
      private readonly tcb: Context, private readonly scope: Scope,
      private readonly node: TmplAstReference,
      private readonly host: TmplAstElement|TmplAstTemplate,
      private readonly target: TypeCheckableDirectiveMeta|TmplAstTemplate|TmplAstElement) {
     if ((this.target instanceof TmplAstElement && !this.tcb.env.config.checkTypeOfDomReferences) ||
         // `TemplateRef<any>`. To get this, an expression of the form
      // `(_t1 as any as TemplateRef<any>)` is constructed.
      initializer = ts.factory.createAsExpression(this.tcb.env.referenceExternalType('@angular/core', 'TemplateRef', [DYNAMIC_TYPE]));
       a}/**
 * A `TcbOp` which is used when the targe * itself is recorded out-of-band.
 */
c    super();
  }  // The declaration of a missing reference is only needed when the reference is resolved.
  o  } * A `TcbOp` which constructs an instance of a directive with types inferred from its inputs. The
 * inputs themselves are not checked here; check * When a Directive is generic, it is required that the TCB generates the instance using this method
 * in order to infer the type information correctly.
 *
 * Executing this operation returns a reference to the directive instance variable with its inferred
 *      super();
  }      // won't report diagnostics by itself, so the operation is marked as optional.
    return true;
     addExpressionIdentifier(id, ExpressionIdentifier.DIRECTIVE);
    addParseSpanInfo(id, this.node.startSourceSpan || this.node.sourceSpan);    const genericInputs = new Map<string, TcbDirectiveInput>();
    const boundAttrs = getBoundAttributes(this.dir, this.node);    for (const attr of boundAttrs) {
      // Skip text attributes if configattr.attribute instanceof TmplAstTextAttribute) {
        continue;
       }    for (const {classPropertyName} of this.dir.inputs) {
       // instance.
       this.scope.addStatement(tsCre  }  override circularFallback(): TcbOp {
    return new TcbDirectiveCtorCircularFallbackOp(this.tcb, this.scope, this.node, this.dir);
  }
} * members of a directive.
 *
 * Executing this operation returns nothing.
 */
class TcbDirectiveInputsOp extends TcbOp {
          const expr = widenBinding(translateInput(attr.attribute, this.tcb, this.scope), this.tcb);      let assignment: ts.Expression = wrapForDiagnostics(expr);      for (const {fieldName, required, transformType} of attr.inputs) {
     type = this.tcb.env.referenceTransplantedType(new TransplantedType(transformType));
} else {
  /}const id = this.tcb.allocateId();
this.scope.addStatement(tsDeclareVariable(id, type));target = id;
        } else if (this.dir.undeclaredInputFields.continue;
     thi const dirTypeRef = this.tcb.env.referenceType(this.dir.ref);
if (!ts.isTypeReferenceNode(dirTypeRef))  `Expected TypeReferenceNode from reference to ${this.dir.ref.debugName}`);
}
c    ts.factory.createLiteralTypeNode(ts.factory.createStringLiteral(fieldName)));
contarget = id;
        } else {  dirId = this.scope.resolve(thi// when possible. String literal fields may not be valid JS identifiers so we use
// literal element access instead for those cases.
targe   dirId, ts.factory.createIdentifier(fieldName));
        }        if (attr.attribute.keySpan !==         assignment =
  ts.factory.createBinaryExpression(target, ts.SyntaxKind.EqualsToken, assignment);
      }      addParseSpanInfo(assignment, attr.attribute.sourceSpan);
      // Ignore diagnostics for text attributes if configured to do so.
      if (!this.tcb.env.config.checkTypeOfAttributes &&
attr.attribute instanceof TmplAstTextAttribute) {      }      this.scope.addStatement(ts.factory.createExpressionStatement(assignment));
     const missing: BindingPropertyName[] = [];    for (const input of this.dir.inputs) {
           this.tcb.oobRecorder.missingRequiredInputs(
this.tcb.id, this.node, this.dir.name, this.dir.isComponent, missing);
  * via `TcbDirectiveCtorOp` requires a reference to its own type. This can happen using a template
 * reference: * ```html
 * <some-cmp #ref [prop]="ref.foo"></some-cmp> *
 * In this case, `TcbDirectiveCtorCircu * input expressions. This infers the widest possible supertype for the directive, which is used to
 * resolve any recursive references required to infer the real type.
    }  over  }  override execute(): ts.Identifier {    const typeCtor = this.tcb.env.typeCtorFor(this.dir);
    const circularPlaceholder = ts.factory.createCallExpression(
        typeCtor, /* typeArgum  }
}/* *
 *  */  c      private claimedInputs: Set<string>) {
    super();
  }  override get optional() {
 this.tcb.id, this.element, this.tcb.schemas, this.tcb.hostIsStandalone);
    }    // TODO(alxhub): this could be more efficient.
    for (const binding of this.element.inputs) {
      if (binding.type === BindingType.Property && this.claimedInputs.has(binding.name)) {
        // Skip this binding as it was claimed by a directive.
  */  'formaction': 'formAction',  'readonly': 'readOnly',}));/**
 * A `TcbOp` which generates code to check "un * itself.
 * * Executing this operclass TcbUnclaimedInputsOp extends TcbOp {
  constructor(
      private tcb: Context, private scope: Scope, private element: TmplAstElement,
     }  override get optional() {
    return false;    let elId: ts.Expression|null = null;    // TODO(alxhub):            continue;
 if (elId === null) {
  elId = this.scope.resolve(this.element);// A direct binding to a property.
const propertyName = ATTR_TO_PROP.get(binding.name) ?? binding.name;
conconst stmt = ts.factory.createBinaryExpression(
    prop, ts.SyntaxKind.EqualsToken, wrapForDiagnostics(expr));
add        }
}/** * outputs of a directive.
 *
 export class TcbDirectiveOutputsOp extends TcbOp {
  c      private dir: TypeCheckableDirectiveMeta) {
    super();    return false;
     const outputs = this.dir.outputs;    for (const output of this.node.outputs) {
      if (output.type !== ParsedEventType.Regular || !outputs.hasBindingPropertyName(output.name)) {
        continue;
           // TODO(alxhub): consider supporting multiple fields with the same property name for outputs.
      con      }      if (this.tcb.env.config.checkTypeOfOutputEvents) {
        // For strict checking of directive events, generate a call to the `subscribe` method
               const handler = tcbCreateEventHandler(output, this.tcb, this.scope, EventParamType.Infer);
        const subscribeFn = ts.factory.createPropertyAccessExpression(outputField, 'subscribe');
        const call =
  ts.factory.createCallExpression(subscribeFn, /* typeArguments */ undefined, [handler               // If strict checking of directive events is disabled:
       }      ExpressionSemanticVisitor.visit(    }    return null;
  } * * Executing this operation returns nothing.
 */
cla     super();
  }  override get optional() {
    return false;
  }  override execute(): null {    for (const output of this.element.outputs) {
      if (this.claimedOutputs.has(output.name)) {        continue;
      }      if (this.tcb.env.config.ch        if (isSplitTwoWayBinding(inputName, output, this.element.inputs, this.tcb)) {
// Skip this event handler as the error was already handled.
c   E                 // `$event` depending on the event name. For un        const handler = tcbCreateEventHandler(output, this.tcb, this.scope, EventParamType.Infer);        if (elId === null) {
elId = this.scope.resolve(this.element);
        }  /* expression */ propertyAccess,
         addParseSpanInfo(call, output.sourceSpan);
                const handler = tcbCreateEventHandler(output, this.tcb, this.scope, EventParamType.Any);
        this.scope.addStatement(ts.factory.createExpressionStatement(handler));
       }    return null;
  }
}/* *
 * This completion point looks like `this. ;` in the TCB output, and does not produce diagnostics.
 *  */
c    markIgnoreDiagnostics(ctxDot);
    a    return null;
  }
}/**
 * Value used to break a circular reference between `TcbOp`s.
 * *  * `Context` handles operations during code generation which are global with respect to the whole
 * block. It's responsible for varia  private nextId = 1;  constructor(      readonly oobRecorder: OutOfBandDiagnostic      private pipes: Map<string, Reference<ClassDeclaration<ts.ClassDeclaration>>>,
      * might change depending on the type of data being stored.  allocateId(): ts.Identifier {  }       return null;
    }  }
}/** * hierarchy. The stru *
 * As a template's `TcbOp`s are executed in a given `Scope`, statements are added via
 * `addStatement()`. When this processing is complete, the `Scope` can be turned into a `ts.Block`
 *  * class Scope {
  /**   *   * `INFER_TYPE_FOR_CIRCULAR_OP_EXPR`. This way, if a cy      */
    * directive on a `TmplAstElement` or `TmplAstTemplate` node.
   */      new Map<TmplAstElement|TmplAstTemplate, Map<TypeCheckableDirectiveMeta, number>>();  /**
   * A map of `TmplAstReference`s to the index of their `TcbReferenceOp` in the `opQueue`
   */
  private referenceOpMap = new Map<TmplAstReference, number>();  /**
   * Map of immediately nested <ng-template>s (within this `Scope`) represented by `TmplAstTemplate`
   * nodes to the index of their `TcbTemplateContextOp`s in the `opQueue`.
   */
  private templateCtxOpMap = new Map<TmplAstTemplate, number>();  /**
   *     *
    * `Scope`.   * calculate the `Scope`, or a list of nodes if no outer template object is available.
   * @param guard an expression that is applied to this scope for type narrowing purposes.
       tcb: Context, parent: Scope|null, templateOrNodes: TmplAstTemplate|(TmplAstNode[]),
         // Add an autocompletion point for the component context.
      scope.opQueue.push(new TcbComp      // The template's variable declarations need to be added as `TcbVariableOp`s.
         } else {tcb.oobRecorder.duplicateTemplateVar(tcb.id, v, firstDecl);
        }        const opIndex = scope.opQueue.push(new TcbVariableOp(tcb, scope, templateOrNodes, v)) - 1;
        scope.varMap.set(v, opIndex);
           scope.appendNode(node);
    }  }    * including any parent scope(s). This method always returns a mutable clone of the
   * `ts.Expression` with the comments cleared.   * @param node a `TmplAstNode` of the operation in question. The lookup performed will depend on
   * the type of this node:
   *
   * As   * * `TmplAstElement` - retrieve the expression for the element DOM node
   * * `TmplAstTemplate` - retrieve the template context variable
   * * `TmplAstVariable` - retrieve a template let- variable
   * * `TmplAstReference` - retrieve variable created for the local ref
   *
   * @p   */
       /      // _t1 /**T:DIR*/ /*1,2*/.input =           let clone: ts.Identifier|ts.NonNullExpression;      if (ts.isIdentifier(res)) {
         } else if (this.parent !== null) {
      // Check with the parent.
      }  /**
     addStatement(stmt: ts.Statement): void {
    this.statements.push(stmt);
  }   */      // by the TemplateTypeChecker.
      const skipOptional = !this.tcb.env.config.enableTemplateT    }
    ret   * Returns an expression of al   */
  guards(): ts.Expression|null {
              parentGuards, ts.SyntaxKind.AmpersandAmpersandToken, this.guard);
    }
  }  private resolveLocal(      directive?: TypeCheckableDirectiveMeta): ts.Expression|null {
    if (ref instanceof TmplAstReference && this.referenceOpMap.has(ref)) {
      return this.resolveOp(this.referenceOpMap.get(ref)!);
    }      // Execute the `TcbVariableOp` associated with the `TmplAstVariable`.
      return this.resolveOp(this.varMap.get(ref)!);
         this.templateCtxOpMap.has(ref)) {
                (ref instanceof TmplAstElement || ref instanceof TmplAstTemplate) &&
        directive !== undefined && this.directiveOpMap.has(ref)) {
              }
    } else if (ref instanceof TmplAstElement && this.elementOpMap.has(ref)) {
       }
  }  /**
     private resolveOp(opIndex: number): ts.Expression {
    * setting the operation's result to a special expression.
   */    const op = this.opQueue[opIndex];
    if (!(op instanceof TcbOp)) {
       return null;
    }    // Set the result of the operation in the queue to its circular fallback. If executing this
    // operation results in a circular dependency, this will prevent an infinite loop and allow for
       this.opQueue[opIndex] = res;  }  private appendNode(node: TmplAstNode): void {
         this.elementOpMap.set(node, opIndex);
      this.appendDirectivesAndInputs    } else if (node i      this.appendDir      const ctxIndex = this.opQueue.push(new Tc      if (this.tcb.env.config.checkTemplateBodies) {
         node.triggers.when !== undefined &&      node.prefetchTriggers.when !== undefined &&        } else if (node instanceof TmplAstIfBlock) {
      // TODO(crisbeto): type check the branch        this.appendChildren(branch);
       // TODO(crisbeto): type check switch conditi    } else if (node in      this.appendChildren(node);
      node.empty && this.appendChildren(node.empty);
    } else if (node instanceof TmplAstBoundText) {
        }  private appendChildren(node: TmplAstNode&{children: TmplAstNode[]}) {
    for (const child of node.children) {      if (target === null) {        this.tcb.oobRecorder.miss         } else {
     const directives = this.tcb.boundTarget.getDirectivesOfNode(node);
    if (directives === null || directives.length ===       // to add them if needed.        this.opQueue.push(new TcbUnclaimedInputsOp(this.tcb, this, node, claimedInputs));
        this.opQueue.push(
  new TcbDomSchemaCheckerOp(this.tcb, node, /* checkElement */ true, claimedInputs));
      }    }    const dirMap = new Map<TypeCheckableDirectiveMeta, number>();
    for (const dir of directives) {
      let directiveOp: TcbOp;
      const host = this.tcb.env.reflector;
      const dirRef = dir.ref as Reference<ClassDeclaration<ts.Cl        // `TcbNonDirectiveTypeOp`.
        directiveOp = new TcbNonGenericDirectiveTypeOp(this.tcb, this, node, dir);
             directiveOp = new TcbDirectiveCtorOp(this.tcb, this, node, dir);
       // Go through the directives and remove any inputs that it claims from `elementInputs`.
 claimedInputs.add(propertyName);
        }
      }      this.opQueue.push(new TcbUnclaimedInputsOp(this.tcb, this, node, claimedInputs));
      // If there are no directives which match this element, then it's a "plain" DOM element (or a
       // <router-outlet>) and shouldn't validate the element name itself.
       // Collect all the outputs on the element.
    const claimedOutputs = new Set<s      return;
       // Go through the directives an        for (const outputProperty of dir.outputs.propertyNames) {
claimedOu      }      this.opQueue.push(new TcbUnclaimedOutputsOp(this.tcb, this, node, claimedOutputs));
    }
  }  pr      if (!(node instanceof TmplAstElement || node instanceof TmplAstTemplate)) {
         const claimedInputs = new Set<string>();
        const directives = this.tcb.boundTarget.getDirectivesOfNode(node);
        l  for (const propertyName of dir.inputs.propertyNames) {
    claimedInputs.add(propertyName);
  }
}
        }
        this.opQueue.push(new TcbDomSchemaCheckerOp(this.tcb, node, !hasDirectives, claimedInputs));
      }  }  private appendIcuExpressions(node: TmplAstIcu): void {
    for (const variable of Object.values(node.vars)) {
      this.opQueue.push(new TcbExpressionOp(this.tcb, this, variable.value));
    }
    for (const placeholder of Object.values(node.placeholders)) {
      i      }
  */    name: ts.EntityName, typeArguments: ts.           /* name */ 'this',      /* type */ ts.factory.createTypeReferenceNode(name, typeArguments),
    */
funct  constructor(protected tcb: Context, protected scope: Scope) {}  translate(ast: AST): ts.Expression {
    // `astToTypescript` actually does the conversion. A special resolver `tcbResolve` is passed
    // which interprets specific expression nodes that interact with the `ImplicitReceiver`. These
          * context). This method assists in resolving those.
       if (ast instanceof PropertyRead && ast.receiver instanceof ImplicitReceiver) {
      // Try to resolve a bound target for this expression. If no such target is available, then
       } else if (ast instanceof PropertyWrite && ast.receiver instanceof Im      }      const expr = this.translate(ast.value);
      const result = ts.factory.createParenthesizedExpression(      addParseSpanInfo(result, ast.sourceSpan);
      r      // PropertyRead(ImplicitReceiver, 'propName') or Call(ImplicitReceiver, 'methodName').
      //
      // `translate` will first try to `resolve` the outer PropertyRead/Call. If this works,
      // it's because the `BoundTarget` found an expression target for the whole expression, and
           /           return ts.factory.createThis();
    } else if (ast instanceof BindingPipe) {
                   }
      const args = ast.args.map(arg => this.translate(arg));
         addParseSpanInfo(methodAccess, ast.nameSpan);        methodAccess = ts.factory.createAsExpression(
  methodAccess, ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword));
      }      const result = ts.factory.createCallExpression(
/* ex/* argumentsArray */[expr, ...args]);
      addParseSpanInfo(result, ast.sourceSpan);
         (ast instanceof Call || ast instanceof SafeCall) &&
        (ast.receiver instanceof PropertyRead || ast.receiver instanceof SafePropertyRead)) {
      // Resolve the special `$any(expr)` syntax to insert a cast of the argument to type `any`.
     !(ast.receiver.receiver instanceof ThisReceiver) && ast.receiver.name === '$any' &&
ast.args.length === 1) {
         expr, ts.factory.createKeywordTypeNode(ts.SyntaxKind.AnyKeyword));
        const result = ts.factory.createParenthesizedExpression(exprAsAny);
           }      // Attempt to resolve a bound target for the method, and generate the method call if a target
      // could be resolved. If no target is available, then the method is referencing the top-level
           return null;
         const args = ast.args.map(arg => this.translate(arg));
         return node;
     const binding = this.tcb.boundTarget.getExpressionTarget(ast);
    if (binding === null) {
      return null;
    }    return expr;
  }
}function tcbCallTypeCtor(
    d  const members = inputs.map(input => {
    const propertyName = ts.factory.createStringLiteral(input.field);    if (input.type === 'binding') {
         return assignment;         return ts.factory.createPropertyAssignment(propertyName, NULL_AS_ANY);
     // from the matched inputs.
  return ts.factory.createCallExpres}function getBoundAtt    node: TmplAstTem    // Skip non-property bindings.      return;
    }    // Skip the attribute if the directive does not hav        inputs: inputs.map(input => ({
    fieldName: input.classPropertyName,
    required: input.required,  }))        node.templateAttrs.forEach(processAttribute);
  }  return boundInputs; * Translates the given attribute binding to a `ts.Expression`.
     attr: TmplAstBoundAttribute|TmplAstTextAttribu  } else {    return ts.factory.createStringLiteral(attr.value);
  }
}/**
 * Potentially widens the type of `expr` according to the type-checking configuration.
 */
fun       return tsCastToAny(expr);
  } else if (!tcb.env.config.strictNullInputBindings) {
            return expr;      // If strict null checks are disabled, erase `null` and `und      return ts.factory.createNonNullExpression(expr);
    }    // No widening is requested, use the expression as is.  }
}/**
 * interface TcbDirectiveBoundInput {
 }/**
 * Indicates that a certain field of a directive doesinterface TcbDirectiveUnsetInput {   * The name of a field on the directive for which no input binding is present.
   */
  field: string;
}type TcbDirectiveInput = TcbDirectiveBoundInput|TcbDirectiveUn  Inf}/**
 * Creates an arrow function to be used as handler function for event bindings. The handler
 * function has a single parameter `$event` and the bound event's handler `AST` represented as a
 * TypeScript expression as its body.
 * * allows for the created handler function to have its `$event * parameter will have an explicit `any` type, effectively disabling strict type checking of event
 * bindings. Alternatively, an explicit type can be passed for the `$event` parameter.
 */    event: TmplAstBoundEvent, tcb: Context, scope: Sco  const handler = tcbEventHandlerExpression(event.handler, tcb, scope);  let eventParamType: ts.TypeNode|undefined;
  if (eventType === EventParamType.Infer) {
    eventParamType = undefined;
   addExpressionIdentifier(eventParam, ExpressionIdentifier.EVENT_PARAMETER);  // Return an arrow function instead of a function expression to preserve the `this` context.
       /* typeParameters */ undefined,
      /* parameters */[eventParam],
      /      /* body */ ts.factory.createBlock([body]));
}/**
 * Similar to `tcbExpression`, this function converts the provided `AST` expression into a
 * `ts.Expression`, with special handling of the `$event` variable that can be used within event
 * bindings.
 */  const input = inputs.find(input => input.name === inputName);
  if (input === undefined || input.s    return false;
   return false;  protected override resolve(ast: AST): ts.Expression|null {
    // Re    //     if (ast instanceof PropertyRead && ast.receiver instanceof ImplicitReceiver &&
        !(ast.receiver instanceof ThisReceiver) && ast.name === EVENT_PARAMETER) {
         }
}