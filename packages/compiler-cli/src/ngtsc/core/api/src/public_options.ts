/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */   *   *
   * @deprecated The `fullTemplateT   * deprecated, `strictTemplates` and its related options should be used instead.
   */
  fullTemplateTypeCheck?: boolean;  /**
   * Whether to generate a flat module index of the given name and the corresponding
   * flat module metadata. This opt   * When this option is used the `package.json` for the library should refer to the
   * generated flat module index instead of the library index file. When using this
   * option only one .metadata.jso   * In the generated .ngfactory.ts files flat module index is used to import symbols
   * including both the public API from the library index as well as shrouded internal
   * symbols.   * library index. If more than one is specified, uses `libraryIndex` to select the
   * file to use. If more than one .ts file is supplied and no `libraryIndex` is supplied
   * an error is produced.   * name in the same location as the library index .d.ts file is emitted.
   * For example, if a library uses `public_api.ts` file as the library index of the
   * module the `tsconfig.json` `fi   * produces `index.d.ts` and  `index.metadata.json` files. The library's
   * `package.json`'s `module` field would be `"index.js"` and the `typings` field would
   * be `"index.d.ts"`.  flatModuleOutFile?: string;  /**
   * Preferred module id to use for importing flat module. References generated by `ngc`
   * will use this module name when importing symbols from the flat module. This is only
   * meaningful when `flatModuleOutFile` is also supplied. It is otherwise ignored.
   */
  flatModuleId?: string;  /**
   * Always report errors a parame   * parameters of classes ma   * not provided is treated as if it were `false`.
   */
  strictInjectionParameters?: boolean;  /**
   * Whether to remove blank text nodes from compiled templates. It is `false` by default starting
   * from Angular 6.
   */}/**
 * Options related to template typ * @publicApiexport interface StrictTemplateOptions {
  /**
   * If `true`, implies all template s   * This flag is a superset of the deprecated `fullTemplateTypeCheck` option.
   *
   * Defaults to `false`, even if "fullTemplateTypeCheck" is `true`.
   */    *
   * For example, if this is `false` then the expression `[input]="expr"` will have `expr` type-
   * checked, but not the assignment of the resulting type to the `input` property of whichever
   * directive or component i   *
   * Defaults to `false`, even if "fullTemplateTypeCheck" is set.
   */   * Whether to check if the input binding attempts to assign to a restricted field (readonly,
   * private, or protected) on the directive/component.
   *
   * Defaults to `false`    * Tracking issue for enabling this by default: https://github.com/angular/angular/issues/38400
   */
  strictInputAccessModifiers?: boolean;  /**
   * Whether to use strict nu   * If this is `true`, applications that are compiled with TypeScript's `strictNullChecks` enabled
   * will produce type errors for bindings which can evaluate to `undefined` or `null` where the
   * inputs's type does not include `u   * Defaults to `false`, even if "fullTemplateTypeCheck" is set. Note that if `strictInputTypes` is
   * not set, or set to `false`, this flag has no effect.
   */
  strictNullInputTypes?:    * up being consumed as an input with type `boolean` by the `matInput` directive. At runtime, the
   * input will be set to the attribute's string value, which is an empty string for attributes
   * without a value, so with this flag   *
   * Defaults to `false`, eve   */
  strictAttributeTypes?: boolean;  /**
   * Whether to use a strict type for    * expression `a != null ? a.b : a`.
   *
   * Defaults to `false`, even if "fullTemplateTypeCheck" is set.
   */   * Whether to inf    * the type of `ref` for DOM nodes will be `any`.
   *
   * Defaults to `false`, even if "full  strictDomLocalRefTypes?: boolean;  /**
   * Whether to infer the type of the `$event` variable in event bindings for directive outputs or
   * animation events.
   *
   * If this is `true`, the type    * type `any`.
   *   * Whether to infer the type of the `$event` variable in event bindings to DOM events.
   *
   * If this is `true`, the type of `$event` will be inferred based on TypeScript's
   * `HTMLElementEventMap`, with    */
  strictDomEventTypes?: boolean;  /**
    * If no component has generic type parameters, this setting has no effect.
   *
   * If a component has generic type pa   * be set to `any` in the templat   * Defaults to `false`, even if "fullTemplateTypeCheck" is set.
   */
  strictContextGenerics?: boolean;  /**
   * Whether object or array literals defined in templates use their inferred type, or are
   * interpreted as `any`.   * Defaults to `false` unless `fullTemplateTypeCheck` or `strictTemplates` are set.
   */
  strictLiteralTypes?: boolea * A label referring to a `ts.Diagn *
 * @publicApi
 */
export enum DiagnosticCategoryLabel {
  /** Treat the diagnostic as a w}/**
 * Options which control how dia * @publicApi
 */
export interface DiagnosticOptions {
  /** Options which control how diagnostics are emitted from the compiler. */
  extendedDiagnostics?: {
    /**     * `warning` by default.    defaultCategory?: DiagnosticCategoryLabel;    /**
     * A map of each extended template diagnostic's name to its category. This can be expanded in
     * the future with more inform     */
    checks?: {[Name in ExtendedTemplateDiagnosticName]?: DiagnosticCategoryLabel};
  }; * Options which control behavior useful for "monorepo" build cases using Bazel (such as the
 * internal Google monorepo, g3).
 *  /**   * NgModule from that NgModule's file.
   *
   * This option should be disabled for application builds or for Angular Package Format libraries
   * (where NgModules along with their directives/pipes are exported via a single entrypoint).
   *    *
   * The compiler will attempt t   *
   * ```typescript
   * import {LibDir, LibCmp, LibPipe} from 'lib/deep/path/to/module';
   * ```
   *
   * It would be burdensome for users t   * private re-exports alongside t   */   * The `.d.ts` file for NgModules contain type pointers to their declarations, imports, and
   * exports. Without this flag, the generated type definition will include
   * components/directives/pipes/N   *
   * With this flag set, the type definition generated in the `.d.ts` for an NgModule will be
   * filtered to only list those    */
  annotateForClosureCompiler?: boolean;
}/**
  * @publicApi
 */  /**
   * Locale of the imported translations
   */
  i18nInLocale?: string;  /**
   * Export format (xlf, xlf2 or     *
   * The default value for now i   * Use this option when use are using the `$localize` based localization messages but
   * have not migrated the translation files to use the new `$localize` message id format.
   */
  enableI18nLegacyMessageIdFormat?: boolean;  /**
   * Whether translation variable name should contain external message id
   * (used by Closure Compiler's output of `goog.getMsg` for transition period)
   */
  i18nUseExternalIds?: boolean;  /*   * whether or not to normalize the line-endi   * parser to avoid normalizing line endings in ICU expressions.
   *
   * If `true` then we will normal   */
  i18nNormalizeLineEndingsInICUs?: boolean;
}/**  /**
   * Specifies the compilation mode to use. The following modes are available:
    * - 'experimental-local': generates code based on each individual source file without using its
    *
   * The default value is 'full'.  compilationMode?: 'full'|'partial'|'experimental-local';
}/**
 * Miscellaneous options that don't fall into any other category
 * */
export interface MiscOptions {
  /**  compileNonExportedClasses?: boo}
