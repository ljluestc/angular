/**
 * @license
 * Copyright Google LLC All Rights Reserved.
 *
 * Use of this source code is governed by an MIT-style license that can be
 * found in the LICENSE file at https://angular.io/license
 */    const transformers: ts.C   program.getTypeChecker(), reflectionHost, diagnostics,
   /* isCore */ false, isClosureEnabled)    }    let dtsOutput: string|n        testFile, ((fileN   output = outputText;
 } else if (fileName === TEST_FILE_DTS_OUTPUT) {
   dtsOutput = outputText;        }),
        undefined, undefined, transformers);
    diagnostics.push(...emitResult.diagnostics);
    expect(output).not.toBeNull();
    r      dtsOutput: dtsOutput   }  it('should downlevel decorators for @Injectable decorated class', () => {
    const {output} = transform(`
       import {Injectable} from '@angular/core';       export class ClassInject {};       @Injectable()
       export class MyService {
constructor(v: ClassInject) {}
       }
     `);    expect(diagnostics.length).toBe(0);
    expect(output).toContain(dedent`
       MyService.ctorParameters = () => [
  { type: ClassInject }
             (0, core_1.Injectable)()
       ], MyService);
       const {output} = transform(`
       import {Directive} from '@angular/core';       export class ClassInject {};       @Directive()
       export class MyDir {       }    expect(output).toContain(dedent`
       MyDir.ctorParameters = () => [
  { type: ClassInject }
       ];
       e       ], MyDir);
       `);
  });  it('should downlevel decorators for @Component decorated class', () => {
    const {output} = transform(`
       import {Component} from '@angular/core';       export class ClassInject {};       @Component({template: 'hello'})
       export class MyComp {
constructor(v: ClassInject) {}
       }
          ];
       exports.MyComp = MyComp = tslib_1.__deco       ], MyComp);`);    const {output} = transform(`
       import {Pipe} from '@angular/core';      constructor(v: ClassInject) {}       MyPipe.ctorParameters = () => [
{ type: ClassInject }
       ];
       exports.MyPipe = MyPipe = tslib_1.__decorate([
               `);
  });  it('should not downlevel non-Angular class decorators', () => {
    c       export class MyClass {}
     `);    expect(diagnostics.length).toBe(0);
    expect(output).toContain(dedent`SomeUnknownDecorator()     `);
    expect(output).not.toContain('MyClass.decorators');
  });  it('should not downlevel non-Angular class decorators generated by a builder', () => {
    const {output} = transform(`
          ], MyClass);
     `);  });  it('should downlevel Angular       }
     `);    expect(diagnostics.length).toB          expect(output).not.toContain('t     `);    expect(diagnostics.length).toBe(0);
    expect(output).toContain(dedent`
       tslib_1.__decorate([
SomeDecorator()
       ]    expect(output).not.toContain('MyClass.propDecorators');
  });  // caused invalid generation of the `ctorParameters` static class member.
  it(    // decorators are preserved and emitted by TypeScript itself. This setting is also
    // d       export class Wrapper {
constructor(y: ZoneToken) {  class ShouldBeProcessed {  }
}
         expect(output).toContain(dedent`
      let Wrapper = class Wrapper {
      (0, core_1.Injectable)()
 ], ShouldBeProcessed);         `);    const {output} = transform(`
       i@Input() trigger: HTMLElement;       }  trigger: [{ type: core_1.Input }],    cons       import {Directive} from '@angular/core';
       import {MyOtherClass} from './other-file';       @Directive()
       export class MyDir {
constructor(other: MyOtherClass) {}
       }        {emitDecoratorMetadata: true});    expect(diagnostics.length).toBe(0);
    e       ];
             tslib_1.__metadata("design:paramtypes", [other_file_1.MyOtherClass])
       ]       export class MyDir {
constructor(other: MyOtherClass) {}     `,    expect(output).toContain('const other_file_1 = require("./other-file");');
    expect(output).toContain(dedent`
             (0, core_1.Directive)()
       ], MyDir);
     `);  });  i    const {output} = transform(`
            export class MyDir {
constructor(other: externalFile.MyOtherClass) {}
       }    e       MyDir.ctorParameters =     const {output} = transform(`
       iconstructor(other: other.OtherClas     `);    expect(diagnostics.leng{ type: other.OtherClass }
       ];
       exports.MyDir = MyDir = tslib_1.__decorate([
               }
     `);       MyDir.ctorParameters = () => [
{ type: Document, decorators: [{ type: core_1.Inj       exports.MyDir = MyDir = tslib_1.__decorate([
        (0, core_1.Directive)()
       ], MyDir);
     `);
  });  it('should properly downlevel constructor parameters with union type', () => {
    const {output} = transform(`       export class MyDir {
const       MyDir.ctorParameters = () => [
{ typ       exports.MyDir = MyDir = tslib_1.__decorate([
              exports.MyDir = MyDir = tslib_1.__decorate([
        (0, core_1.Directive)()     `);        *   type: ?,
        *   decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>),
     { type: ClassInject }
       ];
     `);'`emi          export class ClassInject {}
     `);
       const {output} = transform(       import {Directive, Inject} from '@angular/core';
       import {ErrorHandler, ClassInject} from './external';       export class MyDir {
private _errorHandler: ErrorHandler;
constructor(@Inject(ClassInject) i: ClassInject) {}
       }  {module: ts.ModuleKind.ES2015, emitDecoratorMetadata: true});       expect(diagnostics.length).toBe(0);
          });  it('should not retain unused type imports due to decorator downleveling with ' +
'`emi            import {Directive, Inject} from '@angular/core';
       import {ErrorHandler, ClassInject} from './external';       export class MyDir {
private     context.writeFile('/external.tgreet()      `);       import {Dep} from './external';       @Directive()
       export class MyDir {
constructor(Dep: Dep) {
  Dep       }
                     (0, core_1.Directive)()
       ], MyDir);
     `);       export class MyDir {
constructor(@Optional() @SkipSelf() @Inject(MyDir     `);    expect(diagnostics.length).toBe(0);
    expect(output).toContain(dedent`
       let MyDir = class MyDir {
       constructor(parentDir) { }
            MyDir.ctorParameters = () => [
{ type: MyDir, decorators: [{ type: cor       ], MyDir);
            }
     `);    expect(diagnostics.length).toBe(1);
    expect(diagnostics[0].messageText as string)
        .toBe(`Cannot process decorators for class element with non-analyzable name.`);
  });  i     `);    expect(diagnostics.length).toBe(0);
    expect(output).not.toContain('external');
    expect(output).toContain(dedent`
       MyDir.ctorParameters = () => [
{ type: undefined, decorators: [{ type: { type: undefined, decorators: [{ type: core_1.Inject, args: ['$default',] }] },
{ type: undefined, decorators: [{ type: core_1.Inject, args: ['$keyCodes',] }] }
       ];
       });  it('should allow preceding custom transformers to strip decorators', () => {
    const stripAllDecoratorsTransform: ts.TransformerFactory<ts.SourceFile> = context => {
      return (sourceFile: ts.SourceFile) => {
        return ts.factory.createClassDeclaration(
 ts.g }        };
        return visitNode(sourceFile) as ts.SourceFile;
      };        `
       import {Directive} from '@angular/core';       exportconstructor(someToken: MyInjectedClass) {}
       }
     `,
            expect(output).not.toContain('MyDir.ctorParameters');  });  it('should capture a non-const enum used as a constructor type', () => {
    c       e       }
            MyComp.ctorParameters = () => [
{ type: Values }       exports.MyComp = MyComp = tslib_1.__decorate([
            `);
  });  it('should allow for type-only references to be remov       context.writeFile('/external-interface.ts', `
               expect(output).not.toContain('ExternalInterface');
       expect(output).toContain('metadata("design:returntype", Object)');
     });      context.writeFile('foo_service.d.ts', `
export d      context.writeFile('foo.ts', `
import {Injectable} from '@angular/corexport class MyService {
  constructor(foo: Foo) {}
}
            `);
       constructor(bar: Bar) {}
}
           // The decorators transform used to patch `ts.EmitResolver.isReferencedAliasDeclaration`
      // repeatedly for each source file in the program, causing a stack overflow once a large
      //        const file = `/${i}.ts`;
        files.push(file);  import  export class MyService {
    constructor(foo: Foo) {}
  }
`);
             written++;        // The below assertion throws an explicit error instead of using a Jasmine expectation,
        // as we want to abort on the f        }
      files,    module: ts.ModuleKind.ESNext,
   target: ts.ScriptTarget.Latest,
   declaration: false,
   exper },
 host);
      const typeChecker = program.getTypeChecker();
             before: [getDownle   /*  });
});/** Template string function that can be used  joinedString += strings[string  return text.replace(/^\s+/gm, '');